[{"id":"a9c296a21c9159598134e76871675b03","title":"杭州一日游","content":"杭州一日游攻略：穿越古今，尽赏玉皇山、南宋御街与城隍阁上午：玉皇山景区景点特色介绍：\n\n玉皇山位于西湖与钱塘江之间，海拔237米，是杭州的一处著名自然与文化景观。山上有玉皇宫，据传是为纪念玉皇大帝而建，每年农历春节和重阳节，这里都会举行盛大的祈福活动。站在山顶，你可以享受到“玉皇飞云”的绝美景致，远眺西湖美景，钱塘江如带，城市风貌尽收眼底。此外，山中的紫来洞、八卦田等也是不可错过的自然奇观和人文景观。\n\n建议行程：\n\n早上8:30到达玉皇山景区入口，购票进入。\n沿着登山步道缓缓而上，途中可欣赏沿途的自然风光。\n到达山顶后，在玉皇宫稍作停留，感受道教文化的氛围。\n下山时不妨绕道八卦田，了解古代农业的智慧布局。\n11:30左右结束玉皇山行程，前往下一站南宋御街。\n\n中午：南宋御街午餐体验景点特色介绍：\n\n南宋御街是南宋时期临安城的主要街道，现经改造成为集历史、文化、商业于一体的步行街区。街道两旁保留了不少宋代建筑风格的店铺，你可以在其中寻找传统美食，如南宋小吃、杭州特色茶楼等。此外，南宋御街博物馆、晓风书屋等地可以让你更深入地了解南宋文化和历史。\n\n建议行程：\n\n12:30在南宋御街选择一家具有南宋特色的餐馆享用午餐。\n餐后，漫步在石板路上，逛逛特色小店，感受古街的韵味。\n可以参观南宋御街博物馆、鼓楼、凤凰寺等，增加对这段历史的认识。\n\n下午：城隍阁景区景点特色介绍：\n\n城隍阁位于吴山之巅，是一座七层仿古楼阁，不仅本身建筑雄伟，而且是俯瞰杭州全城的绝佳位置。城隍阁内部展示了许多以南宋为背景的浮雕，重现了古时吴山庙会的热闹景象。登上城隍阁顶，西湖美景、钱塘江及杭州城景致一览无遗，尤其傍晚时分，城市的灯光与自然景色交相辉映，美不胜收。\n\n建议行程：\n\n14:30到达城隍阁景区，购票并开始攀登。\n游览过程中，不妨留意沿途的碑亭与历史文化介绍。\n登至城隍阁顶层，享受杭州全景，拍照留念。\n傍晚时分，可在阁内或附近找个好位置，静待日落与夜景的转换。\n\n注意事项：\n\n记得提前查看各景点的开放时间和门票价格，部分景点可能需要在线预约。\n穿着舒适的鞋子，特别是爬玉皇山时。\n夏季出行，请做好防晒措施，并随身携带足够的水。\n\n通过这样的安排，你将能充分体验到杭州从自然美景到历史文化的独特魅力。\n","slug":"杭州一日游","date":"2024-06-02T00:57:00.000Z","categories_index":"旅行","tags_index":"旅游","author_index":"kiyose408"},{"id":"698bdaa973d597a4a390a291dbaefc44","title":"模版特例化","content":"特例化介绍模板特例化主要是用于在模板特定情况下的一些特殊定义，用来完善模板在特定情况的调用 我们先实现一个函数模板\n12345678910template &lt;typename T&gt;int compare(const T &amp;v1, const T &amp;v2)&#123;    cout &lt;&lt; &quot;use compare T&amp;&quot; &lt;&lt; endl;    if (v1 &lt; v2)        return -1;    if (v2 &lt; v1)        return 1;    return 0;&#125;\n\n接下来我们实现一个带字面值常量的特例化版本\n1234567//带字面常量的比较函数template &lt;size_t N, size_t M&gt;int compare(const char (&amp;a1)[N], const char (&amp;a2)[M])&#123;    cout &lt;&lt; &quot;use const char (&amp;)[N]&quot; &lt;&lt; endl;    strcmp(a1, a2);&#125;\n\n我们实现一个testcompare函数测试普通版和特例话版本的函数调用\n123456789void testcompare()&#123;    const char *p1 = &quot;h1&quot;;    const char *p2 = &quot;mom&quot;;    //调用特例化版本    compare(p1, p2);    //调用第二个版本    compare(&quot;hi&quot;, &quot;mom&quot;);&#125;\n\n当调用特例化版本时，N会被设定为”h1”的长度，M会被设定为”mom”长度。 但是我们发现使用通用模板类型的函数compare在被叫指针p1和p2时不是很理想，可以单独实现针对p1和p2指针特定版的模板函数\n1234567891011template &lt;&gt;int compare(const char* &amp;v1, const char* &amp;v2)&#123;    cout &lt;&lt; &quot;use compare char * &quot; &lt;&lt; endl;    if (strlen(v1) &lt; strlen(v2))        return -1;    else if (strlen(v2) &lt; strlen(v1))        return 1;    else         return strcmp(v1, v2);&#125;\n\n对于char * 版本我们实现了自己的比较规则，如果长度长的那个就是大值，相等则依次比较字符串中的每个字符。\n类模板类模板的使用和函数模板类似，我们先声明两个模板类，然后为模板类声明一个比较函数重载运算符\n12345678template &lt;typename&gt;class BlobPtr;template &lt;typename&gt;class Blob;template &lt;typename T&gt;bool operator==(const Blob&lt;T&gt; &amp;, const Blob&lt;T&gt; &amp;);\n\n我们实现Blob&lt;T&gt;模板类\n1234567891011121314151617181920212223242526272829303132333435363738394041//定义模板类型的blobtemplate &lt;typename T&gt;class Blob&#123;public:    typedef T value_type;    typedef typename std::vector&lt;T&gt;::size_type size_type;    // T类型的BlobPtr是T类型的Blob的友元类    friend class BlobPtr&lt;T&gt;;    //重载==运算符    friend bool operator==(const Blob&lt;T&gt; &amp;, const Blob&lt;T&gt; &amp;);    //构造函数    Blob()    &#123;        data = make_shared&lt;std::vector&lt;T&gt;&gt;();    &#125;    Blob(std::initializer_list&lt;T&gt; il)    &#123;        data = make_shared&lt;std::vector&lt;T&gt;&gt;(il);    &#125;    template &lt;typename It&gt;    Blob(It b, It e);    // Blob 中元素数目    size_type size() const &#123; return data-&gt;size(); &#125;    bool empty() const &#123; return data-&gt;empty(); &#125;    //添加和删除元素    void push_back(const T &amp;t) &#123; data-&gt;push_back(t); &#125;    //移动版本的push_back    void push_back(const T &amp;&amp;t) &#123; data-&gt;push_back(std::move(t)); &#125;    //删除元素    void pop_back();    //元素访问    T &amp;back();    T &amp;operator[](size_type i);private:    std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;    //校验数据是否有效    void check(size_type i, const std::string &amp;msg) const;&#125;;\n\n接下来实现Blob模板类的几个成员函数\n1234567891011121314151617181920212223242526272829template &lt;typename T&gt;void Blob&lt;T&gt;::check(size_type i, const std::string &amp;msg) const&#123;    if (i &gt;= data-&gt;size())        throw std::out_of_range(msg);&#125;template &lt;typename T&gt;void Blob&lt;T&gt;::pop_back()&#123;    if (data-&gt;empty())    &#123;        return;    &#125;    data-&gt;pop_back();&#125;template &lt;typename T&gt;T &amp;Blob&lt;T&gt;::back()&#123;    return data-&gt;back();&#125;template &lt;typename T&gt;T &amp;Blob&lt;T&gt;::operator[](size_type i)&#123;    check(i, &quot;index out of range&quot;);    return (*data)[i];&#125;\n\n实现了pop_back, back, check等操作，以及下标索引等函数，接下来实现比较运算符重载\n12345678910111213141516171819202122232425template &lt;typename T&gt;bool operator==(const Blob&lt;T&gt; &amp;b1, const Blob&lt;T&gt; &amp;b2)&#123;    if (b1.size() &gt; b2.size())    &#123;        return true;    &#125;    if (b1.siz() &lt; b2.size())    &#123;        return false;    &#125;    for (unsigned int i = 0; i &lt; b1.size(); i++)    &#123;        if (b1.data[i] == b2.data[i])        &#123;            continue;        &#125;        return b1.data[i] &gt; b2.data[i];    &#125;    return true;&#125;\n\n此时我们还没有实现迭代器版本的构造函数，与类模板的普通成员函数不同，成员函数有自己的模板，所以要写两个模板名\n12345678910//与模板类的普通成员不同，成员模板是函数模板//模板类的T类型template &lt;typename T&gt;//成员函数模板It类型template &lt;typename It&gt;Blob&lt;T&gt;::Blob(It b, It e)&#123;    //通过迭代器构造    data = std::make_shared&lt;std::vector&lt;T&gt;&gt;(b, e);&#125;\n\n这样我们就可以通不同类型的vector初始化Blob的构造函数了\n12345678910111213void use_tempmemfunc()&#123;    int ia[] = &#123;0, 1, 2, 3, 4&#125;;    vector&lt;long&gt; vi = &#123;7, 6, 5, 4&#125;;    list&lt;const char *&gt; w = &#123;&quot;now&quot;, &quot;zack&quot;, &quot;lov u&quot;&#125;;    // Blob&lt;T&gt; T被实例化为int，    //函数模板It被实例化为 int *    Blob&lt;int&gt; a1(begin(ia), end(ia));    // It为vi的迭代器类型vector&lt;long&gt;::iterator T为long类型    Blob&lt;long&gt; a2(vi.begin(), vi.end());    //实例化Blob&lt;string&gt;以及list&lt;const char *&gt;::iterator参数    Blob&lt;string&gt; a3(w.begin(), w.end());&#125;\n\n接下来我们实现BlobPtr这个模板类\n12345678910111213141516171819template &lt;typename T&gt;class BlobPtr&#123;public:    BlobPtr() : curr(0) &#123;&#125;    BlobPtr(Blob&lt;T&gt; &amp;a, size_t sz = 0) : wptr(a.data), curr(sz) &#123;&#125;    //递增和递减    BlobPtr &amp;operator++(); //前置运算符                           // BlobPtr &amp;operator--(); //前置运算符--    BlobPtr &amp;operator++(int);private:    std::shared_ptr&lt;std::vector&lt;T&gt;&gt;    check(std::size_t, const std::string &amp;) const;    std::size_t curr; //数组中的当前位置    //保存一个weak_ptr， 表示底层vector可能被销毁    std::weak_ptr&lt;std::vector&lt;T&gt;&gt; wptr;&#125;;\n\nBlobPtr实现了根据Blob构造自己的成员wptr以及curr，因为wptr是一个弱指针，所以只做弱关联。 接下来我们实现前置++和后置++\n1234567891011121314template &lt;typename T&gt;BlobPtr&lt;T&gt; &amp;BlobPtr&lt;T&gt;::operator++()&#123;    this-&gt;curr++;    return *this;&#125;template &lt;typename T&gt;BlobPtr&lt;T&gt; &amp;BlobPtr&lt;T&gt;::operator++(int)&#123;    BlobPtr &amp;rt = *this;    this-&gt;curr++;    return rt;&#125;\n\n前置++很容易理解，后置++理解较为困难，这里做一下说明，后置++的函数里先用一个BlobPtr引用类型的临时变量rt存储了_this，因为this不会被释放，所以rt就是_this的引用，所引用的内容不会释放，这样外界接受到rt后同样是引用的_this。这样即使rt被回收了也没关系，因为外部已经捕获到_this的引用了。然后对curr++操作，这就是我们看到的先返回*this的引用，后++。 模板类没有实现拷贝赋值时，默认用拷贝构造完成构造初始化\n1234567891011121314151617181920212223242526272829303132void use_classtemp()&#123;    Blob&lt;int&gt; ia;    Blob&lt;int&gt; ia2 = &#123;0, 1, 2, 3, 5&#125;;    Blob&lt;string&gt; ia3 = &#123;&quot;hello &quot;, &quot;zack&quot;, &quot;nice&quot;&#125;;    for (size_t i = 0; i &lt; ia2.size(); i++)    &#123;        ia2[i] = i * i;    &#125;    for (size_t i = 0; i &lt; ia2.size(); i++)    &#123;        cout &lt;&lt; ia2[i] &lt;&lt; endl;    &#125;    for (size_t i = 0; i &lt; ia3.size(); i++)    &#123;        string_upper(ia3[i]);    &#125;    for (size_t i = 0; i &lt; ia3.size(); i++)    &#123;        cout &lt;&lt; ia3[i] &lt;&lt; endl;    &#125;    const auto &amp;data = ia3.back();    cout &lt;&lt; data &lt;&lt; endl;    ia3.pop_back();    const auto &amp;data2 = ia3.back();    cout &lt;&lt; data2 &lt;&lt; endl;&#125;\n\n模板的友元模板类也支持友元类的访问，以下列举了几种情况\n1234567891011121314151617181920212223242526272829303132333435363738template &lt;typename T&gt;class Pal&#123;&#125;;template &lt;typename T&gt;class Pal2&#123;&#125;;class C&#123;    // Pal&lt;C&gt;是C类的友元    friend class Pal&lt;C&gt;;    //所有类型的Pal2的类都是C的友元    template &lt;typename T&gt;    friend class Pal2;&#125;;// c2本身是一个模板类template &lt;typename T&gt;class C2&#123;    //和C2同类型的Pal是C2的所有实例友元    friend class Pal&lt;T&gt;;    // Pal2的所有实例都是C2的所有实例友元    template &lt;typename X&gt;    friend class Pal2;    // Pal3是一个普通类，他是C2的所有实例的友元    friend class Pal3;&#125;;template &lt;typename Type&gt;class Bar&#123;    //将访问权限授予用来实例化Bar的类型    friend Type;&#125;;\n\n类模板的别名类模板的别名定义有以下几种方式\n123456789101112131415//定义模板类别名typedef long long INT64;//我们可以为实例好的模板类定义别名typedef Bar&lt;int&gt; mytype;// C11 可以为模板类定义别名template &lt;typename T&gt;using twin = pair&lt;T, T&gt;;// authors 是一个pair&lt;string, string&gt;twin&lt;string&gt; authors;// infos 是一个pair&lt;int, int&gt;类型twin&lt;int&gt; infos;template &lt;typename T&gt;using partNo = pair&lt;T, unsigned&gt;;// books是pair&lt;string, unsigned&gt;类型partNo&lt;string&gt; books;\n\n类模板的静态成员类模板的静态成员要在非内联文件中初始化，也就是说在类模板声明的.h文件初始化。\n12345678910111213//类模板的static成员template &lt;typename T&gt;class Foo&#123;public:    static std::size_t count() &#123; return ctr; &#125;private:    static std::size_t ctr;&#125;;template &lt;typename T&gt;size_t Foo&lt;T&gt;::ctr = 0;\n\n告知编译器模板的子类型对于string::size_type , size_type是一个类型 默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。 因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。 我们通过使用关键字typename来实现这一点：\n我们用下面的例子显示指名模板名作用域下的是类型不是名字\n123456789// 用typename 告知编译器T::value_type是一个类型template &lt;typename T&gt;typename T::value_type top(const T &amp;c)&#123;    if (!c.empty())        return c.back();    else        return typename T::value_type();&#125;\n\n巧用模板类完成析构有时候我们可以利用模板类型实现()的重载，这样通过仿函数传递给智能指针的第二个参数，可以帮助智能指针回收内存\n12345678910111213141516//函数对象，给指定类型的指针执行析构class DebugDelete&#123;public:    DebugDelete(std::ostream &amp;s = std::cerr) : os(s) &#123;&#125;    //我们定义一个仿函数，参数是T*类型    template &lt;typename T&gt;    void operator()(T *p) const    &#123;        os &lt;&lt; &quot;deleting unique_str&quot; &lt;&lt; std::endl;        delete p;    &#125;private:    std::ostream &amp;os;&#125;;\n\nDebugDelete实现了仿函数，接下来写一个函数调用这个仿函数\n12345678910111213141516void use_debugdel()&#123;    double *p = new double;    DebugDelete d;    //调用DebugDelete的仿函数,delete p    d(p);    //析构多种类型    int *np = new int;    //构造DebugDelete对象后调用仿函数析构np    DebugDelete()(np);    //作为删除器析构智能指针    // p 被delete时会执行DebugDelete的仿函数进行析构    unique_ptr&lt;int, DebugDelete&gt; p3(new int, DebugDelete());    // 用DebugDelete 的仿函数析构string的指针    unique_ptr&lt;string, DebugDelete&gt; sp(new string, DebugDelete());&#125;\n\n模板类型推断有时候对于模板函数返回的类型表示起来很复杂时，可以通过auto 配合尾置类型推断返回数据类型 比如我们我们想返回迭代器指向类型的引用\n12345678//推断返回类型，通过尾置返回允许我们在参数列表之后的声明返回类型template &lt;typename It&gt;auto fcnrf(It beg, It end) -&gt; decltype(*beg)&#123;    //处理序列    //返回迭代器beg指向的元素的引用    return *beg;&#125;\n\n通过decltype(*beg)返回迭代器beg指向的元素的引用类型。 如果想要返回指向元素的副本类型，不是引用类型可以通过remove_reference去引用\n123456789101112// remove_reference 是一个模板// remove_reference&lt;decltype(*beg)&gt;::type// type的类型就是beg指向元素的类型// remove_reference&lt;int&amp;&gt;::type type就是int// remove_reference&lt;string&amp;&gt;::type type就是stringtemplate &lt;typename It&gt;auto fcncp(It beg, It end) -&gt; remove_reference&lt;decltype(*beg)&gt;&#123;    //返回迭代器beg指向元素的copy    return *beg;&#125;\n\n模板的左值和右值函数模板同样存在左值和右值\n1234567891011//接受左值引用的模板函数template &lt;typename T&gt;void f1(T &amp;t)&#123;&#125;//接受右值引用的模板函数template &lt;typename T&gt;void f2(T &amp;&amp;t)&#123;&#125;\n\nf2(42) T就被推断为int int i &#x3D; 100; f2(i) T就被推断为int&amp; 参数类型就变为int&amp; &amp;&amp; 当模板函数的参数是一个T类型的右值引用 1 传递给该参数的实参是一个右值时，T就是该右值类型 2 传递给该参数的实参是一个左值时，T就是该左值引用类型\n折叠规则 X&amp;&amp; 、X&amp;&amp;&amp; 都会被折叠为X&amp; X&amp;&amp; &amp;&amp; 会被折叠为X&amp;&amp;\n所以我们可以推断move的实现原理，其参数一定是T&amp;&amp;类型，因为其能接受左值和右值两种类型。其返回值一定是实参类型的右值引用类型。\n12345template &lt;typename T&gt;typename remove_reference&lt;T&gt;::type &amp;&amp;my_move(T &amp;&amp;t)&#123;    return static_cast&lt;typename remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);&#125;\n\n为什么要有原样转发stl::forward是用来做原样转发的，将原有类型保持原样传递给其他函数，这种机制尤为重要。因为如果不进行原样转发，传递的参数变为左值，传递给一个接受右值引用的函数会出现编译报错。 比如我们实现一个flip函数，既能接受左值又能接受右值，并且在函数内部修改这个值会同步到外部实参的效果，那他的实现一定是通过模板类型T&amp;&amp;实现的，通过折叠达到适配左值和右值的目的\n1234void flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)&#123;    f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));&#125;\n\nflip 函数内部调用了函数f, 将t1和t2的类型原样转发。\n123456789101112131415161718192021void gtemp(int &amp;&amp;i, int &amp;j)&#123;    cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;&#125;void use_ftemp()&#123;    int j = 100;    int i = 99;    // flip(gtemp, j, 42) 会报错    // 因为42作为右值纯递给flip，t2会被折叠为int类型,    // j作为左值传递给flip, T1会绑定为int&amp;，通过折叠t1变为int&amp;类型    // 如果不进行原样转发，t2传递给gtemp第一个参数时，t2虽然是右值引用类型的变量    // 但是t2作为左值传递给了gtemp第一个参数，编译器会报错，int&amp;&amp;无法绑定int类型    // 所以无论右值引用类型还是左值引用类型的变量当成参数传递给其他函数时，这个变量就是一个左值。    // 通过原样转发就保证了这个值在传递给其他函数时不改变其左值引用类型或者右值引用类型    // 这样即使编译报错也是实参层面传递出了错误。    flip(gtemp, i, 42);    cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;&#125;\n\n总结本文模拟实现了vector的功能。 视频链接https://www.bilibili.com/video/BV15t4y1W7ZL/?vd_source&#x3D;8be9e83424c2ed2c9b2a3ed1d01385e9 源码链接 https://gitee.com/secondtonone1/cpplearn\n","slug":"模版特例化","date":"2022-04-21T15:49:00.000Z","categories_index":"C++模版","tags_index":"模版,特例化","author_index":"kiyose408"},{"id":"5ac0cfc2a03b63f31f1f39881eb54b11","title":"模拟实现vector","content":"模拟vector我们可以通过模板实现类似vector的类。我们实现一个StrVecTemp类，其内部通过allocator开辟空间，存储的类型用T来表示，T是模板类型。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970template &lt;typename T&gt;class StrVecTemp&#123;public:    StrVecTemp() : elements(nullptr), first_free(nullptr),                   cap(nullptr) &#123;&#125;    //拷贝构造函数    StrVecTemp(const StrVecTemp &amp;);    //拷贝赋值运算符    StrVecTemp &amp;operator=(const StrVecTemp &amp;);    //移动构造函数    StrVecTemp(StrVecTemp &amp;&amp;src) noexcept : elements(src.elements),                                            first_free(src.first_free), cap(src.cap)    &#123;        //将源数据置空        src.elements = src.first_free = src.cap = nullptr;    &#125;    template &lt;class... Args&gt;    void emplace_back(Args &amp;&amp;...args);    //析构函数    ~StrVecTemp();    //拷贝元素    void push_back(const T &amp;);    //抛出元素    void pop_back(T &amp;s);    //返回元素个数    size_t size() const &#123; return first_free - elements; &#125;    //返回capacity返回容量    size_t capacity() const &#123; return cap - elements; &#125;    //返回首元素的指针    T *begin() const    &#123;        return elements;    &#125;    //返回第一个空闲元素指针    T *end() const    &#123;        return first_free;    &#125;private:    //判断容量不足靠皮新空间    void chk_n_alloc()    &#123;        if (size() == capacity())        &#123;            reallocate();        &#125;    &#125;    //重新开辟空间    void reallocate();    // copy指定范围的元素到新的内存中    std::pair&lt;T *, T *&gt; alloc_n_copy(const T *, const T *);    //释放空间    void free();    //数组首元素的指针    T *elements;    //指向数组第一个空闲元素的指针    T *first_free;    //指向数组尾后位置的指针    T *cap;    //初始化alloc用来分配空间    static std::allocator&lt;T&gt; alloc;&#125;;template &lt;typename T&gt;std::allocator&lt;T&gt; StrVecTemp&lt;T&gt;::alloc;\n\nalloc在使用前要在类外初始化，因为是模板类，所以放在.h中初始化即可。 接下来我们要实现根据迭代器开始和结束的区间copy旧元素到新的空间里\n123456789//实现区间copytemplate &lt;typename T&gt;std::pair&lt;T *, T *&gt; StrVecTemp&lt;T&gt;::alloc_n_copy(const T *b, const T *e)&#123;    auto newdata = alloc.allocate(e - b);    //用旧的数据初始化新的空间    auto first_free = uninitialized_copy(b, e, newdata);    return &#123;newdata, first_free&#125;;&#125;\n\n实现copy构造\n12345678910//实现拷贝构造函数template &lt;class T&gt;StrVecTemp&lt;T&gt;::StrVecTemp(const StrVecTemp &amp;strVec)&#123;    auto rsp = alloc_n_copy(strVec.begin(), strVec.end());    //利用pair类型更新elements, cap, first_free    elements = rsp.first;    first_free = rsp.second;    cap = rsp.second;&#125;\n\n实现copy赋值\n1234567891011121314//拷贝赋值运算符template &lt;class T&gt;StrVecTemp&lt;T&gt; &amp;StrVecTemp&lt;T&gt;::operator=(const StrVecTemp &amp;strVec)&#123;    if (this == &amp;strVec)    &#123;        return *this;    &#125;    //如果不是自赋值，就将形参copy给自己    auto rsp = alloc_n_copy(strVec.begin(), strVec.end());    elements = rsp.first;    first_free = rsp.second;    cap = rsp.second;&#125;\n\n析构函数要先销毁数据再回收内存\n1234567891011121314151617181920212223//析构函数template &lt;class T&gt;StrVecTemp&lt;T&gt;::~StrVecTemp()&#123;    //判断elements是否为空    if (elements == nullptr)    &#123;        return;    &#125;    //缓存第一个有效元素的地址    auto dest = elements;    //循环析构    for (size_t i = 0; i &lt; size(); i++)    &#123;        //析构每一个元素        alloc.destroy(dest++);    &#125;    //再回收内存    alloc.deallocate(elements, cap - elements);    elements = nullptr;    cap = nullptr;    first_free = nullptr;&#125;\n\n重新开辟空间\n123456789101112131415161718192021222324252627282930313233template &lt;class T&gt;void StrVecTemp&lt;T&gt;::reallocate()&#123;    T *newdata = nullptr;    //数组为空的情况    if (elements == nullptr || cap == nullptr || first_free == nullptr)    &#123;        newdata = alloc.allocate(1);        elements = newdata;        first_free = newdata;        // cap指向数组尾元素的下一个位置        cap = newdata + 1;        return;    &#125;    //原数据不为空，则扩充size两倍大小    newdata = alloc.allocate(size() * 2);    //新内存空闲位置    auto dest = newdata;    //就内存的有效位置    auto src = elements;    //通过移动操作将旧数据放到新内存中    for (size_t i = 0; i != size(); ++i)    &#123;        alloc.construct(dest++, std::move(*src++));    &#125;    //移动完旧数据后一定要删除    free();    //更新数据位置    elements = newdata;    first_free = dest;    cap = newdata + size() * 2;&#125;\n\n上面的函数用到了free函数，我们自己实现一个free\n12345678910111213141516171819202122template &lt;typename T&gt;void StrVecTemp&lt;T&gt;::free()&#123;    //先判断elements是否为空    if (elements == nullptr)    &#123;        return;    &#125;    auto dest = elements;    //遍历析构每一个对象    for (size_t i = 0; i &lt; size(); i++)    &#123;        // destroy 会析构每一个元素        alloc.destroy(dest++);    &#125;    //再整体回收内存    alloc.deallocate(elements, cap - elements);    elements = nullptr;    cap = nullptr;    first_free = nullptr;&#125;\n\n压入元素和弹出元素\n123456789101112131415161718192021222324252627282930//拷贝元素template &lt;class T&gt;void StrVecTemp&lt;T&gt;::push_back(const T &amp;t)&#123;    chk_n_alloc();    alloc.construct(first_free++, t);&#125;//抛出元素template &lt;class T&gt;void StrVecTemp&lt;T&gt;::pop_back(T &amp;s)&#123;    //先判断是否为空    if (first_free == nullptr)    &#123;        return;    &#125;    //判断size为1    if (size() == 1)    &#123;        s = *elements;        alloc.destroy(elements);        first_free = nullptr;        elements = nullptr;        return;    &#125;    s = *(--first_free);    alloc.destroy(first_free);&#125;\n\n接下来要实现emplace_back，因为emplace_back支持多种构造函数的参数，所以要用模板参数列表的方式定义该函数。 模板参数列表和形参列表都要用参数包的方式\n1234567template &lt;class T&gt;template &lt;class... Args&gt;void StrVecTemp&lt;T&gt;::emplace_back(Args &amp;&amp;...args)&#123;    chk_n_alloc();    alloc.construct(first_free++, forward&lt;Args&gt;(args)...);&#125;\n\nArgs是模板参数包，args是参数列表。因为construct的参数可能为右值引用，所以要用forward将原参数列表类型原样转发。\n123456// forward既扩展了模板参数包Args，又扩展了函数参数包args// std::forward&lt;Args&gt;(args)... 等价于std::forward&lt;Ti&gt;(ti)//比如传递给emplace_back(10,&#x27;c&#x27;);//相当于调用 alloc.construct(first_free++, forward&lt;int&gt;(10), forward&lt;char&gt;(&#x27;c&#x27;))//调用的就是插入cccccccccc\n\n总结本文模拟实现了vector的功能。 视频链接https://www.bilibili.com/video/BV1Et4y1p73a/?vd_source&#x3D;8be9e83424c2ed2c9b2a3ed1d01385e9 源码链接 https://gitee.com/secondtonone1/cpplearn\n","slug":"模拟实现vector","date":"2022-04-16T14:49:00.000Z","categories_index":"C++模版","tags_index":"模版,模拟","author_index":"kiyose408"},{"id":"7840d4003f29222bf6cd12a2077991b7","title":"foward原样转发","content":"原样转发的意义前文我们实现了一个my_move函数，用来模拟stl的move操作，实现去引用的功能。其内部的原理就是通过remove_reference实现去引用操作。 有时我们也需要保留原类型的左值或者右值属性，进行原样转发，此时就要用forward实现转发功能。 我们先定义一个模板函数\n12345template &lt;typename F, typename T1, typename T2&gt;void flip1(F f, T1 t1, T2 t2)&#123;    f(t2, t1);&#125;\n\nflip1内部调用了函数f 我们写一个函数测试\n123456789101112void ftemp(int v1, int &amp;v2)&#123;    cout &lt;&lt; v1 &lt;&lt; &quot; &quot; &lt;&lt; ++v2 &lt;&lt; endl;&#125;void use_ftemp()&#123;    int j = 100;    int i = 99;    flip1(ftemp, j, 42);    cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;&#125;\n\n通过打印发现i和j的值没有变化，因为ftemp的v2参数虽然是引用，但是是flip1的形参t1的引用 t1只是形参，修改t1并不能影响外边的实参j。 想要达到修改实参的目的，需要将flip1的参数修改为引用，我们先实现修改后的版本flip2\n12345template &lt;typename F, typename T1, typename T2&gt;void flip2(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)&#123;    f(t2, t1);&#125;\n\n我们定义了一个flip2函数，t1和t2分别是右值引用类型。接下来用一个测试函数进行测试\n1234int j = 100;int i = 99;flip2(ftemp, j, 42);cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;\n\n这次我们发现j被修改了，因为flip2的t1参数类型为T1的右值引用，当把实参j赋值给flip2时，T1变为int&amp;, t1的类型就是int&amp; &amp;&amp;，通过折叠t1变为int&amp;类型。这样t1就和实参j绑定了，在flip2内部修改t1，就达到了修改j的目的。 但是flip2同样存在一个问题，如果flip2的第一个参数f，如果f是一个接受右值引用参数的函数，会出现编译错误。 为说明这一点，我们实现一个接纳模板参数右值引用类型的函数\n1234void gtemp(int &amp;&amp;i, int &amp;j)&#123;    cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;&#125;\n\n此时如果我们将gtemp作为参数传递给flip2会报错\n123456789101112131415161718int j = 100;int i = 99;// flip2(gtemp, j, 42) 会报错// 因为42作为右值纯递给flip2，t2会被折叠为int&amp;类型// t2传递给gtemp第一个参数时，int&amp;&amp;无法绑定int&amp;类型//flip2(gtemp, i, 42);cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;```t当我们将42传递给flip2第二个参数时，T2被实例化为int类型，t2就变为int &amp;&amp; 类型，通过折叠t2变为int&amp;类型。t2作为参数传递给gtemp的第一个参数时会报错，cannot bind rvalue reference of type &#x27;int&amp;&amp;&#x27; to lvalue of type &#x27;int&#x27;因为t2是一个左值，右值无法绑定该左值。上面的错误可以简化为``` cppint i = 100;int&amp;&amp; m = 200;int&amp;&amp; k =  m;\n\n上面代码仍然会报错，无法将k这个右值引用绑定到m这个左值上。 解决的办法很简单\n123int i = 100;int&amp;&amp; m = 200;int&amp;&amp; k = int(m);\n\n通过int强制类型转换，这是一个表达式得出的就是右值。当然也可以通过如下方式\n123int i = 100;int&amp;&amp; m = 200;int&amp;&amp; k = std::move(m);\n\n总之就是通过表达式将m转化为右值即可。所以大家要清楚的是及时m是一个int&amp;&amp;类型，但是它本身是一个左值。 综上所述，上面问题的解决的办法就是实现一个flip函数，内部实现对T2，T1类型的原样转发。\n12345template &lt;typename F, typename T1, typename T2&gt;void flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)&#123;    f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));&#125;\n\n通过forward将t2类型转化为和T2类型一样的类型，也就是int的右值类型，接下来的调用就不会出问题了\n1234567void use_ftemp()&#123;    int j = 100;    int i = 99;    flip(gtemp, i, 42);    cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;&#125;\n\n模板的可变参数模板同样支持可变参数\n12345678910111213//可变参数的函数模板template &lt;typename T&gt;ostream &amp;print(ostream &amp;os, const T &amp;t)&#123;    return os &lt;&lt; t; //输出最后一个元素&#125;template &lt;typename T, typename... Args&gt;ostream &amp;print(ostream &amp;os, const T &amp;t, const Args &amp;...rest)&#123;    os &lt;&lt; t &lt;&lt; &quot;, &quot;;    return print(os, rest...);&#125;\n\nArgs是可变的模板参数包， 然后再用Args定义rest变量，这是一个可变参数列表。 我们的模板函数print内部调用stl的print函数，通过对rest…实现展开操作。 调用过程可按如下的方式\n123456void use_printtemp()&#123;    int i = 100;    string s = &quot;hello zack!!!&quot;;    print(cout, i, s, 42);&#125;\n\n第一次调用print实际是调用的可变参数的print，之后才调用没有可变参数的print函数。\n总结本文介绍了模板类型的原样转发，以及多模板参数列表的使用。 视频链接https://www.bilibili.com/video/BV1ES4y187Yc/?vd_source&#x3D;8be9e83424c2ed2c9b2a3ed1d01385e9 源码链接 https://gitee.com/secondtonone1/cpplearn\n","slug":"forward原样转发","date":"2022-04-08T11:49:00.000Z","categories_index":"C++模版","tags_index":"原样转发,模版","author_index":"kiyose408"},{"id":"a5369c7c25920ed05726c5cd9a2b6ec2","title":"模版类的友元和折叠规则","content":"为模板类声明友元类有时我们需要A类访问模板类B的私有成员，但是不想其他类访问，就要在模板类B里为A类声明友元。比如我们想要实现一个BlobPtr类，让BlobPtr类成为Blob类的友元，这样BlobPtr类就可以访问Blob类了。对于Blob类的声明和定义在前文已经阐述https://llfc.club/articlepage?id=28Vv7hro3VVMPDepLTlLRLqYJhJ。 我们省略Blob类的详细声明,只为它添加友元类BlobPtr类，并且为他添加友元函数operator&#x3D;&#x3D;\n12345678910class Blob&#123;public:    typedef T value_type;    typedef typename std::vector&lt;T&gt;::size_type size_type;    // T类型的BlobPtr是T类型的Blob的友元类    friend class BlobPtr&lt;T&gt;;    //重载==运算符    friend bool operator==(const Blob&lt;T&gt; &amp;, const Blob&lt;T&gt; &amp;);&#125;;\n\n实现友元类BlobPtr接下来我们实现友元类BlobPtr,先对其进行声明\n12345678910111213141516171819template &lt;typename T&gt;class BlobPtr&#123;public:    BlobPtr() : curr(0) &#123;&#125;    BlobPtr(Blob&lt;T&gt; &amp;a, size_t sz = 0) : wptr(a.data), curr(sz) &#123;&#125;    //递增和递减    BlobPtr &amp;operator++(); //前置运算符                           // BlobPtr &amp;operator--(); //前置运算符--    BlobPtr &amp;operator++(int);private:    std::shared_ptr&lt;std::vector&lt;T&gt;&gt;    check(std::size_t, const std::string &amp;) const;    std::size_t curr; //数组中的当前位置    //保存一个weak_ptr， 表示底层vector可能被销毁    std::weak_ptr&lt;std::vector&lt;T&gt;&gt; wptr;&#125;;\n\n在实现其定义,这里只举例实现一部分函数，其余的读者自己实现即可。\n1234567891011121314template &lt;typename T&gt;BlobPtr&lt;T&gt; &amp;BlobPtr&lt;T&gt;::operator++()&#123;    this-&gt;curr++;    return *this;&#125;template &lt;typename T&gt;BlobPtr&lt;T&gt; &amp;BlobPtr&lt;T&gt;::operator++(int)&#123;    BlobPtr &amp;rt = *this;    this-&gt;curr++;    return rt;&#125;\n\n对于友元函数operator &#x3D;&#x3D; 的定义可以按照如下实现\n12345678910111213141516171819202122232425template &lt;typename T&gt;bool operator==(const Blob&lt;T&gt; &amp;b1, const Blob&lt;T&gt; &amp;b2)&#123;    if (b1.size() &gt; b2.size())    &#123;        return true;    &#125;    if (b1.siz() &lt; b2.size())    &#123;        return false;    &#125;    for (unsigned int i = 0; i &lt; b1.size(); i++)    &#123;        if (b1.data[i] == b2.data[i])        &#123;            continue;        &#125;        return b1.data[i] &gt; b2.data[i];    &#125;    return true;&#125;\n\n模板类的友元还有一些特殊的用法，如下，读者可以自己体会\n12345678910111213141516171819202122232425262728293031template &lt;typename T&gt;class Pal&#123;&#125;;template &lt;typename T&gt;class Pal2&#123;&#125;;class C&#123;    // Pal&lt;C&gt;是C类的友元    friend class Pal&lt;C&gt;;    //所有类型的Pal2的类都是C的友元    template &lt;typename T&gt;    friend class Pal2;&#125;;// c2本身是一个模板类template &lt;typename T&gt;class C2&#123;    //和C2同类型的Pal是C2的所有实例友元    friend class Pal&lt;T&gt;;    // Pal2的所有实例都是C2的所有实例友元    template &lt;typename X&gt;    friend class Pal2;    // Pal3是一个普通类，他是C2的所有实例的友元    friend class Pal3;&#125;;\n\n定义模板类别名我们可以通过typedef和using等方式为一个模板类定义别名\n12345678910111213141516171819202122template &lt;typename Type&gt;class Bar&#123;    //将访问权限授予用来实例化Bar的类型    friend Type;&#125;;//定义模板类别名typedef long long INT64;//我们可以为实例好的模板类定义别名typedef Bar&lt;int&gt; mytype;// C11 可以为模板类定义别名template &lt;typename T&gt;using twin = pair&lt;T, T&gt;;// authors 是一个pair&lt;string, string&gt;twin&lt;string&gt; authors;// infos 是一个pair&lt;int, int&gt;类型twin&lt;int&gt; infos;template &lt;typename T&gt;using partNo = pair&lt;T, unsigned&gt;;// books是pair&lt;string, unsigned&gt;类型partNo&lt;string&gt; books;\n\n类模板的静态成员对于类模板的静态成员，其初始化要放在声明的.h文件中。\n1234567891011121314//类模板的static成员template &lt;typename T&gt;class Foo&#123;public:    static std::size_t count() &#123; return ctr; &#125;private:    static std::size_t ctr;&#125;;//初始化放在和声明所在的同一个.h文件中template &lt;typename T&gt;size_t Foo&lt;T&gt;::ctr = 0;\n\n模板类的作用域访问默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。 因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。 我们通过使用关键字typename来实现这一点：\n123456789// 用typename 告知编译器T::value_type是一个类型template &lt;typename T&gt;typename T::value_type top(const T &amp;c)&#123;    if (!c.empty())        return c.back();    else        return typename T::value_type();&#125;\n\n我们定义了一个名为top的模板函数，通过T::value_type声明其返回类型，但是C++默认作用域下value_type是一个成员， 所以为了说明value_type是一个类型就需要用typename关键字做声明。\n通用的函数对象我们可以通过模板类实现通用的仿函数，也就是实现通用的函数对象，我们先实现一个DebugDelete类，用来删除各种类型的指针对象\n12345678910111213141516//函数对象，给指定类型的指针执行析构class DebugDelete&#123;public:    DebugDelete(std::ostream &amp;s = std::cerr) : os(s) &#123;&#125;    //我们定义一个仿函数，参数是T*类型    template &lt;typename T&gt;    void operator()(T *p) const    &#123;        os &lt;&lt; &quot;deleting unique_str&quot; &lt;&lt; std::endl;        delete p;    &#125;private:    std::ostream &amp;os;&#125;;\n\nDebugDelete构造函数接纳一个输出流，用来在operator()调用时输出删除信息 接下来我们实现一个测试函数，用来说明DebugDelete的用法\n12345678910111213141516void use_debugdel()&#123;    double *p = new double;    DebugDelete d;    //调用DebugDelete的仿函数,delete p    d(p);    //析构多种类型    int *np = new int;    //构造DebugDelete对象后调用仿函数析构np    DebugDelete()(np);    //作为删除器析构智能指针    // p 被delete时会执行DebugDelete的仿函数进行析构    unique_ptr&lt;int, DebugDelete&gt; p3(new int, DebugDelete());    // 用DebugDelete 的仿函数析构string的指针    unique_ptr&lt;string, DebugDelete&gt; sp(new string, DebugDelete());&#125;\n\n可以看出DebugDelete可以用来给智能指针作删除器用。\n尾置类型的推断C11新标准中提出了尾置类型推断\n12// func接受了一个int类型的实参，返回了一个指针，该指针指向一个含有10个整数的数组auto func(int i) -&gt; int (*)[10];\n\n利用这个特性，我们可以用在模板函数中，同样实现一个尾置类型推断函数\n12345678//推断返回类型，通过尾置返回允许我们在参数列表之后的声明返回类型template &lt;typename It&gt;auto fcnrf(It beg, It end) -&gt; decltype(*beg)&#123;    //处理序列    //返回迭代器beg指向的元素的引用    return *beg;&#125;\n\nfcnrf的返回类型时It指向元素的解引用(*beg)类型，通过decltype类型推断给出返回的类型。 我们也可以实现一个返回值类型的函数，去掉引用类型。\n123456789101112// remove_reference 是一个模板// remove_reference&lt;decltype(*beg)&gt;::type// type的类型就是beg指向元素的类型// remove_reference&lt;int&amp;&gt;::type type就是int// remove_reference&lt;string&amp;&gt;::type type就是stringtemplate &lt;typename It&gt;auto fcncp(It beg, It end) -&gt; remove_reference&lt;decltype(*beg)&gt;&#123;    //返回迭代器beg指向元素的copy    return *beg;&#125;\n\n引用折叠规则我们可以用模板定义一个左值引用\n12345//接受左值引用的模板函数template &lt;typename T&gt;void f1(T &amp;t)&#123;&#125;\n\n当我们用模板类型定义一个右值引用时，传递给该类型的实参类型，会根据C++标准进行折叠。 我们先声明一个右值引用的模板函数\n12345//接受右值引用的模板函数template &lt;typename T&gt;void f2(T &amp;&amp;t)&#123;&#125;\n\n如果我们调用f2(42), T就被推断为int int i &#x3D; 100; f2(i) T就被推断为int&amp; 进行参数展开参数就变为int&amp; &amp;&amp; 折叠后就变为int &amp; 所以我们可以做如下归纳： 当模板函数的实参是一个T类型的右值引用 1 传递给该参数的实参是一个右值时， T就是该右值类型 2 传递给该参数的实参是一个左值时， T就是该左值引用类型。\n&#x2F;&#x2F;折叠规则 &#x2F;&#x2F;X&amp;&amp; ,X&amp;&amp;&amp; 都会被折叠为X&amp; &#x2F;&#x2F;X&amp;&amp; &amp;&amp; 会被折叠为X&amp;&amp; 所以根据这个规律，我们可以实现一个类似于stl的move操作\n1234template&lt;typename T&gt;typename remove_reference&lt;T&gt;::type &amp;&amp; my_move(T&amp;&amp; t)&#123;    return static_cast&lt;typename remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);&#125;\n\n如果我们在函数中作如下调用\n1234567891011121314151617181920212223void use_tempmove()&#123;    int i = 100;    my_move(i);    //推断规则    /*    1  T被推断为int &amp;    2  remove_reference&lt;int &amp;&gt;的type成员是int    3  my_move 的返回类型是int&amp;&amp;    4  推断t类型为int&amp; &amp;&amp; 通过折叠规则t为int&amp;类型    5  最后这个表达式变为 int &amp;&amp; my_move(int &amp;t)    */    auto rb = my_move(43);    //推断规则    /*    1  T被推断为int    2  remove_reference&lt;int&gt;的type成员是int    3  my_move 的返回类型为int&amp;&amp;    4  my_move 的参数t类型为int &amp;&amp;    5  最后这个表达式变为 int &amp;&amp; my_move(int &amp;&amp; t)    */&#125;\n\n总结这篇文章介绍了模板参数类型的折叠规则和友元类的声明和使用。 视频链接https://www.bilibili.com/video/BV1cF41177hK?vd_source&#x3D;8be9e83424c2ed2c9b2a3ed1d01385e9 源码链接 https://gitee.com/secondtonone1/cpplearn\n","slug":"模板类的友元和折叠规则","date":"2022-03-28T16:49:00.000Z","categories_index":"C++模版","tags_index":"模版,友元类","author_index":"kiyose408"},{"id":"85522d683e84dc82b51c41943dc59db8","title":"lambda表达式","content":"lambda表达式lambda表达式又称为匿名表达式，是C11提出的新语法。[]存储lambda表达式要捕获的值，()内的参数为形参，可供外部调用传值。lambda表达式可以直接调用\n123456// 1  匿名调用   [](string name)   &#123;       cout &lt;&lt; &quot;this is anonymous&quot; &lt;&lt; endl;       cout &lt;&lt; &quot;hello &quot; &lt;&lt; name &lt;&lt; endl;   &#125;(&quot;zack&quot;);\n\n上述代码定义了一个匿名函数后直接调用。我们可以通过auto初始化一个变量存储lambda表达式\n12345678// 2 通过auto赋值   auto fname = [](string name)   &#123;       cout &lt;&lt; &quot;this is auto  &quot; &lt;&lt; endl;       cout &lt;&lt; &quot;hello &quot; &lt;&lt; name &lt;&lt; endl;   &#125;;   fname(&quot;Rolin&quot;);\n\n通过auto定义fname，然后存储了lambda表达式，之后调用fname即可。也可以通过函数指针的方式接受lambda表达式\n123456789typedef void (*P_NameFunc)(string name);// 3 函数指针P_NameFunc fname2 = [](string name)&#123;    cout &lt;&lt; &quot;this is P_NameFunc &quot; &lt;&lt; endl;    cout &lt;&lt; &quot;hello &quot; &lt;&lt; name &lt;&lt; endl;&#125;;fname2(&quot;Vivo&quot;);\n\nP_NameFunc定义了fname2函数指针接受了lambda表达式。也可以通过function对象接受lambda表达式，function类是C11新增的语法。\n123456789// 4 function    function&lt;void(string)&gt; funcName;    funcName = [](string name)    &#123;        cout &lt;&lt; &quot;this is function &quot; &lt;&lt; endl;        cout &lt;&lt; &quot;hello &quot; &lt;&lt; name &lt;&lt; endl;    &#125;;    funcName(&quot;Uncle Wang&quot;);\n\n用一个function对象接受了lambda表达式，同样可以调用该function对象funcName达到调用lambda的效果。\n谈谈lambda的捕获1 值捕获\n123456789int age = 33;string name = &quot;zack&quot;;int score = 100;string job = &quot;softengineer&quot;;//值捕获[age, name](string name_)&#123;    cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; &quot; name is &quot; &lt;&lt; name &lt;&lt; &quot; self-name is &quot; &lt;&lt; name_ &lt;&lt; endl;&#125;(&quot;Novia&quot;);\n\n上述lambda表达式捕获了age和name，是以值的方式来捕获的。所以无法在lambda表达式内部修改age和name的值，如果修改age和name，编译器会报错，提示无法修改const常量，因为age和name是以值的方式被捕获的。 2 引用捕获\n12345678910int age = 33;string name = &quot;zack&quot;;int score = 100;string job = &quot;softengineer&quot;;[&amp;age, &amp;name](string name_)&#123;    cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; &quot; name is &quot; &lt;&lt; name &lt;&lt; &quot; self-name is &quot; &lt;&lt; name_ &lt;&lt; endl;    name = &quot;Xiao Li&quot;;    age = 18;&#125;(&quot;Novia&quot;);\n\n[]里age和name前边添加了&amp;，此时age和name是以引用方式捕获的。所以可以在lambda表达式中修改age和name的值。 C++的lambda表达式虽然可以捕获局部变量的引用，达到类似闭包的效果，但不是真的闭包，golang和python等语言通过闭包捕获局部变量后可以增加局部变量的声明周期，C++无法做到这一点，所以下面的调用会出现崩溃。\n1234567891011121314151617181920212223242526272829vector&lt;function&lt;void(string)&gt;&gt; vec_Funcs;void use_lambda2()&#123;    int age = 33;    string name = &quot;zack&quot;;    int score = 100;    string job = &quot;softengineer&quot;;    vec_Funcs.push_back([age, name](string name_)                        &#123;   cout &lt;&lt; &quot;this is value catch &quot; &lt;&lt; endl;                            cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; &quot; name is &quot; &lt;&lt; name &lt;&lt; &quot; self-name is &quot; &lt;&lt; name_ &lt;&lt; endl; &#125;);    //危险，不要捕获局部变量的引用    vec_Funcs.push_back([&amp;age, &amp;name](string name_)                        &#123;   cout &lt;&lt; &quot;this is referenc catch&quot; &lt;&lt; endl;                            cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; &quot; name is &quot; &lt;&lt; name &lt;&lt; &quot; self-name is &quot; &lt;&lt; name_ &lt;&lt; endl; &#125;);&#125;void use_lambda3()&#123;    for (auto f : vec_Funcs)    &#123;        f(&quot;zack&quot;);    &#125;&#125;int main()&#123;    use_lambda2();    use_lambda3();&#125;\n\nuse_lambda2中将lambda表达式存储在function类型的vector里，当use_lambda2结束后，里边的局部变量都被释放了，而vector中的lambda表达式还存储着局部变量的引用，在调用use_lambda3时调用lambda表达式，此时访问局部变量已经被释放了，所以导致程序崩溃。 3 全部用值捕获，name用引用捕获\n123456789int age = 33;string name = &quot;zack&quot;;int score = 100;string job = &quot;softengineer&quot;;[=, &amp;name]()&#123;    cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; &quot; name is &quot; &lt;&lt; name &lt;&lt; &quot; score is &quot; &lt;&lt; score &lt;&lt; &quot; job is &quot; &lt;&lt; job &lt;&lt; endl;    name = &quot;Cui Hua&quot;;&#125;();\n\n通过&#x3D;表示所有变量都以值的方式捕获，如果希望某个变量以引用方式捕获则单独在这个变量前加&amp;。 4 全部用引用捕获，只有name用值捕获\n12345678int age = 33;string name = &quot;zack&quot;;int score = 100;string job = &quot;softengineer&quot;;[&amp;, name]()&#123;     cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; &quot; name is &quot; &lt;&lt; name &lt;&lt; &quot; score is &quot; &lt;&lt; score &lt;&lt; &quot; job is &quot; &lt;&lt; job &lt;&lt; endl;&#125;();\n\n通过&amp;方式表示所有变量都已引用方式捕获，如果希望某个变量以值方式捕获则单独在这个变量前加&#x3D;。\n万能的function我们可以用function存储形参和返回值相同的一类函数指针，可调用对象，lambda表达式等。\n12345678910111213141516void use_function()&#123;    list&lt;function&lt;void(string)&gt;&gt; list_Funcs;    //存储函数对象    list_Funcs.push_back(FuncObj());    //存储lambda表达式    list_Funcs.push_back([](string str)                         &#123; cout &lt;&lt; &quot;this is lambda call &quot; &lt;&lt; str &lt;&lt; endl; &#125;);    //存储全局函数    list_Funcs.push_back(globalFun);    for (const auto &amp;f : list_Funcs)    &#123;        f(&quot;hello zack&quot;);    &#125;&#125;\n\nbind操作C11同样提供了bind操作，将原函数的几个参数通过bind绑定传值，返回一个新的可调用对象。\n1234567891011//绑定全局函数auto newfun1 = bind(globalFun2, placeholders::_1, placeholders::_2, 98, &quot;worker&quot;);//相当于调用globalFun2(&quot;Lily&quot;,22, 98,&quot;worker&quot;);newfun1(&quot;Lily&quot;, 22);//多传参数没有用，相当于调用globalFun2(&quot;Lucy&quot;,28, 98,&quot;worker&quot;);newfun1(&quot;Lucy&quot;, 28, 100, &quot;doctor&quot;);auto newfun2 = bind(globalFun2, &quot;zack&quot;, placeholders::_1, 100, placeholders::_2);//相当于调用globalFun2(&quot;zack&quot;,33,100,&quot;engineer&quot;);newfun2(33, &quot;engineer&quot;);auto newfun3 = bind(globalFun2, &quot;zack&quot;, placeholders::_2, 100, placeholders::_1);newfun3(&quot;coder&quot;, 33);\n\nplaceholders表示占位符，_1表示新生成函数的第一个参数, _2表示新生成函数的第二个参数，将这些参数传递给原函数达到占位的效果，原函数的其余参数通过bind绑定固定值。 接下来定义类\n1234567891011class BindTestClass&#123;public:    BindTestClass(int num_, string name_) : num(num_), name(name_) &#123;&#125;    static void StaticFun(const string &amp;str, int age);    void MemberFun(const string &amp;job, int score);public:    int num;    string name;&#125;;\n\n实现静态函数和成员函数\n1234567891011121314void BindTestClass::StaticFun(const string &amp;str, int age)&#123;    cout &lt;&lt; &quot;this is static function&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;name is &quot; &lt;&lt; str &lt;&lt; endl;    cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; endl;&#125;void BindTestClass::MemberFun(const string &amp;job, int score)&#123;    cout &lt;&lt; &quot;this is member function&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;name is &quot; &lt;&lt; name &lt;&lt; endl;    cout &lt;&lt; &quot;age is &quot; &lt;&lt; num &lt;&lt; endl;    cout &lt;&lt; &quot;job is &quot; &lt;&lt; job &lt;&lt; endl;    cout &lt;&lt; &quot;score is &quot; &lt;&lt; score &lt;&lt; endl;&#125;\n\n我们通过bind绑定静态成员函数\n1234//绑定类的静态成员函数,加不加&amp;都可以// auto staticbind = bind(BindTestClass::StaticFun, placeholders::_1, 33);auto staticbind = bind(&amp;BindTestClass::StaticFun, placeholders::_1, 33);staticbind(&quot;zack&quot;);\n\n新生成的staticbind函数可以直接传递一个参数zack就完成了调用。接下来用bind绑定成员函数\n1234567891011BindTestClass bindTestClass(33, &quot;zack&quot;);// 绑定类的成员函数,一定要传递对象给bind的第二个参数，可以是类对象，也可以是类对象的指针// 如果要修改类成员，必须传递类对象的指针auto memberbind = bind(&amp;BindTestClass::MemberFun, &amp;bindTestClass, placeholders::_1, placeholders::_2);memberbind(&quot;coder&quot;, 100);auto memberbind2 = bind(&amp;BindTestClass::MemberFun, placeholders::_3, placeholders::_1, placeholders::_2);memberbind2(&quot;coder&quot;, 100, &amp;bindTestClass);//绑定类成员时，对象必须取地址auto numbind = bind(&amp;BindTestClass::num, placeholders::_1);std::cout &lt;&lt; numbind(bindTestClass) &lt;&lt; endl;\n\n当然也可以直接用function对象接受bind返回的结果\n123456789101112131415161718// function接受bind返回的函数function&lt;void(int, string)&gt; funcbind = bind(globalFun2, &quot;zack&quot;, placeholders::_1, 100, placeholders::_2);funcbind(33, &quot;engineer&quot;);// function接受bind 成员函数function&lt;void(string, int)&gt; funcbind2 = bind(&amp;BindTestClass::MemberFun, &amp;bindTestClass, placeholders::_1, placeholders::_2);funcbind2(&quot;docker&quot;, 100);function&lt;void(string, int, BindTestClass *)&gt; funcbind3 = bind(&amp;BindTestClass::MemberFun, placeholders::_3, placeholders::_1, placeholders::_2);funcbind3(&quot;driver&quot;, 100, &amp;bindTestClass);// function 直接接受成员函数,function的模板列表里第一个参数是类对象引用function&lt;void(BindTestClass &amp;, const string &amp;, int)&gt; functomem = BindTestClass::MemberFun;functomem(bindTestClass, &quot;functomem&quot;, 88);// function 绑定类的静态成员函数function&lt;void(const string &amp;)&gt; funbindstatic = bind(&amp;BindTestClass::StaticFun, placeholders::_1, 33);funbindstatic(&quot;Rolis&quot;);\n\nlambda和bind的使用就介绍到这里 源码链接：https://gitee.com/secondtonone1/cpplearn 视频链接: https://www.bilibili.com/video/BV15S4y1Y7no\n","slug":"lambda表达式","date":"2022-03-21T22:49:00.000Z","categories_index":"C++高级","tags_index":"lambda表达式,bind操作","author_index":"kiyose408"},{"id":"6d811383cc30559af72f7dba87a5b6e3","title":"动态内存管理示例","content":"动态内存管理之前我们讲述过动态内存的开辟，可以通过new, malloc，以及alloc等方式，本文通过介绍alloc方式，构造一个StrVec类，这个类的功能类似于一个vector，实现字符串的管理，其中包含push一个字符串，动态扩容，析构，回收内存等操作。\nStrVec类实现细节StrVec类实现如下\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class StrVec&#123;public:    //无参构造函数    StrVec() : elements(nullptr), first_free(nullptr),               cap(nullptr) &#123;&#125;    //拷贝构造函数    StrVec(const StrVec &amp;);    //拷贝赋值运算符    StrVec &amp;operator=(const StrVec &amp;);    //析构函数    ~StrVec();    //拷贝元素    void push_back(const std::string &amp;);    //返回元素个数    size_t size() const &#123; return first_free - elements; &#125;    //返回总容量    size_t capacity() const &#123; return cap - elements; &#125;    //返回首元素地址    std::string *begin() const    &#123;        return elements;    &#125;    //返回第一个空闲元素地址    //也是最后一个有效元素的下一个位置    std::string *end() const    &#123;        return first_free;    &#125;private:    //判断容量不足开辟新空间    void chk_n_alloc()    &#123;        if (size() == capacity())            reallocate();    &#125;    //重新开辟空间    void reallocate();    // copy指定范围的元素到新的内存中    std::pair&lt;std::string *, std::string *&gt; alloc_n_copy(        const std::string *, const std::string *);    //释放空间    void free();    //数组首元素的指针    std::string *elements;    //指向数组第一个空闲元素的指针    std::string *first_free;    //指向数组尾后位置的指针    std::string *cap;    //构造string类型allocator静态成员    static std::allocator&lt;std::string&gt; alloc;&#125;;\n\n1 elements成员，该成员指向StrVec内部数组空间的第一个元素 2 first_free成员指向第一个空闲元素，也就是有效元素的下一个元素，该元素开辟空间但未构造。 3 cap 指向最后一个元素的下一个位置。 4 alloc为静态成员，主要负责string类型数组的开辟工作。 5 无参构造函数将三个指针初始化为空，并且默认够早了alloc。 6 alloc_n_copy私有函数的功能是将一段区域的数据copy到新的空间， 并且返回新开辟的空间地址以及第一个空闲元素的地址(第一个未构造元素的地址)。 7 chk_n_alloc私有函数检测数组大小是否达到容量，如果达到则调用reallocate重新开辟空间。 8 reallocate重新开辟空间 9 capacity返回总容量 10 size返回元素个数 11 push_back 将元素放入开辟的类似于数组的连续空间中。 12 begin返回首元素地址 13 end返回第一个空闲元素地址,也是最后一个有效元素的下一个位置 无论我们实现push操作还是拷贝构造操作，都要实现realloc，当空间不足时要开辟空间将旧数据移动到新的数据\n1234567891011121314151617181920212223242526272829303132333435//重新开辟空间void StrVec::reallocate()&#123;    string *newdata = nullptr;    //数组为空的情况    if (elements == nullptr || cap == nullptr || first_free == nullptr)    &#123;        newdata = alloc.allocate(1);        // elements和first_free都指向首元素        elements = newdata;        first_free = newdata;        // cap指向数组尾元素的下一个位置。        cap = newdata + 1;        return;    &#125;    //不为空则扩充两倍空间    newdata = alloc.allocate(size() * 2);    //新内存空闲位置    auto dest = newdata;    //旧内存有效位置    auto src = elements;    //通过移动操作将旧数据放到新内存中    for (size_t i = 0; i != size(); ++i)    &#123;        alloc.construct(dest++, std::move(*src++));    &#125;    //移动后旧内存数据无效，一定要删除    free();    //更新数据位置    elements = newdata;    //更新第一个空闲位置    first_free = dest;    //更新容量    cap = elements + size() * 2;&#125;\n\nreallocate函数内部判断是否为刚初始化指针却没开辟空间的空数组，如果是则开辟1个大小的空间。 否则则开辟原有空间的两倍，将旧数据移动到新空间，采用了std::move操作，这么做减少拷贝造成的性能开销。 move之后原数据就无效了，所以要调用私有函数free()进行释放。我们实现该free操作\n12345678910111213141516171819//释放操作void StrVec::free()&#123;    //判断elements是否为空    if (elements == nullptr)    &#123;        return;    &#125;    auto dest = elements;    //要先遍历析构每一个对象    for (size_t i = 0; i &lt; size(); i++)    &#123;        // destroy会调用每一个元素的析构函数        alloc.destroy(dest++);    &#125;    //再整体回收内存    alloc.deallocate(elements, cap - elements);&#125;\n\n先通过遍历destroy销毁内存，从而调用string的析构函数，最后在deallocate回收内存。\n123456789// copy指定范围的元素到新的内存中,返回新元素的地址和第一个空闲元素地址的pairstd::pair&lt;std::string *, std::string *&gt; StrVec::alloc_n_copy(    const std::string *b, const std::string *e)&#123;    auto newdata = alloc.allocate(e - b);    //将原数据用来初始化新空间    auto first_free = uninitialized_copy(b, e, newdata);    return &#123;newdata, first_free&#125;;&#125;\n\n这样利用alloc_n_copy，我们就可以实现拷贝构造和拷贝赋值了\n12345678910//拷贝构造函数StrVec::StrVec(const StrVec &amp;strtmp)&#123;    //将形参数据拷贝给自己    auto rsp = alloc_n_copy(strtmp.begin(), strtmp.end());    //更新elements, cap，first_free    elements = rsp.first;    first_free = rsp.second;    cap = rsp.second;&#125;\n\n但是拷贝赋值要注意一点，就是自赋值的情况，所以我们提前判断是否为自赋值，如不是则进行和拷贝构造相同的操作\n123456789101112131415//拷贝赋值运算符StrVec &amp;StrVec::operator=(const StrVec &amp;strtmp)&#123;    //防止自赋值    if (this == &amp;strtmp)    &#123;        return *this;    &#125;    //将形参数据拷贝给自己    auto rsp = alloc_n_copy(strtmp.begin(), strtmp.end());    //更新elements, cap，first_free    elements = rsp.first;    first_free = rsp.second;    cap = rsp.second;&#125;\n\n我们可以利用free实现析构函数\n12345//析构StrVec::~StrVec()&#123;    free();&#125;\n\n接下来我们实现push_back，将指定字符串添加到数组空间,以及抛出元素\n12345678910111213141516171819202122232425262728//添加元素void StrVec::push_back(const std::string &amp;s)&#123;    chk_n_alloc();    alloc.construct(first_free++, s);&#125;//抛出元素void StrVec::pop_back(std::string &amp;s)&#123;    if (first_free == nullptr)    &#123;        return;    &#125;    if (size() == 1)    &#123;        s = *elements;        alloc.destroy(elements);        first_free = nullptr;        elements = nullptr;        return;    &#125;    s = *(--first_free);    alloc.destroy(first_free);&#125;\n\n接下来实现测试函数，测试上述操作\n12345678910void test_strvec()&#123;    auto str1 = StrVec();    str1.push_back(&quot;hello zack&quot;);    StrVec str2(str1);    str2.push_back(&quot;hello rolin&quot;);    StrVec str3 = str1;    string strtmp;    str3.pop_back(strtmp);&#125;\n\n在主函数调用上面test_strvec，运行稳定。\n总结本文通过allocator实现了一个类似于vector的类，管理string变量。演示了拷贝构造，拷贝赋值要注意的事项，同时演示了如何手动开辟内存并管理内存空间。 源码链接 https://gitee.com/secondtonone1/cpplearn 想系统学习更多C++知识,可点击下方链接。 C++基础\n","slug":"动态内存管理示例","date":"2022-03-14T19:49:00.000Z","categories_index":"C++高级","tags_index":"内存管理,拷贝构造","author_index":"kiyose408"},{"id":"d9200ea647e7412ece3be1905aeabe7d","title":"再谈单例模式","content":"本文介绍C++单例模式的集中实现方式，以及利弊\n局部静态变量方式123456789101112131415161718//通过静态成员变量实现单例//懒汉式class Single2&#123;private:    Single2()    &#123;    &#125;    Single2(const Single2 &amp;) = delete;    Single2 &amp;operator=(const Single2 &amp;) = delete;public:    static Single2 &amp;GetInst()    &#123;        static Single2 single;        return single;    &#125;&#125;;\n\n上述代码通过局部静态成员single实现单例类，原理就是函数的局部静态变量生命周期随着进程结束而结束。上述代码通过懒汉式的方式实现。 调用如下\n123456void test_single2()&#123;    //多线程情况下可能存在问题    cout &lt;&lt; &quot;s1 addr is &quot; &lt;&lt; &amp;Single2::GetInst() &lt;&lt; endl;    cout &lt;&lt; &quot;s2 addr is &quot; &lt;&lt; &amp;Single2::GetInst() &lt;&lt; endl;&#125;\n\n程序输出如下\n12sp1  is  0x1304b10sp2  is  0x1304b10\n\n确实生成了唯一实例，上述单例模式存在隐患，对于多线程方式生成的实例可能时多个。\n静态成员变量指针方式可以定义一个类的静态成员变量，用来控制实现单例\n1234567891011121314151617181920212223//饿汉式class Single2Hungry&#123;private:    Single2Hungry()    &#123;    &#125;    Single2Hungry(const Single2Hungry &amp;) = delete;    Single2Hungry &amp;operator=(const Single2Hungry &amp;) = delete;public:    static Single2Hungry *GetInst()    &#123;        if (single == nullptr)        &#123;            single = new Single2Hungry();        &#125;        return single;    &#125;private:    static Single2Hungry *single;&#125;;\n\n这么做的一个好处是我们可以通过饿汉式的方式避免线程安全问题\n123456789101112131415161718192021//饿汉式初始化Single2Hungry *Single2Hungry::single = Single2Hungry::GetInst();void thread_func_s2(int i)&#123;    cout &lt;&lt; &quot;this is thread &quot; &lt;&lt; i &lt;&lt; endl;    cout &lt;&lt; &quot;inst is &quot; &lt;&lt; Single2Hungry::GetInst() &lt;&lt; endl;&#125;void test_single2hungry()&#123;    cout &lt;&lt; &quot;s1 addr is &quot; &lt;&lt; Single2Hungry::GetInst() &lt;&lt; endl;    cout &lt;&lt; &quot;s2 addr is &quot; &lt;&lt; Single2Hungry::GetInst() &lt;&lt; endl;    for (int i = 0; i &lt; 3; i++)    &#123;        thread tid(thread_func_s2, i);        tid.join();    &#125;&#125;int main()&#123;    test_single2hungry()&#125;\n\n程序输出如下\n12345678s1 addr is 0x1e4b00s2 addr is 0x1e4b00this is thread 0inst is 0x1e4b00this is thread 1inst is 0x1e4b00this is thread 2inst is 0x1e4b00\n\n可见无论单线程还是多线程模式下，通过静态成员变量的指针实现的单例类都是唯一的。饿汉式是在程序启动时就进行单例的初始化，这种方式也可以通过懒汉式调用，无论饿汉式还是懒汉式都存在一个问题，就是什么时候释放内存？多线程情况下，释放内存就很难了，还有二次释放内存的风险。 我们定义一个单例类并用懒汉式方式调用\n1234567891011121314151617181920212223242526272829303132333435//懒汉式指针//即使创建指针类型也存在问题class SinglePointer&#123;private:    SinglePointer()    &#123;    &#125;    SinglePointer(const SinglePointer &amp;) = delete;    SinglePointer &amp;operator=(const SinglePointer &amp;) = delete;public:    static SinglePointer *GetInst()    &#123;        if (single != nullptr)        &#123;            return single;        &#125;        s_mutex.lock();        if (single != nullptr)        &#123;            s_mutex.unlock();            return single;        &#125;        single = new SinglePointer();        s_mutex.unlock();        return single;    &#125;private:    static SinglePointer *single;    static mutex s_mutex;&#125;;\n\n在cpp文件里初始化静态成员,并定义一个测试函数\n12345678910111213141516171819202122232425//懒汉式//在类的cpp文件定义static变量SinglePointer *SinglePointer::single = nullptr;std::mutex SinglePointer::s_mutex;void thread_func_lazy(int i)&#123;    cout &lt;&lt; &quot;this is lazy thread &quot; &lt;&lt; i &lt;&lt; endl;    cout &lt;&lt; &quot;inst is &quot; &lt;&lt; SinglePointer::GetInst() &lt;&lt; endl;&#125;void test_singlelazy()&#123;    for (int i = 0; i &lt; 3; i++)    &#123;        thread tid(thread_func_lazy, i);        tid.join();    &#125;    //何时释放new的对象？造成内存泄漏&#125;int main()&#123;    test_singlelazy();&#125;\n\n函数输出如下\n123456this is lazy thread 0inst is 0xbc1700this is lazy thread 1inst is 0xbc1700this is lazy thread 2inst is 0xbc1700\n\n此时生成的单例对象的内存空间还没回收，这是个问题，另外如果多线程情况下多次delete也会造成崩溃。\n智能指针方式可以利用智能指针自动回收内存的机制设计单例类\n12345678910111213141516171819202122232425262728293031323334353637383940//利用智能指针解决释放问题class SingleAuto&#123;private:    SingleAuto()    &#123;    &#125;    SingleAuto(const SingleAuto &amp;) = delete;    SingleAuto &amp;operator=(const SingleAuto &amp;) = delete;public:    ~SingleAuto()    &#123;        cout &lt;&lt; &quot;single auto delete success &quot; &lt;&lt; endl;    &#125;    static std::shared_ptr&lt;SingleAuto&gt; GetInst()    &#123;        if (single != nullptr)        &#123;            return single;        &#125;        s_mutex.lock();        if (single != nullptr)        &#123;            s_mutex.unlock();            return single;        &#125;        single = std::shared_ptr&lt;SingleAuto&gt;(new SingleAuto);        s_mutex.unlock();        return single;    &#125;private:    static std::shared_ptr&lt;SingleAuto&gt; single;    static mutex s_mutex;&#125;;\n\nSingleAuto的GetInst返回std::shared_ptr类型的变量single。因为single是静态成员变量，所以会在进程结束时被回收。智能指针被回收时会调用内置指针类型的析构函数，从而完成内存的回收。 在主函数调用如下测试函数\n123456789101112131415// 智能指针方式std::shared_ptr&lt;SingleAuto&gt; SingleAuto::single = nullptr;mutex SingleAuto::s_mutex;void test_singleauto()&#123;    auto sp1 = SingleAuto::GetInst();    auto sp2 = SingleAuto::GetInst();    cout &lt;&lt; &quot;sp1  is  &quot; &lt;&lt; sp1 &lt;&lt; endl;    cout &lt;&lt; &quot;sp2  is  &quot; &lt;&lt; sp2 &lt;&lt; endl;    //此时存在隐患，可以手动删除裸指针，造成崩溃    // delete sp1.get();&#125;int main()&#123;    test_singleauto();&#125;\n\n程序输出如下\n12sp1  is  0x1174f30sp2  is  0x1174f30\n\n智能指针方式不存在内存泄漏，但是有一个隐患就是单例类的析构函数时public的，如果被人手动调用会存在崩溃问题，比如将上边test_singleauto中的注释打开，程序会崩溃。\n辅助类智能指针单例模式智能指针在构造的时候可以指定删除器，所以可以传递一个辅助类或者辅助函数帮助智能指针回收内存时调用我们指定的析构函数。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// safe deletor//防止外界delete//声明辅助类//该类定义仿函数调用SingleAutoSafe析构函数//不可以提前声明SafeDeletor，编译时会提示incomplete type// class SafeDeletor;//所以要提前定义辅助类class SingleAutoSafe;class SafeDeletor&#123;public:    void operator()(SingleAutoSafe *sf)    &#123;        cout &lt;&lt; &quot;this is safe deleter operator()&quot; &lt;&lt; endl;        delete sf;    &#125;&#125;;class SingleAutoSafe&#123;private:    SingleAutoSafe() &#123;&#125;    ~SingleAutoSafe()    &#123;        cout &lt;&lt; &quot;this is single auto safe deletor&quot; &lt;&lt; endl;    &#125;    SingleAutoSafe(const SingleAutoSafe &amp;) = delete;    SingleAutoSafe &amp;operator=(const SingleAutoSafe &amp;) = delete;    //定义友元类，通过友元类调用该类析构函数    friend class SafeDeletor;public:    static std::shared_ptr&lt;SingleAutoSafe&gt; GetInst()    &#123;        if (single != nullptr)        &#123;            return single;        &#125;        s_mutex.lock();        if (single != nullptr)        &#123;            s_mutex.unlock();            return single;        &#125;        //额外指定删除器        single = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe, SafeDeletor());        //也可以指定删除函数        // single = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe, SafeDelFunc);        s_mutex.unlock();        return single;    &#125;private:    static std::shared_ptr&lt;SingleAutoSafe&gt; single;    static mutex s_mutex;&#125;;\n\nSafeDeletor要写在SingleAutoSafe上边，并且SafeDeletor要声明为SingleAutoSafe类的友元类，这样就可以访问SingleAutoSafe的析构函数了。 我们在构造single时制定了SafeDeletor(),single在回收时，会调用SingleAutoSafe的仿函数，从而完成内存的销毁。 并且SingleAutoSafe的析构函数为私有的无法被外界手动调用了。\n1234567891011121314151617//智能指针初始化为nullptrstd::shared_ptr&lt;SingleAutoSafe&gt; SingleAutoSafe::single = nullptr;mutex SingleAutoSafe::s_mutex;void test_singleautosafe()&#123;    auto sp1 = SingleAutoSafe::GetInst();    auto sp2 = SingleAutoSafe::GetInst();    cout &lt;&lt; &quot;sp1  is  &quot; &lt;&lt; sp1 &lt;&lt; endl;    cout &lt;&lt; &quot;sp2  is  &quot; &lt;&lt; sp2 &lt;&lt; endl;    //此时无法访问析构函数，非常安全    // delete sp1.get();&#125;int main()&#123;    test_singleautosafe();&#125;\n\n程序输出如下\n12sp1  is  0x1264f30sp2  is  0x1264f30\n\n通过辅助类调用单例类的析构函数保证了内存释放的安全性和唯一性。这种方式时生产中常用的。如果将test_singleautosafe函数的注释打开，手动delete sp1.get()编译阶段就会报错，达到了代码安全的目的。因为析构被设置为私有函数了。\n通用的单例模板类我们可以通过声明单例的模板类，然后继承这个单例模板类的所有类就是单例类了。达到泛型编程提高效率的目的。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445template &lt;typename T&gt;class Single_T&#123;protected:    Single_T() = default;    Single_T(const Single_T&lt;T&gt; &amp;st) = delete;    Single_T &amp;operator=(const Single_T&lt;T&gt; &amp;st) = delete;    ~Single_T()    &#123;        cout &lt;&lt; &quot;this is auto safe template destruct&quot; &lt;&lt; endl;    &#125;public:    static std::shared_ptr&lt;T&gt; GetInst()    &#123;        if (single != nullptr)        &#123;            return single;        &#125;        s_mutex.lock();        if (single != nullptr)        &#123;            s_mutex.unlock();            return single;        &#125;        //额外指定删除器        single = std::shared_ptr&lt;T&gt;(new T, SafeDeletor_T&lt;T&gt;());        //也可以指定删除函数        // single = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe, SafeDelFunc);        s_mutex.unlock();        return single;    &#125;private:    static std::shared_ptr&lt;T&gt; single;    static mutex s_mutex;&#125;;//模板类的static成员要放在h文件里初始化template &lt;typename T&gt;std::shared_ptr&lt;T&gt; Single_T&lt;T&gt;::single = nullptr;template &lt;typename T&gt;mutex Single_T&lt;T&gt;::s_mutex;\n\n我们定义一个网络的单例类，继承上述模板类即可，并将构造和析构设置为私有，同时设置友元保证自己的析构和构造可以被友元类调用.\n1234567891011//通过继承方式实现网络模块单例class SingleNet : public Single_T&lt;SingleNet&gt;&#123;private:    SingleNet() = default;    SingleNet(const SingleNet &amp;) = delete;    SingleNet &amp;operator=(const SingleNet &amp;) = delete;    ~SingleNet() = default;    friend class SafeDeletor_T&lt;SingleNet&gt;;    friend class Single_T&lt;SingleNet&gt;;&#125;;\n\n在主函数中调用如下\n1234567void test_singlenet()&#123;    auto sp1 = SingleNet::GetInst();    auto sp2 = SingleNet::GetInst();    cout &lt;&lt; &quot;sp1  is  &quot; &lt;&lt; sp1 &lt;&lt; endl;    cout &lt;&lt; &quot;sp2  is  &quot; &lt;&lt; sp2 &lt;&lt; endl;&#125;\n\n程序输出如下\n12sp1  is  0x1164f30sp2  is  0x1164f30\n\n总结本文介绍了一些面试常见问题 源码链接 https://gitee.com/secondtonone1/cpplearn 想系统学习更多C++知识,可点击下方链接。 C++基础\n","slug":"再谈单例模式","date":"2022-03-08T16:49:00.000Z","categories_index":"智能指针","tags_index":"单例模式,智能指针","author_index":"kiyose408"},{"id":"adc37eeabf3d5d5cb2363096a2fd87f2","title":"动态数组","content":"C++语言和标准库提供了两种一次分配一个对象数组的方法。C++语言定义了另一种new表达式语法，可以分配并初始化一个对象数组。标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。\nnew和数组为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目。在下例中，new分配要求数量的对象并（假定分配成功后）返回指向第一个对象的指针：\n123456789101112131415int get_size_new()&#123;    return 42;&#125;void new_array()&#123;    int *p_array = new int[get_size_new()]();    for (int i = 0; i &lt; get_size_new(); i++)    &#123;        cout &lt;&lt; *(p_array + i) &lt;&lt; &quot; &quot;;    &#125;    delete[] p_array;    cout &lt;&lt; endl;&#125;\n\n在main函数中调用new_array会输出42个0,因为new 分配的数组初始值都为0。 为了释放动态数组，我们使用一种特殊形式的delete——在指针前加上一个空方括号对. 方括号中的大小必须是整型，但不必是常量。也可以用一个表示数组类型的类型别名，来分配一个数组，这样，new表达式中就不需要方括号了：\n12345678void new_array()&#123;    //定义数组类型    typedef int array_type[10];    //动态开辟数组空间    int *p_array = new (array_type);    delete[] p_array;&#125;\n\n虽然我们通常称new T[]分配的内存为“动态数组”，但这种叫法某种程度上有些误导。 当用new分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。 即使我们使用类型别名定义了一个数组类型，new也不会分配一个数组类型的对象。new返回的是一个元素类型的指针。 由于分配的内存并不是一个数组类型，因此不能对动态数组调用begin或end。 要记住我们所说的动态数组并不是数组类型，这是很重要的。 可以通过{}初始化动态数组\n1234567void new_array()&#123;    //通过&#123;&#125;初始化动态数组    int *p_array = new int[10]&#123;1, 2, 3, 4&#125;;    //释放动态数组    delete[] p_array;&#125;\n\n如果{}初始化列表小于数组长度，则默认补充空值，int补充0，string补充空字符串。 动态分配一个大小为0的数组是合法的\n123456789101112void new_array()&#123;    int n = 0;    //开辟一个大小为0的数组    int *p_array = new int[n];    for (int *p = p_array; p != n + p_array; p++)    &#123;        cout &lt;&lt; *p &lt;&lt; &quot; &quot;;    &#125;    delete[] p_array;&#125;\n\n当n为0时，开辟了一个长度为0的动态数组，因为循环条件p !&#x3D; n+p_array，所以不会进入循环。 当我们用new分配一个大小为0的数组时，new返回一个合法的非空指针。此指针保证与new返回的其他任何指针都不相同。 对于零长度的数组来说，此指针就像尾后指针一样，我们可以像使用尾后迭代器一样使用这个指针。 可以用此指针进行比较操作，就像上面循环代码中那样。可以向此指针加上（或从此指针减去）0，也可以从此指针减去自身从而得到0。但此指针不能解引用——毕竟它不指向任何元素。\n智能指针和动态数组标准库提供了一个可以管理new分配的数组的unique_ptr版本。为了用一个unique_ptr管理动态数组，我们必须在对象类型后面跟一对空方括号：\n1234567void unique_array()&#123;    //开辟一个20个整形的动态数组，用unique_ptr管理它。    auto unarray = unique_ptr&lt;int[]&gt;(new int[20]);    //释放这个动态数组    unarray.release();&#125;\n\n类型说明符中的方括号&lt;int[]&gt;指出up指向一个int数组而不是一个int。由于unarray指向一个数组，当unarray销毁它管理的指针时，会自动使用delete[]。 当一个unique_ptr指向一个数组时，我们可以使用下标运算符来访问数组中的元素：\n1234567891011121314void unique_array()&#123;    //开辟一个20个整形的动态数组，用unique_ptr管理它。    auto unarray = unique_ptr&lt;int[]&gt;(new int[20]);    //可以通过下标访问数组元素    for (size_t i = 0; i &lt; 10; i++)    &#123;        unarray[i] = 1024;    &#125;    //释放这个动态数组    unarray.release();&#125;\n\nshared_ptr也可以管理动态数组，这一点在C++ primer 第5版里没有提及，但是我自己测试好用\n1234567891011void shared_array()&#123;    // 开辟一个5个整形的动态数组，用shared_ptr管理它    auto sharray = shared_ptr&lt;int[]&gt;(new int[5]&#123;1, 2, 3, 4, 5&#125;);    for (int i = 0; i &lt; 5; i++)    &#123;        cout &lt;&lt; sharray[i] &lt;&lt; &quot; &quot;;    &#125;    sharray.reset();    cout &lt;&lt; endl;&#125;\n\nC++ primer 第5版推荐的用法如下\n123456void use_shared_array()&#123;    shared_ptr&lt;int&gt; sharray = shared_ptr&lt;int&gt;(new int[5], [](int *p)                                              &#123; delete[] p; &#125;);    sharray.reset();&#125;\n\n上例中，shared_ptr管理一个动态数组并提供了删除器。\nallocator类当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作（同时付出一定开销）。\n类似vector，allocator是一个模板。为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。 当一个allocator对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：\n123456789void use_allocator()&#123;    allocator&lt;string&gt; alloc;    // allocator分配5个string类型对象的空间    // 这些空间未构造    auto const p = alloc.allocate(5);    //销毁开辟的空间    alloc.deallocate(p, 5);&#125;\n\n上述代码用allocator构造alloc对象，说明开辟的空间是为string对象准备的，然后调用allocate开辟空间，但是这些空间不能直接使用，需要调用构造函数才能使用，我们用allocator类的construct来构造对象。\n1234567891011121314151617181920212223void use_allocator()&#123;    allocator&lt;string&gt; alloc;    // allocator分配5个string类型对象的空间    // 这些空间未构造    auto p = alloc.allocate(5);    auto q = p;    string str = &quot;c&quot;;    for (; q != p + 5; q++)    &#123;        //构造字符串，每次字符串增加c字符        alloc.construct(q, str);        str += &quot;c&quot;;    &#125;    // //打印构造的字符串列表    for (q = p; q != p + 5; q++)    &#123;        cout &lt;&lt; *q &lt;&lt; endl;    &#125;    //销毁开辟的空间    alloc.deallocate(p, 5);&#125;\n\n循环中通过construct为每个q指向的空间构造string对象，对象的内容就是str的内容，str会随着循环每次增加c，所以上面的代码输出如下\n12345ccccccccccccccc\n\n另外stl也提供了一些拷贝和填充内存的算法\n123456789101112void use_allocator()&#123;    vector&lt;int&gt; ivec = &#123;1, 2, 3, 4, 5&#125;;    allocator&lt;int&gt; alloc;    //开辟2倍ivec大小的空间    auto p = alloc.allocate(ivec.size() * 2);    //将ivec的内容copy至alloc开辟的空间里    //返回q指向剩余未构造的内存空间的起始地址    auto q = uninitialized_copy(ivec.begin(), ivec.end(), p);    //将剩余元素初始化为42    uninitialized_fill_n(q, ivec.size(), 42);&#125;\n\n通过uninitialized_copy将ivec元素拷贝到p指向的空间，同样完成了构造。 uninitialized_fill_n将剩余ivec大小未构造的空间全部初始化为42。\n总结本文介绍了动态数组开辟的方法，利用new关键字可以开辟动态数组，利用delete[]可以回收数组。 也实现了通过shared_ptr和unique_ptr等智能指针管理动态数组的方案。 最后通过列举allocator的一些方法，展示了如何实现开辟空间和构造对象分离的方式动态构造对象。 源码连接 https://gitee.com/secondtonone1/cpplearn 想系统学习更多C++知识,可点击下方链接。 C++基础\n","slug":"动态数组","date":"2022-03-02T15:49:00.000Z","categories_index":"智能指针","tags_index":"智能指针,new和数组,动态数组,allocator类","author_index":"kiyose408"},{"id":"cccb789278337c954bd0aaca0affbce9","title":"_unique_ptr和weak_ptr","content":"unique_ptrunique_ptr和shared_ptr不同，unique_ptr不允许所指向的内容被其他指针共享，所以unique_ptr是不允许拷贝构造和赋值的。\n1234567891011void use_uniqueptr()&#123;    //指向double类型的unique指针    unique_ptr&lt;double&gt; udptr;    //一个指向int类型的unique指针    unique_ptr&lt;int&gt; uiptr(new int(42));    // unique不支持copy    // unique_ptr&lt;int&gt; uiptr2(uiptr);    // unique不支持赋值    // unique_ptr&lt;int&gt; uiptr3 = uiptr;&#125;\n\n虽然我们不能拷贝或赋值unique_ptr，但可以通过调用release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique：\n123456789101112void use_uniqueptr()&#123;    //定义一个upstr    unique_ptr&lt;string&gt; upstr(new string(&quot;hello zack&quot;));    // upstr.release()返回其内置指针，并将upstr置空    // 用upstr返回的内置指针初始化了upstr2    unique_ptr&lt;string&gt; upstr2(upstr.release());    unique_ptr&lt;string&gt; upstr3(new string(&quot;hello world&quot;));    //将upstr3的内置指针转移给upstr2    // upstr2放弃原来的内置指针，指向upstr3返回的内置指针。    upstr2.reset(upstr3.release());&#125;\n\nunique_ptr有一个成员方法就是release，release可以返回unique_ptr的内置指针，并将unique_ptr置为空。 上述代码将upstr的内置指针转移给upstr2了。同样的道理，通过reset操作, upstr2将upstr3的内置指针绑定了。 release()操作提供了返回unique_ptr的内置指针的方法，但要注意release过后unique_ptr被置空，那返回的内置指针要么手动释放，要么交给其他的智能指针管理。\n12345678910void use_uniqueptr()&#123;    //定义一个upstr    unique_ptr&lt;string&gt; upstr(new string(&quot;hello zack&quot;));    //获取upstr的内置指针    string *inerp = upstr.release();    //因为此时upstr已经通过release交出内置指针使用权    //所以要手动释放内置指针的内存    delete inerp;&#125;\n\n不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr。 最常见的例子是从函数返回一个unique_ptr：\n1234567891011unique_ptr&lt;int&gt; clone_unique(int a)&#123;    return unique_ptr&lt;int&gt;(new int(a));&#125;void use_uniqueptr()&#123;    int a = 1024;    unique_ptr&lt;int&gt; mp = clone_unique(a);    cout &lt;&lt; *mp &lt;&lt; endl;&#125;\n\n删除器类似shared_ptr，我们可以为unique_ptr指定删除器，但与之不同的是，为unique_ptr指定删除器时要在尖括号里指定删除器类型\n123//p 指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象//它会调用一个名为fcn的delT类型对象 unique_ptr&lt;objT, delT&gt; p(new objT, fcn);\n\n作为一个更具体的例子，我们这样演示,先定义一个unique_deleter\n12345void unique_deleter(int *p)&#123;    cout &lt;&lt; &quot;this is unique deleter&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;inner pointer data is &quot; &lt;&lt; *p &lt;&lt; endl;&#125;\n\n再基于删除器定义一个unique_ptr\n1234void use_uniqueptr()&#123;    unique_ptr&lt;int, decltype(unique_deleter) *&gt; mp(new int(1024), unique_deleter);&#125;\n\n我们在主函数调用use_uniqueptr会输出如下\n12this is unique deleterinner pointer data is 1024\n\n在本例中我们使用了decltype来指明函数指针类型。由于decltype返回一个函数类型，所以我们必须添加一个＊来指出我们正在使用该类型的一个指针。\nweak_ptrweak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。 将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。 一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。 即使有weak_ptr指向对象，对象也还是会被释放，因此，weak_ptr的名字抓住了这种智能指针“弱”共享对象的特点。 weak_ptr同样包括reset()，use_count()等方法。 与shared_ptr不同的是，weak_ptr提供expired()方法，该方法在use_count为0时返回true, 否则返回false。所以可以通过expired方法去判断weak_ptr的内置指针是否被释放。 weak_ptr通过lock()方法返回一个shared_ptr，shared_ptr内置指针指向的空间和weak_ptr内置指针指向相同。由于weak_ptr的弱共享特点，其内置指针可能被回收，所以当expired为true时， lock()返回一个空的shared_ptr，否则返回一个shared_ptr，该shared_ptr的内置指针与weak_ptr的内置指针指向相同。 我们通过如下几个例子阐述weak_ptr的特性 1 不增加shared_ptr的引用计数\n123456789void use_weakptr()&#123;    //构造shared_ptr    auto psint = make_shared&lt;int&gt;(1024);    //用shared_ptr构造weak_ptr    weak_ptr&lt;int&gt; pwint(psint);    //打印shared_ptr的引用计数    cout &lt;&lt; &quot;shared_ptr use count is &quot; &lt;&lt; psint.use_count() &lt;&lt; endl;&#125;\n\n上述代码输出shared_ptr use count is 1 因为weak_ptr不占用引用计数。 2 通过expired判断内置指针是否被释放\n123456789101112131415161718weak_ptr&lt;int&gt; clone_weakptr(int num)&#123;    shared_ptr&lt;int&gt; psint(new int(num));    return weak_ptr&lt;int&gt;(psint);&#125;void use_weakptr()&#123;    auto wptr = clone_weakptr(1024);    if (wptr.expired())    &#123;        cout &lt;&lt; &quot;wptr inner pointer has been deleted&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;wptr inner pointer data is &quot; &lt;&lt; *(wptr.lock()) &lt;&lt; endl;    &#125;&#125;\n\n在主函数中调用use_weakptr将会输出”wptr inner pointer has been deleted”。 因为clone_weakptr返回的weak_ptr引用了局部变量psint，psint随着函数clone_weakptr结束而释放，所以wptr.expired()返回true 3 通过lock生成shared_ptr\n12345678910void use_weakptr()&#123;    shared_ptr&lt;int&gt; psint(new int(1022));    //也可以通过赋值，将shared_ptr赋值给weak_ptr    weak_ptr&lt;int&gt; pwint = psint;    //通过weak_ptr生成shared_ptr    shared_ptr&lt;int&gt; psint2 = pwint.lock();    cout &lt;&lt; &quot;psint use count is &quot; &lt;&lt; psint.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;psint2 use count is &quot; &lt;&lt; psint2.use_count() &lt;&lt; endl;&#125;\n\n可以看到通过赋值初始化pwint，pwint.lock()返回另一个shared_ptr，这样两个shared_ptr引用计数相同，都为2. 源码连接 https://gitee.com/secondtonone1/cpplearn 想系统学习更多C++知识,可点击下方链接。 C++基础\n","slug":"unique_ptr和weak_ptr","date":"2022-02-24T14:49:00.000Z","categories_index":"智能指针","tags_index":"指针,unique_ptr,weak_ptr,删除器","author_index":"kiyose408"},{"id":"a6d831861235c2eb17093e31fa78d0c7","title":"shared_ptr","content":"指针C++提供了对指针操作的方法，当我们用new开辟指定类型的空间后，就生成了一个指针。\n1234567void use_pointer()&#123;    //开辟整形指针，指向一个值为5的元素    int *pint = new int(5);    //开辟指向字符串的指针    string *pstr = new string(&quot;hello zack&quot;);&#125;\n\n通过new + 类型构造的方式可以生成指针对象，但是开辟的指针对象所占用的空间在堆空间上。需要手动回收。 可以通过delete 指针对象的方式回收\n12345678910111213141516171819void use_pointer()&#123;    //开辟整形指针，指向一个值为5的元素    int *pint = new int(5);    //开辟指向字符串的指针    string *pstr = new string(&quot;hello zack&quot;);    //释放pint指向的空间    if (pint != nullptr)    &#123;        delete pint;        pint = nullptr;    &#125;    //释放指针指向的空间。    if (pstr != nullptr)    &#123;        delete pstr;        pstr = nullptr;    &#125;&#125;\n\n通过delete 指针对象回收其指向的堆空间。为了防止double free，所以将释放后的对象分别置为nullptr。 指针存在很多隐患: 1 当一个函数返回局部变量的指针时，外部使用该指针可能会造成崩溃或逻辑错误。因为局部变量随着函数的右}释放了。 2 如果多个指针指向同一个堆空间，其中一个释放了堆空间，使用其他的指针时会造成崩溃。 3 对一个指针多次delete，会造成double free问题。 4 两个类对象A和B，分别包含对方类型的指针成员，互相引用时如何释放是个问题。\n所以C++提出了智能指针的用法，可以解决上述隐患。 shared_ptr允许多个指针指向同一个对象； unique_ptr则“独占”所指向的对象。 标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。 这三种类型都定义在memory头文件中。\n12345678910111213//我们定义一个指向整形5得指针auto psint2 = make_shared&lt;int&gt;(5);//判断智能指针是否为空if (psint2 != nullptr)&#123;    cout &lt;&lt; &quot;psint2 is &quot; &lt;&lt; *psint2 &lt;&lt; endl;&#125;auto psstr2 = make_shared&lt;string&gt;(&quot;hello zack&quot;);if (psstr2 != nullptr &amp;&amp; !psstr2-&gt;empty())&#123;    cout &lt;&lt; &quot;psstr2 is &quot; &lt;&lt; *psstr2 &lt;&lt; endl;&#125;\n\n对于智能指针得使用和普通的内置指针没什么区别，通过判断指针是否为nullptr可以判断是否为空指针。 通过-&gt;可以取指针内部得成员方法或者成员变量。 make_shared函数将参数为对象类型的构造函数的参数，将此参数传递给模板中得对象类型的构造函数，从而构造出对象类型得智能指针，节省了对象在函数传递得开销。 当我们需要获取内置类型时，可以通过智能指针的方法get()返回其底层的内置指针。\n12int *pint = psint2.get();cout &lt;&lt; &quot;*pint  is &quot; &lt;&lt; *pint &lt;&lt; endl;\n\n不要手动回收智能指针get返回的内置指针，要交给智能指针自己回收即可，否则会造成double free或者 使用智能指针产生崩溃等问题。 也不要用get()返回得内置指针初始化另一个智能指针，因为两个智能指针引用一个内置指针会出现问题，比如一个释放了另一个不知道就会导致崩溃等问题。 shared_ptr会根据引用计数管理内置指针，当引用计数为0时就自动删除内置指针。 当将一个智能指针p赋值给另一个智能指针q时，p引用计数就-1，q引用计数就+1\n123456789101112131415161718void use_sharedptr()&#123;    //我们定义一个指向整形5得指针    auto psint2 = make_shared&lt;int&gt;(5);    auto psstr2 = make_shared&lt;string&gt;(&quot;hello zack&quot;);    //将psint2赋值给psint3,他们底层的内置指针相同    // psint3和psint2引用计数相同，引用计数+1，都为2    shared_ptr&lt;int&gt; psint3 = psint2;    //打印引用计数    cout &lt;&lt; &quot;psint2 usecount is &quot; &lt;&lt; psint2.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;psint3 usecount is &quot; &lt;&lt; psint3.use_count() &lt;&lt; endl;    // psint3引用计数为1    psint3 = make_shared&lt;int&gt;(1024);    // psint2引用计数-1，变为1    //打印引用计数    cout &lt;&lt; &quot;psint2 usecount is &quot; &lt;&lt; psint2.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;psint3 usecount is &quot; &lt;&lt; psint3.use_count() &lt;&lt; endl;&#125;\n\n程序输出\n1234psint2 usecount is 2psint3 usecount is 2psint2 usecount is 1psint3 usecount is 1\n\n可以利用shared_ptr实现数据共享，我们定义一个StrBlob类，这个类仅又一个成员shared_ptr成员，用来管理vector,记录有多少个StrBlob类对象使用vector，当所有的StrBlob销毁时，vector自动回收。\n12345678910111213141516171819202122232425262728293031class StrBlob&#123;public:    //定义类型    typedef std::vector&lt;string&gt;::size_type size_type;    StrBlob();    //通过初始化列表构造    StrBlob(const initializer_list&lt;string&gt; &amp;li);    //返回vector大小    size_type size() const &#123; return data-&gt;size(); &#125;    //判断vector是否为空    bool empty()    &#123;        return data-&gt;empty();    &#125;    //向vector写入元素    void push_back(const string &amp;s)    &#123;        data-&gt;push_back(s);    &#125;    //从vector弹出元素    void pop_back();    //访问头元素    std::string &amp;front();    //访问尾元素    std::string &amp;back();private:    shared_ptr&lt;vector&lt;string&gt;&gt; data;&#125;;\n\n因为StrBlob未重载赋值运算符，也没有实现拷贝构造函数，所以StrBlob对象之间的赋值就是浅copy，因而内部成员data会随着StrBlob对象的赋值修改引用计数，默认情况下，当我们拷贝、赋值或销毁一个StrBlob对象时，它的shared_ptr成员会被拷贝、赋值或销毁。 当然我们也可以实现拷贝构造和赋值操作，让大家更好的理解智能指针随着类对象赋值等操作达到共享的效果。 运算符重载之后介绍，为了让程序更完善，这里给出拷贝构造和运算符重载的完整类声明。\n12345678910111213141516171819202122232425262728293031323334353637class StrBlob&#123;public:    //定义类型    typedef std::vector&lt;string&gt;::size_type size_type;    StrBlob();    //通过初始化列表构造    StrBlob(const initializer_list&lt;string&gt; &amp;li);    //拷贝构造函数    StrBlob(const StrBlob &amp;sb);    StrBlob &amp;operator=(const StrBlob &amp;sb);    //返回vector大小    size_type size() const &#123; return data-&gt;size(); &#125;    //判断vector是否为空    bool empty()    &#123;        return data-&gt;empty();    &#125;    //向vector写入元素    void push_back(const string &amp;s)    &#123;        data-&gt;push_back(s);    &#125;    //从vector弹出元素    void pop_back();    //访问头元素    std::string &amp;front();    //访问尾元素    std::string &amp;back();private:    shared_ptr&lt;vector&lt;string&gt;&gt; data;    //检测i是否越界    void check(size_type i, const string &amp;msg) const;&#125;;\n\n接下来实现三个构造函数\n1234567891011121314StrBlob::StrBlob()&#123;    data = make_shared&lt;vector&lt;string&gt;&gt;();&#125;StrBlob::StrBlob(const StrBlob &amp;sb)&#123;    data = sb.data;&#125;StrBlob::StrBlob(const initializer_list&lt;string&gt; &amp;li)&#123;    data = make_shared&lt;vector&lt;string&gt;&gt;(li);&#125;\n\n默认构造函数初始化data指向了一个空的vector，拷贝构造函数将sb的data赋值给自己，初始化列表方式的构造函数是用初始化列表构造data。接下来实现赋值运算符的重载\n123456789StrBlob &amp;StrBlob::operator=(const StrBlob &amp;sb)&#123;    if (&amp;sb != this)    &#123;        this-&gt;data = sb.data;    &#125;    return *this;&#125;\n\n将sb的data赋值给this-&gt;data，这样this-&gt;data和sb.data引用计数相同。 我们实现检查越界的函数\n12345678//检测i是否越界void StrBlob::check(size_type i, const string &amp;msg) const&#123;    if (i &gt;= data-&gt;size())    &#123;        throw out_of_range(msg);    &#125;&#125;\n\n接下来实现front\n1234567891011121314string &amp;StrBlob::front()&#123;    //不要返回局部变量的引用    // if (data-&gt;size() &lt;= 0)    // &#123;    //     return string(&quot;&quot;);    // &#125;    // 1 可以用一个局部变量返回异常情况    if (data-&gt;size() &lt;= 0)    &#123;        return badvalue;    &#125;    return data-&gt;front();&#125;\n\n要考虑队列为空的情况，此时返回空字符串。但是如果我们直接构造一个空字符串返回，这样就返回了局部变量的引用，局部变量会随着函数结束而释放，造成安全隐患。所以我们可以返回类的成员变量badvalue，作为队列为空的标记。当然如果不能容忍队列为空的情况，可以通过抛出异常来处理，那我们用这种方式改写front\n12345string &amp;StrBlob::front()&#123;    check(0, &quot;front on empty StrBlob&quot;);    return data-&gt;front();&#125;\n\n同样我们实现back()和pop_back()\n1234567891011string &amp;StrBlob::back()&#123;    check(0, &quot;back on empty StrBlog&quot;);    return data-&gt;back();&#125;void StrBlob::pop_back()&#123;    check(0, &quot;back on pop_back StrBlog&quot;);    data-&gt;pop_back();&#125;\n\n这样我们通过定义StrBlob类，达到共享vector的方式。多个StrBlob操作的是一个vector向量。 我们新增一个打印shared_ptr引用计数的方法\n1234void StrBlob::printCount()&#123;    cout &lt;&lt; &quot;shared_ptr use count is &quot; &lt;&lt; data.use_count() &lt;&lt; endl;&#125;\n\n下面测试以下\n123456789101112131415161718192021222324void test_StrBlob()&#123;    StrBlob strblob1(&#123;&quot;hello&quot;, &quot;zack&quot;, &quot;good luck&quot;&#125;);    StrBlob strblob2;    try    &#123;        auto str2front = strblob2.front();    &#125;    catch (std::out_of_range &amp;exc)    &#123;        cout &lt;&lt; exc.what() &lt;&lt; endl;    &#125;    catch (...)    &#123;        cout &lt;&lt; &quot;unknown exception&quot; &lt;&lt; endl;    &#125;    strblob2 = strblob1;    auto str1front = strblob1.front();    cout &lt;&lt; &quot;strblob1 front is &quot; &lt;&lt; str1front &lt;&lt; endl;    strblob2.printCount();    strblob1.printCount();&#125;\n\n程序输出\n1234front on empty StrBlobstrblob1 front is helloshared_ptr use count is 2shared_ptr use count is 2\n\n因为strblob2的队列为空，所以会抛出异常，当执行strblob2 &#x3D; strblob1之后，strblob2和strblob1的data的引用计数相同都为2。\nshared_ptr和new结合之前的方式都是通过make_shared&lt;类型&gt;(构造函数列表参数)的方式构造的shared_ptr，也可以通过new 生成的内置指针初始化生成shared_ptr。\n12auto psint = shared_ptr&lt;int&gt;(new int(5));auto psstr = shared_ptr&lt;string&gt;(new string(&quot;hello zack&quot;));\n\n接受指针参数的智能指针构造函数是explicit的。因此，我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式来初始化一个智能指针：\n1234//错误，不能用内置指针隐式初始化shared_ptr// shared_ptr&lt;int&gt; psint2 = new int(5);//正确，显示初始化shared_ptr&lt;string&gt; psstr2(new string(&quot;good luck&quot;));\n\n除了智能指针之间的赋值，可以通过一个智能指针构造另一个\n12345shared_ptr&lt;string&gt; psstr2(new string(&quot;good luck&quot;));//可以通过一个shared_ptr 构造另一个shared_ptrshared_ptr&lt;string&gt; psstr3(psstr2);cout &lt;&lt; &quot;psstr2 use count is &quot; &lt;&lt; psstr2.use_count() &lt;&lt; endl;cout &lt;&lt; &quot;psstr3 use count is &quot; &lt;&lt; psstr3.use_count() &lt;&lt; endl;\n\n程序输出\n12psstr2 use count is 2psstr3 use count is 2\n\n通过一个指针构造另一个智能指针，两个指针共享底层内置指针，所以引用计数为2. 在构造智能指针的同时，可以指定自定义的删除方法替代shared_ptr自己的delete操作\n12//可以设置新的删除函数替代deleteshared_ptr&lt;string&gt; psstr4(new string(&quot;good luck for zack&quot;), delfunc);\n\n我们为psstr4指定了delfunc删除函数，这样当psstr4被释放时就会执行delfunc函数，而不是delete操作。\n12345678910void delfunc(string *p)&#123;    if (p != nullptr)    &#123;        delete (p);        p = nullptr;    &#125;    cout &lt;&lt; &quot;self delete&quot; &lt;&lt; endl;&#125;\n\n我们实现了自己的delfunc函数作为删除器，回收了内置指针，并且打印了删除信息。这样当psstr4执行析构时，会打印”self delete”。 推荐使用make_shared的方式构造智能指针。 如果通过内置指针初始化生成智能指针，那一定要记住不要手动回收内置指针。 当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr。 一旦这样做了，我们就不应该再使用内置指针来访问shared_ptr所指向的内存了。 以下代码存在问题\n12345678910111213void process(shared_ptr&lt;int&gt; psint)&#123;    cout &lt;&lt; &quot;psint data is &quot; &lt;&lt; *psint &lt;&lt; endl;&#125;int main()&#123;    int *p = new int(5);    process(shared_ptr&lt;int&gt;(p));    //危险，p已经被释放，会造成崩溃或者逻辑错误    cout &lt;&lt; &quot;p data is &quot; &lt;&lt; *p &lt;&lt; endl;    return 0;&#125;\n\n程序输出\n12psint data is 5p data is 10569024\n\n因为p构造为shared_ptr，那么它的回收就交给了shared_ptr，而shared_ptr是process的形参，形参在process运行结束会释放，那么p也被回收，之后再访问p会产生逻辑错误，所以打印了一个非法内存的数值。\n智能指针类型定义了一个名为get的函数，它返回一个内置指针，指向智能指针管理的对象。 此函数是为了这样一种情况而设计的：我们需要向不能使用智能指针的代码传递一个内置指针。 使用get返回的指针的代码不能delete此指针。\n123456789101112131415void bad_use_sharedptr()&#123;    shared_ptr&lt;int&gt; p(new int(5));    //通过p获取内置指针q    //注意q此时被p绑定，不要手动delete q    int *q = p.get();    &#123;        //两个独立的shared_ptr m和p都绑定q        auto m = shared_ptr&lt;int&gt;(q);    &#125;    //上述&#125;结束则m被回收，其绑定的q也被回收    //此时使用q是非法操作，崩溃或者逻辑错误    cout &lt;&lt; &quot;q data is &quot; &lt;&lt; *q &lt;&lt; endl;&#125;\n\n上述代码虽然没有手动delete q但是，两个独立的shared_ptr m和p都绑定了q，导致其中一个m被回收时q的内存也回收所以之后访问*q会出现崩溃或者数据异常。 注意，以下代码和上面是不同的，m和p此时共享q,并且引用计数是共享同步的。\n123456789101112131415void good_use_sharedptr()&#123;    shared_ptr&lt;int&gt; p(new int(5));    //通过p获取内置指针q    //注意q此时被p绑定，不要手动delete q    int *q = p.get();    &#123;        // m和p的引用计数都为2        shared_ptr&lt;int&gt; m(p);    &#125;    //上述&#125;结束则m被回收，其绑定的q也被回收    //此时使用q是非法操作，崩溃或者逻辑错误    cout &lt;&lt; &quot;q data is &quot; &lt;&lt; *q &lt;&lt; endl;&#125;\n\n所以总结以下： get用来将指针的访问权限传递给代码，你只有在确定代码不会delete指针的情况下，才能使用get。 特别是，永远不要用get初始化另一个智能指针或者为另一个智能指针赋值。\nresetreset的功能是为shared_ptr重新开辟一块新的内存，让shared_ptr绑定这块内存\n123shared_ptr&lt;int&gt; p(new int(5));// p重新绑定新的内置指针p.reset(new int(6));\n\n上述代码为p重新绑定了新的内存空间。 reset常用的情况是判断智能指针是否独占内存，如果引用计数为1，也就是自己独占内存就去修改，否则就为智能指针绑定一块新的内存进行修改，防止多个智能指针共享一块内存，一个智能指针修改内存导致其他智能指针受影响。\n123456789//如果引用计数为1，unique返回trueif (!p.unique())&#123;    //还有其他人引用，所以我们为p指向新的内存    p.reset(new int(6));&#125;// p目前是唯一用户*p = 1024;\n\n使用智能指针的另一个好处，就是当程序一场崩溃时，智能指针也能保证内存空间被回收\n1234567void execption_shared()&#123;    shared_ptr&lt;string&gt; p(new string(&quot;hello zack&quot;));    //此处导致异常    int m = 5 / 0;    //即使崩溃也会保证p被回收&#125;\n\n即使运行到 m &#x3D; 5 &#x2F; 0处，程序崩溃，智能指针p也会被回收。 有时候我们传递个智能指针的指针不是new分配的，那就需要我们自己给他传递一个删除器\n12345678910void delfuncint(int *p)&#123;    cout &lt;&lt; *p &lt;&lt; &quot; in del func&quot; &lt;&lt; endl;&#125;void delfunc_shared()&#123;    int p = 6;    shared_ptr&lt;int&gt; psh(&amp;p, delfuncint);&#125;\n\n如果不传递delfuncint，会造成p被智能指针delete，因为p是栈空间的变量，用delete会导致崩溃。\n总结智能指针陷阱智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的前提下。 为了正确使用智能指针，我们必须坚持一些基本规范： · 不使用相同的内置指针值初始化（或reset）多个智能指针。 · 不delete get（）返回的指针。 · 不使用get（）初始化或reset另一个智能指针。 · 如果你使用get（）返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。 · 如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。\n源码连接 https://gitee.com/secondtonone1/cpplearn\n","slug":"shared_ptr","date":"2022-02-14T02:49:00.000Z","categories_index":"智能指针","tags_index":"指针,shared_ptr,reset","author_index":"kiyose408"},{"id":"e5cddefd1d930eb71bc590588a1288b4","title":"迭代器分类","content":"除了容器自定义的迭代器之外，标准库还提供了其他几种迭代器，包括插入迭代器，流迭代器，反向迭代器，移动迭代器。\n插入迭代器迭代器被绑定到一个容器上，可用来向容器插入元素。插入迭代器包括back_inserter, front_inserter, inserter三种。 back_inserter绑定到容器后，对该迭代器赋值，就执行了类似于push_back的操作，前提是该容器要支持push_back。 front_inserter绑定到容器后，对该迭代器赋值，就执行了类似于push_front的操作，前提是该容器支持push_front。 inserter创建一个使用insert的迭代器，此函数接受第二个参数必须是一个指向给定容器的迭代器，元素被插入到给定迭代器所表示的元素之前。\n1234567891011121314151617181920void use_inserter()&#123;    list&lt;int&gt; list1 = &#123;1, 2, 3, 4&#125;;    list&lt;int&gt; list2, list3, list4;    copy(list1.begin(), list1.end(), front_inserter(list2));    copy(list1.begin(), list1.end(), back_inserter(list3));    copy(list1.begin(), list1.end(), inserter(list4, list4.begin()));    for_each(list2.begin(), list2.end(), [](const int &amp;i)             &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;);    cout &lt;&lt; endl;    for_each(list3.begin(), list3.end(), [](const int &amp;i)             &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;);    cout &lt;&lt; endl;    for_each(list4.begin(), list4.end(), [](const int &amp;i)             &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;);    cout &lt;&lt; endl;&#125;\n\n程序输出\n1234 3 2 11 2 3 41 2 3 4\n\niostream迭代器istream_iterator 读取输入流，ostream_iterator 向一个输出流写数据。 这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。 通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。 我们先看看输入流的操作:\n123456789101112131415void use_istreamiter()&#123;    //输入流迭代器    istream_iterator&lt;int&gt; in_int(cin);    //迭代器终止标记    istream_iterator&lt;int&gt; in_eof;    vector&lt;int&gt; in_vec;    while (in_int != in_eof)    &#123;        in_vec.push_back(*in_int++);    &#125;    for_each(in_vec.begin(), in_vec.end(), [](const int &amp;i)             &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;);    cout &lt;&lt; endl;&#125;\n\n上述代码创建了输入流迭代器in_int，绑定了cin。 同时生成了一个输入流的结尾迭代器in_eof，in_eof未绑定任何输入流，所以是输入流的终止。 通过循环将输入流数据写入in_vec中。 再看看输出流的操作:\n12345678910void use_ostreamiter()&#123;    vector&lt;int&gt; in_vec = &#123;1, 3, 4, 2, 5, 6, 7, 9&#125;;    ostream_iterator&lt;int&gt; out_in(cout, &quot; &quot;);    for (auto data : in_vec)    &#123;        *out_in++ = data;    &#125;    cout &lt;&lt; endl;&#125;\n\n输出流迭代器out_in和cout绑定，并且为每一个输出的元素设置了空格间隔。 通过向*out_in赋值达到向cout写入数据的目的，同时out_in++保证了迭代器的后移。\n反向迭代器反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个元素；递减一个迭代器（–it）会移动到下一个元素 cbegin和cend表示正向迭代器，crbegin和crend表示反向迭代器,如下图  我们通过反向迭代器逆序打印原容器中的数据\n123456789void use_reverseiter()&#123;    vector&lt;int&gt; in_vec = &#123;1, 3, 4, 2, 5, 6, 7, 9&#125;;    for (auto rit = in_vec.crbegin(); rit != in_vec.crend(); rit++)    &#123;        cout &lt;&lt; *rit &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;\n\n程序输出9 7 6 5 2 4 3 1 我们知道sort默认规则是从小到大，如果我们想实现从大到小，可以利用反向迭代器完成\n1sort(vec.rbegin(), vec.rend());\n\n反向迭代器遍历是从后往前，这一点也会造成一些不必要的问题\n123string line = &quot;FIRST,MIDDLE,LAST&quot;;auto rcomma = find(line.crbegin(), line.crend(), &#x27;,&#x27;);cout &lt;&lt; string(line.crbegin(), rcomma) &lt;&lt; endl;\n\n上述代码会找到最后一个逗号，获取crbegin和rcomma之间的数据实际是TSAL,也就是说反向迭代器遍历是反向的。 标准库提供了一个将反向迭代器转化为正向迭代器的方法base()\n12//通过base将反向迭代器转化为正向的cout &lt;&lt; string(rcomma.base(), line.cend()) &lt;&lt; endl;\n\n程序输出LAST 大家可以看一下正向迭代器和反向迭代器的关系图 \n","slug":"迭代器分类","date":"2022-02-05T05:49:00.000Z","categories_index":"泛型用法","tags_index":"迭代器,插入迭代器,方向迭代器,iostream迭代器","author_index":"kiyose408"},{"id":"72f8e112b71c8b55e9acbece39e8eb93","title":"泛型定制","content":"向算法传递函数默认情况下，泛型算法还实现了另外一个版本，就是接受一个额外的参数。比如sort函数，接受第三个参数，第三个参数是一个谓词。 谓词就是一个可调用的表达式，其返回值结果是一个能用作条件的值。 标准库算法所使用的谓词分为两类： 一元谓词（unary predicate，意味着它们只接受单一参数）和二元谓词（binary predicate，意味着它们有两个参数）。 接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。 我们可以暂且将谓词理解为函数 我们利用谓词，修改sort的排序规则\n1234bool isShort(const string &amp;s1, const string &amp;s2)&#123;    return s1.size() &lt; s2.size();&#125;\n\n上述代码将规则修改为按长度有小到大排序 接下来我们实现一个函数调用sort并传递参数isShort\n123456789void use_predicate()&#123;    vector&lt;string&gt; words = &#123;&quot;hello&quot;, &quot;za&quot;, &quot;zack&quot;, &quot;no matter&quot;, &quot;what&quot;&#125;;    sort(words.begin(), words.end(), isShort);    for (auto it = words.begin(); it != words.end(); it++)    &#123;        cout &lt;&lt; *it &lt;&lt; endl;    &#125;&#125;\n\n上面的函数输出\n12345zazackwhathellono matter\n\nlambda表达式lambda表达式提供了类似函数的功能，可以理解为一个匿名函数，通过传递参数和捕获外部变量的引用，值等方式完成一些逻辑处理。 一个lambda表达式表示一个可调用的代码单元。 我们可以将其理解为一个未命名的内联函数。 与任何函数类似，一个lambda具有一个返回类型、一个参数列表和一个函数体。 但与函数不同，lambda可能定义在函数内部。 一个lambda表达式具有如下形式\n1[capture list](parameter list) -&gt; return type &#123;function body&#125;\n\ncapture list表示捕获列表，如果lambda表达式定义在函数内部，可以通过capture list 捕获该函数的局部变量的引用或者值。 return type、parameter list和function body与任何普通函数一样，分别表示返回类型、参数列表和函数体。 我们可以忽略返回类型，lambda可以根据返回值自己推导返回类型。\n12auto f = []() &#123; return 42; &#125;;\n\n此例中，我们定义了一个可调用对象f，它不接受参数，返回42。lambda的调用方式与普通函数的调用方式相同，都是使用调用运算符：\n1cout &lt;&lt; &quot; f is &quot; &lt;&lt; f() &lt;&lt; endl;\n\n如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void。 我们将isShorter函数定义为lambda表达式\n12[](const string &amp;s1, const string &amp;s2) -&gt; bool  &#123; return s1.size() &lt; s2.size(); &#125;;\n\n我们可以通过调用stable_sort进行排序，长度相同的单词维持原序列.\n123vector&lt;string&gt; words = &#123;&quot;hello&quot;, &quot;za&quot;, &quot;zack&quot;, &quot;no matter&quot;, &quot;what&quot;&#125;;    stable_sort(words.begin(), words.end(), [](const string &amp;s1, const string &amp;s2) -&gt; bool                &#123; return s1.size() &lt; s2.size(); &#125;);\n\n我们打印words\n1234for (auto it = words.begin(); it != words.end(); it++)    &#123;        cout &lt;&lt; *it &lt;&lt; endl;    &#125;\n\n输出如下\n12345zazackwhathellono matter\n\n我们用lambda表达式的捕获功能，实现一个函数，查找长度大于指定数值的单词个数。 我们先实现一个将单词排序并去除重复单词的函数\n12345678910void erase_dup(vector&lt;string&gt; &amp;words)&#123;    //先将words中的词语排序    sort(words.begin(), words.end());    // unique会移动元素，将不重复的元素放在前边，重复的放在后边    // unique返回不重复的最后一个元素的位置    const auto uniqueiter = unique(words.begin(), words.end());    //调用erase将重复的元素删除    words.erase(uniqueiter, words.end());&#125;\n\n接下来我们实现biggers函数，返回大于指定长度sz的单词的个数\n12345678910111213int use_bigger(int sz)&#123;    vector&lt;string&gt; words = &#123;&quot;hello&quot;, &quot;za&quot;, &quot;zack&quot;, &quot;no matter&quot;, &quot;what&quot;&#125;;    //先排序去除重复单词    erase_dup(words);    //再稳定排序，按照长度有小到大    stable_sort(words.begin(), words.end(), [](const string &amp;s1, const string &amp;s2) -&gt; bool                &#123; return s1.size() &lt; s2.size(); &#125;);    auto findit = find_if(words.begin(), words.end(), [sz](const string &amp;s)                          &#123; return s.size() &gt; sz; &#125;);    return words.end() - findit;&#125;\n\n我们测试下\n123cout &lt;&lt; &quot;count is &quot; &lt;&lt; use_bigger(3) &lt;&lt; endl;cout &lt;&lt; &quot;count is &quot; &lt;&lt; use_bigger(5) &lt;&lt; endl;cout &lt;&lt; &quot;count is &quot; &lt;&lt; use_bigger(10) &lt;&lt; endl;\n\n程序输出如下\n123count is 4count is 1count is 0\n\n可以看出长度大于3的单词有4个，长度大于5的有1个，长度大于10的有0个。 我们通过lambda表达式[sz]的方式捕获了use_bigger的形参sz。 如果我们要将长度大于sz的单词全部打印出来,可以采用foreach函数，该函数接受三个参数，前两个是迭代器表示遍历的范围，第三个是一个表达式，表示对每个元素的操作。我们完善use_bigger函数\n123456789101112131415int use_bigger(int sz)&#123;    vector&lt;string&gt; words = &#123;&quot;hello&quot;, &quot;za&quot;, &quot;zack&quot;, &quot;no matter&quot;, &quot;what&quot;&#125;;    //先排序去除重复单词    erase_dup(words);    //再稳定排序，按照长度有小到大    stable_sort(words.begin(), words.end(), [](const string &amp;s1, const string &amp;s2) -&gt; bool                &#123; return s1.size() &lt; s2.size(); &#125;);    auto findit = find_if(words.begin(), words.end(), [sz](const string &amp;s)                          &#123; return s.size() &gt; sz; &#125;);    for_each(findit, words.end(), [](const string &amp;s)             &#123; cout &lt;&lt; s &lt;&lt; &quot; &quot;; &#125;);    cout &lt;&lt; endl;    return words.end() - findit;&#125;\n\nlambda捕获类型lambda捕获分为值捕获和引用捕获。 lambda采用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。 与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝。\n123456789void lambda_catch()&#123;    int val = 10;    auto fn = [val]    &#123; return val; &#125;;    val = 200;    auto fv = fn();    cout &lt;&lt; &quot;fv is &quot; &lt;&lt; fv &lt;&lt; endl;&#125;\n\n上述代码fv会输出10，因为fn捕获的是val的值，在lambda表达式创建时就捕获了val，此时val值为10. 如果采用引用方式捕获\n123456789void lambda_catch_r()&#123;    int val = 10;    auto fn = [&amp;val]    &#123; return val; &#125;;    val = 200;    auto fv = fn();    cout &lt;&lt; &quot;fv is &quot; &lt;&lt; fv &lt;&lt; endl;&#125;\n\n此时输出fv is 200， 因为fn捕获的是val的引用。 我们可以从一个函数返回lambda，此lambda不能包含引用捕获。因为如果lambda包含了函数局部变量的引用，当次局部变量被释放后，lambda调用会出现崩溃问题。\n捕获一个普通变量，如int、string或其他非指针类型，通常可以采用简单的值捕获方式。 在此情况下，只需关注变量在捕获时是否有我们所需的值就可以了。 如果我们捕获一个指针或迭代器，或采用引用捕获方式，就必须确保在lambda执行时，绑定到迭代器、指针或引用的对象仍然存在。 而且，需要保证对象具有预期的值。 在lambda从创建到它执行的这段时间内，可能有代码改变绑定的对象的值。 也就是说，在指针（或引用）被捕获的时刻，绑定的对象的值是我们所期望的，但在lambda执行时，该对象的值可能已经完全不同了。 一般来说，我们应该尽量减少捕获的数据量，来避免潜在的捕获导致的问题。而且，如果可能的话，应该避免捕获指针或引用。\n隐式捕获为了指示编译器推断捕获列表，应在捕获列表中写一个&amp;或&#x3D;。&amp;告诉编译器采用捕获引用方式，&#x3D;则表示采用值捕获方式。 比如我们修改use_bigger函数，参数增加一个ostream和char的分隔符，在use_bigger内部利用for_each调用\n1234567891011121314151617181920int use_bigger2(ostream &amp;os, char c, int sz)&#123;    vector&lt;string&gt; words = &#123;&quot;hello&quot;, &quot;za&quot;, &quot;zack&quot;, &quot;no matter&quot;, &quot;what&quot;&#125;;    //先排序去除重复单词    erase_dup(words);    //再稳定排序，按照长度有小到大    stable_sort(words.begin(), words.end(), [](const string &amp;s1, const string &amp;s2) -&gt; bool                &#123; return s1.size() &lt; s2.size(); &#125;);    auto findit = find_if(words.begin(), words.end(), [sz](const string &amp;s)                          &#123; return s.size() &gt; sz; &#125;);    // os 按照引用方式捕获，其余变量c 通过= 值方式隐士捕获。    for_each(findit, words.end(), [=, &amp;os](const string &amp;s)             &#123; os &lt;&lt; s &lt;&lt; c; &#125;);    // c 按照值的方式捕获，其余按照引用方式捕获。    for_each(findit, words.end(), [&amp;, c](const string &amp;s)             &#123; os &lt;&lt; s &lt;&lt; c; &#125;);    cout &lt;&lt; endl;    return words.end() - findit;&#125;\n\n上述代码两个for_each通过不同的隐式方式捕获局部变量。\nmutable改变值默认情况下，值捕获的变量，lambda不会改变其值。lambda可以声明mutable，这样可以修改捕获的变量值。\n1234567891011121314151617void mutalble_lam()&#123;    int val = 100;    auto fn = [val]() mutable    &#123;        return ++val;    &#125;;    cout &lt;&lt; &quot;val is &quot; &lt;&lt; val &lt;&lt; endl;    cout &lt;&lt; &quot;fn val is &quot; &lt;&lt; fn() &lt;&lt; endl;    val = 200;    cout &lt;&lt; &quot;val is &quot; &lt;&lt; val &lt;&lt; endl;    cout &lt;&lt; &quot;fn val is &quot; &lt;&lt; fn() &lt;&lt; endl;&#125;\n\n程序输出\n1234val is 100fn val is 101val is 200fn val is 102\n\nfn捕获val的值，因为fn是mutable所以可以修改val，但不会影响外界的val。\nlambda返回类型我们要做一个返回序列中数值的绝对值的函数\n12345678void rt_lambda()&#123;    vector&lt;int&gt; nums = &#123;-1, 2, 3, -5, 6, 7, -9&#125;;    transform(nums.begin(), nums.end(), nums.begin(), [](int a)              &#123; return a &lt; 0 ? -a : a; &#125;);    for_each(nums.begin(), nums.end(), [](int a)             &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;);&#125;\n\n通过transform将nums中的数值全部变为其绝对值。transform前两个参数表示输入序列，第三个参数表示写入的目的序列，如果目的序列迭代器和输入序列开始的迭代器相同，则表示transform序列全部元素。lambda表达式并没有写返回值类型，但是是一个三目运算符的表达式，所以lambda可以推断返回类型。如果将lambda表达式写成如下会报错。\n1[](int a)&#123; if(a&lt;0) return -a; else return a; &#125;\n\n此时我们修改上面的lambda表达式，明确写出返回类型为int\n12transform(nums.begin(), nums.end(), nums.begin(), [](int a) -&gt; int             &#123; if (a &lt; 0)  return -a; else return a; &#125;);\n\nbind绑定参数bind的形式为\n1auto newCallable = bind(callable, arg_list);\n\nnewCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。 即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。\narg_list中的参数可能包含形如_n的名字，其中n是一个整数。这些参数是“占位符”，表示newCallable的参数，它们占据了传递给newCallable的参数的“位置”。 数值n表示生成的可调用对象中参数的位置：_1为newCallable的第一个参数，_2为第二个参数，依此类推。 我们先实现一个判断字符串长度的函数\n123456789bool check_size(const string &amp;str, int sz)&#123;    if (str.size() &gt; sz)    &#123;        return true;    &#125;    return false;&#125;\n\ncheck_size如果字符串str的长度大于sz就返回true，否则就返回false。 接下来用bind操作生成一个新的函数，只接受一个sz参数。 使用bind函数要包含头文件functional，也需要使用using namespace std::placeholders\n12345678910111213141516void calsize_count()&#123;    string str = &quot;hello&quot;;    //将check_size第一个参数绑定给bind_check    auto bind_check = bind(check_size, _1, 6);    //相当于调用check_size(str,6)    bool bck = bind_check(str);    if (bck)    &#123;        cout &lt;&lt; &quot;check res is true&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;check res is false&quot; &lt;&lt; endl;    &#125;&#125;\n\n通过bind将check_size第一个参数绑定给bind_check，第二个参数为6 所以调用bind_check(str)相当于调用check_size(str,6)。 我们可以用bind方式实现find_if的查找，因为find_if接受的谓词只能有一个参数，所以通过bind将check_size生成为单参数函数。\n12345678910111213141516int use_bigger3(ostream &amp;os, char c, int sz)&#123;    vector&lt;string&gt; words = &#123;&quot;hello&quot;, &quot;za&quot;, &quot;zack&quot;, &quot;no matter&quot;, &quot;what&quot;&#125;;    //先排序去除重复单词    erase_dup(words);    //再稳定排序，按照长度有小到大    stable_sort(words.begin(), words.end(), [](const string &amp;s1, const string &amp;s2) -&gt; bool                &#123; return s1.size() &lt; s2.size(); &#125;);    auto findit = find_if(words.begin(), words.end(), bind(check_size, _1, sz));    // c 按照值的方式捕获，其余按照引用方式捕获。    for_each(findit, words.end(), [&amp;, c](const string &amp;s)             &#123; os &lt;&lt; s &lt;&lt; c; &#125;);    cout &lt;&lt; endl;    return words.end() - findit;&#125;\n\n通过bind生成新的函数传递给find_if就可以使用了。 bind极大地方便了泛型编程的可扩展性。\n","slug":"泛型定制","date":"2022-01-25T05:49:00.000Z","categories_index":"泛型用法","tags_index":"lambda表达式,泛型","author_index":"kiyose408"},{"id":"ae38a1dc51089423f709c36bdcb792e9","title":"泛型算法","content":"泛型算法泛型算法是STL库里面定义的一些算法,这些算法可以用一个接口操作各种数据类型,因此成为泛型算法。大多算法定义在头文件algorithm和numeric中。意思就是可以用一个接口操作各种类型的算法就是泛型算法。 泛型算法分为两类，一类是只读算法，一类是修改原有容器的算法。 只读算法包括find(查找),accumulate(累加)等。 修改算法包括replace(替换),fill(填充)等。\naccumulate1234567vector&lt;int&gt; nvec = &#123;1, 2, 3, 4, 5, 6, 7&#125;;//调用accumulate累加，sum的初始值为0，累加结果写入sumauto sum = accumulate(nvec.begin(), nvec.end(), 0);cout &lt;&lt; &quot;sum is &quot; &lt;&lt; sum &lt;&lt; endl;list&lt;string&gt; strlist = &#123;&quot;hello&quot;, &quot;zack&quot;, &quot;good&quot;, &quot;idea&quot;&#125;;string stradd = accumulate(strlist.begin(), strlist.end(), string(&quot;&quot;));cout &lt;&lt; &quot;str add result is &quot; &lt;&lt; stradd &lt;&lt; endl;\n\naccumulate将第三个参数作为求和起点，这蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。在上例中，vec中的元素可以是int，或者是double、long long或任何其他可以加到int上的类型。由于string定义了+运算符，所以我们可以通过调用accumulate来将vector中所有string元素连接起来. 程序输出\n12sum is 28str add result is hellozackgoodidea\n\nequal泛型算法中有操作两个序列的算法，比如equal就是比较两个序列中元素是否有相等的值，如果第一个序列中每个元素与第二个序列中的元素都相等，则返回true，否则返回false。\n123456789bool bequa = equal(strlist.begin(), strlist.end(), strlist2.begin());   if (bequa)   &#123;       cout &lt;&lt; &quot;strlist is equal to strlist2&quot; &lt;&lt; endl;   &#125;   else   &#123;       cout &lt;&lt; &quot;strlist is not equal to strlist2&quot; &lt;&lt; endl;   &#125;\n\n上述代码比较了strlist和strlist2，切记strlist2的长度要大于等于strlist，否则程序会出现问题。那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。\nfill可以通过fill算法修改容器的值,算法fill接受一对迭代器表示一个范围，还接受一个值作为第三个参数。fill将给定的这个值赋予输入序列中的每个元素。\n12345vector&lt;int&gt; nvec2 = &#123;1, 2, 3, 4&#125;;//将nvec2中所有元素设置为0fill(nvec2.begin(), nvec2.end(), 0);//将nvec2中前半部分设置为10fill(nvec2.begin(), nvec2.begin() + nvec2.size() / 2, 10);\n\n类似的还有fill_n函数，该函数接受一个单迭代器，一个计数值和一个值。\n12vector&lt;int&gt; vec;fill_n(vec.begin(), vec.size(), 0);\n\n如下调用fill会导致程序崩溃，因为vec3大小为0，而fill要向vec3写入10个0，会造成越界崩溃。\n1234//空向量vector&lt;int&gt; vec3;// 灾难，修改vec3中的10个不存在元素fill_n(vec3.begin(),10,0);\n\nback_inserterfill_n如果传递的个数大于容器的大小会造成崩溃，为了防止类似的问题，stl引入了back_inserter。back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中：\n1234567891011//空vectorvector&lt;int&gt; nvec4;// back_inserter绑定nvec4并返回迭代器auto iter = back_inserter(nvec4);//对迭代器的赋值就是对nvec插入元素*iter = 2;*iter = 4;for (auto it = nvec4.begin(); it != nvec4.end(); it++)&#123;    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125;\n\n程序依次打印输出2, 4 我们常常使用back_inserter来创建一个迭代器，作为算法的目的位置来使用。例如：\n123456//空vectorvector&lt;int&gt; nvec5;// back_inserter绑定nvec5并返回迭代器auto iter5 = back_inserter(nvec5);//添加10个元素写入nvec5fill_n(iter5, 10, 0);\n\ncopy拷贝（copy）算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给copy的目的序列至少要包含与输入序列一样多的元素。\n12345int a1[] = &#123;0, 1, 2, 3, 4, 5, 6&#125;;constexpr int nszie = sizeof(a1) / sizeof(int);int a2[nszie];//将a1内容copy到a2中copy(begin(a1), end(a1), a2);\n\nreplace我们可以通过replace替换原容器中的某个值为设定的新值\n123vector&lt;int&gt; nvec6 = &#123;1, 2, 3, 4&#125;;//将nvec6中所有元素为3的设置为32replace(nvec6.begin(), nvec6.end(), 3, 32);\n\n如果保留原容器数据，可以通过back_inserter绑定一个新的容器，然后用replace_copy完成拷贝和替换操作\n123456//原始数据列表list&lt;int&gt; ilist = &#123;0, 1, 2, 3, 4, 5&#125;;//空向量vector&lt;int&gt; rcpvec;//将ilist中的数据copy到rcpvec里，但是将其中的0替换为42replace_copy(ilist.begin(), ilist.end(), back_inserter(rcpvec), 0, 42);\n\nunique和sort我们实现一个功能，将vector中的单词排序并且去除其中重复的单词。 我们可以用sort函数先将vector中的单词排序，然后用unique去除重复的单词，unique返回不重复的最后一个元素的迭代器，unique保证容器中前n个元素是不重复的，n+1个开始就是重复的，所以我们用erase再删除n+1个元素以后的内容就可以了。\n12345678vector&lt;string&gt; words = &#123;&quot;good&quot;, &quot;idea&quot;, &quot;zack&quot;, &quot;lucy&quot;, &quot;good&quot;, &quot;idea&quot;&#125;;//先将words中的词语排序sort(words.begin(), words.end());// unique会移动元素，将不重复的元素放在前边，重复的放在后边// unique返回不重复的最后一个元素的位置const auto uniqueiter = unique(words.begin(), words.end());//调用erase将重复的元素删除words.erase(uniqueiter, words.end());\n\n打印输出words可以看到words变为{good , idea , lucy , zack}\n","slug":"泛型算法","date":"2022-01-15T05:49:00.000Z","categories_index":"泛型用法","tags_index":"算法,泛型","author_index":"kiyose408"},{"id":"30d74a927cb679b680169d9bb1c056fd","title":"软件测试基础","content":"一、接口的认识什么是接口电脑：USB，投影机（数据传输）\n\n\n\n\n\n\n\n\n\n软件：API，application program interface.微信提现与充值，支付宝支付，银联支付接口。（鉴权码：token，key,appkey)接口包括：内部接口和外部接口内部接口：开发人员自己开发的对自身系统提供的接口外部接口：开发系统调用外部的 其他的接口。\n总结：接口就是软件提供给外部的一种服务，用于做数据传输服务。\n软件为什么需要接口因为接口能让内部的数据被外部进行修改。\n为什么需要做接口测试？\n现在很多系统是前后端分离，开发进度是不一样的，需要把一开始开发出来的接口进行测试。（不需要等系统全部开发完）。mock(模拟接口）前后端开发进度不一致是需要使用。\n基于安全考虑，前端有验证很容易绕过，直接请求接口，特别是：身份证信息，银行卡，金钱交易。\n测试推崇的是测试左移，测试尽早介入。\n\n接口测试的本质：就是测试接口能否正常的交互数据，权限控制以及异常场景。\n二、接口返回的数据格式和JSON详解\nJSON格式:三组数据**(80%)**\n\n\n\n\n\n\n\n\n{error_code:0,msg:”提现成功”,data:[]}error_code:错误码，0表示成功，msg：对错误码的中文说明data：真正返回的数据\n\n\n\njson 就是一种数据类型。\nJSON由两组数据组成： 1234567891011121314MAP对象，键值对,&#123;key:value,key:value&#125;数组：[value1，value2,value3]示例：&#123;\t&quot;people&quot;: [&#123;\t\t\t&quot;firstName&quot;: &quot;Brett&quot;,\t\t\t&quot;lastName&quot;: &quot;McLaughlin&quot;\t\t&#125;,\t\t&#123;\t\t\t&quot;firstName&quot;: &quot;Jason&quot;,\t\t\t&quot;lastName&quot;: &quot;Hunter&quot;\t\t&#125;\t]&#125;\n好用的JSON校验工具网站：www.bejson.com\n\n\n\n\n\n\n\n\n可以帮助校验json格式是否正确，比如符号中英接口的加密与编密功能\n\n\n\nHtml格式；\n12345678&lt;html&gt;\t&lt;title&gt;&lt;/title&gt;\t\t&lt;body&gt;\t\t&lt;error_code&gt;0&lt;/error_code&gt;\t\t...\t\t&lt;/body&gt;&lt;/html&gt;\n\nXML格式；\n1234&lt;?xml?version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&gt;\t&lt;error_code&gt;0&lt;/error_code&gt;\t...&lt;/xml&gt;\n\n三、接口测试协议1. webservice协议：接口地址：http:&#x2F;&#x2F;………………?wsdl\n1234http://192.168.3.1:8080/addUserhttp://192.168.3.1:8080/delUserhttp://192.168.3.1:8080/updUserhttp://192.168.3.1:8080/selUser\nsoap协议，携带wsdlrestful规则：get获取数据，post提交数据，put修改数据，delete删除数据\n1http://192.168.3.1:8080/user\t\t\t//根据请求方式的不一样来对数据做不同操作\n\n2. dubbo协议：接口地址以dubbo:&#x2F;&#x2F;……..\n\n\n\n\n\n\n\n\n\n适用于少量的数据传输，大并发。\n3. http协议：接口地址：http：&#x2F;&#x2F;    80%https &#x3D; http + ssl安全传输协议     端口：443http：端口80\n什么是http协议？http是超文本传输协议，主要用于浏览器和服务器之间交互数据，交互有两个部分：请求： get，post，delete响应：1XX信息，2XX成功，3XX重定向（不传值的跳转），4XX客户端错误，5XX服务器错误请求部分包含：\n请求行：请求方式，请求地址，协议GET http://www.baidu.com/ HTTP&#x2F;1.1\n请求头：User-Agent: PostmanRuntime&#x2F;7.32.3（客户端的用户&#x2F;代理）Accept: &#x2F;\t\t\t\t（客户端可以接收的数据格式）X-Request_With:(异步请求—带有局部刷新的带有此请求头)Postman-Token: 05535233-a98a-4e7d-89f1-3f76cbcfa5f7Host: www.baidu.com（**请求的地址**）Accept-Encoding: gzip, deflate, br（客户端可以接受的压缩方式）Connection: keep-alive\t（保持活跃的状态）Cookie: BDSVRTM&#x3D;0（请求所带的cookie信息）\n空一行请求正文\n响应的部分：响应行：协议 ，响应码，响应信息HTTP&#x2F;1.1 200 OK响应头：Connection: close（链接状态&#x2F;响应方式）Transfer-Encoding: chunkedBdpagetype: 1Bdqid: 0xec3aba61001f68baContent-Encoding: gzipContent-Security-Policy: frame-ancestors ‘self’ https://chat.baidu.com http://mirror-chat.baidu.com https://fj-chat.baidu.com https://hba-chat.baidu.com https://hbe-chat.baidu.com https://njjs-chat.baidu.com https://nj-chat.baidu.com https://hna-chat.baidu.com https://hnb-chat.baidu.com http://debug.baidu-int.com;Content-Type: text&#x2F;html; charset&#x3D;utf-8\t（响应内容的类型）Date: Mon, 10 Jul 2023 18:52:15 GMT（响应时间）P3p: CP&#x3D;” OTI DSP COR IVA OUR IND COM “P3p: CP&#x3D;” OTI DSP COR IVA OUR IND COM “Server: BWS&#x2F;1.1\t（服务器）Set-Cookie: （当浏览器第一次访问服务器时会响应一个set-Cookie给浏览器）BAIDUID&#x3D;38CC3D5FF00FE1D276A9A87D6B66FA25:FG&#x3D;1; expires&#x3D;Thu, 31-Dec-37 23:55:55 GMT; max-age&#x3D;2147483647; path&#x3D;&#x2F;; domain&#x3D;.baidu.com（响应）Set-Cookie: BIDUPSID&#x3D;38CC3D5FF00FE1D276A9A87D6B66FA25; expires&#x3D;Thu, 31-Dec-37 23:55:55 GMT; max-age&#x3D;2147483647; path&#x3D;&#x2F;; domain&#x3D;.baidu.comSet-Cookie: PSTM&#x3D;1689015135; expires&#x3D;Thu, 31-Dec-37 23:55:55 GMT; max-age&#x3D;2147483647; path&#x3D;&#x2F;; domain&#x3D;.baidu.comSet-Cookie: BAIDUID&#x3D;38CC3D5FF00FE1D22CE9CDFC03EA4184:FG&#x3D;1; max-age&#x3D;31536000; expires&#x3D;Tue, 09-Jul-24 18:52:15 GMT; domain&#x3D;.baidu.com; path&#x3D;&#x2F;; version&#x3D;1; comment&#x3D;bdSet-Cookie: BDSVRTM&#x3D;31; path&#x3D;&#x2F;Set-Cookie: BD_HOME&#x3D;1; path&#x3D;&#x2F;Set-Cookie: H_PS_PSSID&#x3D;36546_38643_38831_39027_39023_38942_38882_38958_38955_39009_39013_39037_38919_38972_38814_38639_26350_39041_39046; path&#x3D;&#x2F;; domain&#x3D;.baidu.comTraceid: 1689015135069700634617022122667376863418X-Ua-Compatible: IE&#x3D;Edge,chrome&#x3D;1空一行响应的内容\n四、企业接口测试的流程和方案？\n拿到api接口文档，熟悉接口的业务，接入地址，鉴权，入参，出参，错误码。\n接口计划和方案思路：正例：输入正常的入参，查看接口是否返回成功。反例： 鉴权反例：鉴权为空，鉴权码错误，鉴权码已过期… 参数反例：参数为空，单数类型异常，参数长度异常。                   错误码的覆盖。 其他场景：分页异常。\n编写用例和评审。\n执行接口测试。\n输出接口测试报告。\n\n五、接口测试工具以及Postman介绍接口测试工具：postman，jmeter，soupui，apipost,ffiddler,charles\nPostman简介是一款功能强大的网页调试与发送HTTP请求的Chrome插件，专为接口而生\n","slug":"软件测试_基础篇","date":"2021-12-30T05:49:00.000Z","categories_index":"软件测试","tags_index":"软件测试,接口测试","author_index":"kiyose408"},{"id":"e43f80fd110a34cfffcfbd2096485cd5","title":"codeblocks快捷键合集","content":"CodeBlocks常用操作快捷键编辑部分：\n\n\n\n\n\n\n\n\nCtrl + A：全选baiCtrl + C：复制Ctrl + X: 剪切Ctrl + V：粘贴Ctrl + Z：撤销Ctrl + S：保存Ctrl + Y &#x2F; Ctrl + Shift + Z:重做Ctrl+Shift+C：注释掉当前行或选中块Ctrl+Shift+X：解除注释Tab：缩进当前行或选中块Shift+Tab：减少缩进按住Ctrl，滚动鼠标滚轮，放大或缩小字体\n编译与运行部分：\n\n\n\n\n\n\n\n\nCtrl + F9：编译Ctrl + F10：运行上次成功编译后的程序Ctrl +　Shift + F9:编译当前文件F9：编译并运行当前代码Ctrl + C：终止正在运行的程序Ctrl + Z：终止输入\n调试部分：\n\n\n\n\n\n\n\n\nF5：在当前光标所在行设置断点F4：运行到光标所在行F8：开始调试Shift + F8：停止调试F7：下一行代码Shift + F7：进入下一行代码\n界面部分：\n\n\n\n\n\n\n\n\nShift + F2：左侧导航栏\n","slug":"Codeblocks快捷键合集","date":"2021-10-30T05:49:00.000Z","categories_index":"实用教程","tags_index":"快捷操作,Codeblocks","author_index":"kiyose408"},{"id":"c75c8a86af519c1ac4f83901b186d8f4","title":"codeblocks控制台输出中文乱码解决办法","content":"在使用codeblocks进行编程的时候我发现控制台输出会出现中文乱码，就像这样： 所以很快我就问了老师，解决步骤如下：一：如果源码是用codeblock编写的,打开Setting-&gt;Editor-&gt;General Setting-&gt;Ecoding Setting设置如图: 二：解决编译器读取源文件编码，设置执行输出编码这里使用GCC编译器，打开Setting-&gt;Compiler-&gt;Global compiler setting-&gt;Compiler setting -&gt; other compiler options; 在其中添加：\n\n\n\n\n\n\n\n\n\n-finput-charset&#x3D;UTF-8-fexec-charset&#x3D;GBK\n 如图： 我的问题经过这两步操作之后再重新编译一遍代码就能正常运行啦。\n\n","slug":"codeblocks输出中文乱码解决办法","date":"2021-10-12T05:49:00.000Z","categories_index":"实用教程","tags_index":"Codeblocks,Bug修复","author_index":"kiyose408"},{"id":"b9ce9a50f730e8a78430a9c829d0903c","title":"文件操作","content":"文件操作程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放\n通过文件可以将数据持久化\nC++中对文件操作需要包含头文件 &#x3D;&#x3D;&lt; fstream &gt;&#x3D;&#x3D;\n文件类型分为两种：\n\n文本文件     -  文件以文本的ASCII码形式存储在计算机中\n二进制文件 -  文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们\n\n操作文件的三大类:\n\nofstream：写操作\nifstream： 读操作\nfstream ： 读写操作\n\n文本文件写文件   写文件步骤如下：\n\n包含头文件   \n  #include &lt;fstream&gt;\n\n创建流对象  \nofstream ofs;\n\n打开文件\nofs.open(“文件路径”,打开方式);\n\n写数据\nofs &lt;&lt; “写入的数据”;\n\n关闭文件\nofs.close();\n​\n\n\n文件打开方式：\n\n\n\n打开方式\n解释\n\n\n\nios::in\n为读文件而打开文件\n\n\nios::out\n为写文件而打开文件\n\n\nios::ate\n初始位置：文件尾\n\n\nios::app\n追加方式写文件\n\n\nios::trunc\n如果文件存在先删除，再创建\n\n\nios::binary\n二进制方式\n\n\n注意： 文件打开方式可以配合使用，利用|操作符\n例如：用二进制方式写文件 ios::binary |  ios:: out\n示例：\n12345678910111213141516171819202122#include &lt;fstream&gt;void test01()&#123;\tofstream ofs;\tofs.open(&quot;test.txt&quot;, ios::out);\tofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl;\tofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl;\tofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl;\tofs.close();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n文件操作必须包含头文件 fstream\n读文件可以利用 ofstream  ，或者fstream类\n打开文件时候需要指定操作文件的路径，以及打开方式\n利用&lt;&lt;可以向文件中写数据\n操作完毕，要关闭文件\n\n读文件读文件与写文件步骤相似，但是读取方式相对于比较多\n读文件步骤如下：\n\n包含头文件   \n  #include &lt;fstream&gt;\n\n创建流对象  \nifstream ifs;\n\n打开文件并判断文件是否打开成功\nifs.open(“文件路径”,打开方式);\n\n读数据\n四种方式读取\n\n关闭文件\nifs.close();\n\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;fstream&gt;#include &lt;string&gt;void test01()&#123;\tifstream ifs;\tifs.open(&quot;test.txt&quot;, ios::in);\tif (!ifs.is_open())\t&#123;\t\tcout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;\t\treturn;\t&#125;\t//第一种方式\t//char buf[1024] = &#123; 0 &#125;;\t//while (ifs &gt;&gt; buf)\t//&#123;\t//\tcout &lt;&lt; buf &lt;&lt; endl;\t//&#125;\t//第二种\t//char buf[1024] = &#123; 0 &#125;;\t//while (ifs.getline(buf,sizeof(buf)))\t//&#123;\t//\tcout &lt;&lt; buf &lt;&lt; endl;\t//&#125;\t//第三种\t//string buf;\t//while (getline(ifs, buf))\t//&#123;\t//\tcout &lt;&lt; buf &lt;&lt; endl;\t//&#125;\tchar c;\twhile ((c = ifs.get()) != EOF)\t&#123;\t\tcout &lt;&lt; c;\t&#125;\tifs.close();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n读文件可以利用 ifstream  ，或者fstream类\n利用is_open函数可以判断文件是否打开成功\nclose 关闭文件\n\n二进制文件以二进制的方式对文件进行读写操作\n打开方式要指定为 &#x3D;&#x3D;ios::binary&#x3D;&#x3D;\n写文件二进制方式写文件主要利用流对象调用成员函数write\n函数原型 ：ostream&amp; write(const char * buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738#include &lt;fstream&gt;#include &lt;string&gt;class Person&#123;public:\tchar m_Name[64];\tint m_Age;&#125;;//二进制文件  写文件void test01()&#123;\t//1、包含头文件\t//2、创建输出流对象\tofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary);\t\t//3、打开文件\t//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);\tPerson p = &#123;&quot;张三&quot;  , 18&#125;;\t//4、写文件\tofs.write((const char *)&amp;p, sizeof(p));\t//5、关闭文件\tofs.close();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n文件输出流对象 可以通过write函数，以二进制方式写数据\n\n读文件二进制方式读文件主要利用流对象调用成员函数read\n函数原型：istream&amp; read(char *buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n示例：\n1234567891011121314151617181920212223242526272829303132#include &lt;fstream&gt;#include &lt;string&gt;class Person&#123;public:\tchar m_Name[64];\tint m_Age;&#125;;void test01()&#123;\tifstream ifs(&quot;person.txt&quot;, ios::in | ios::binary);\tif (!ifs.is_open())\t&#123;\t\tcout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;\t&#125;\tPerson p;\tifs.read((char *)&amp;p, sizeof(p));\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n文件输入流对象 可以通过read函数，以二进制方式读数据\n\n","slug":"文件操作","date":"2021-10-05T12:49:00.000Z","categories_index":"C++高级","tags_index":"C++,文件操作,fstream,文本文件,二进制文件","author_index":"kiyose408"},{"id":"fd628f085eaaaa86503f2ec06df00bd2","title":"python随笔一","content":"前言  本文材料均来自于MOOC的免费课程Python程序设计（https://www.icourse163.org/course/BIT-268001）\n\n\n\n\n\n\n\n\n\npython基础的随笔更多是偏向于我个人代码实现和讨论，所以对于知识点不会有一个比较输入的说明，&#x3D;&#x3D;知识点可能会在之后系列再做总结&#x3D;&#x3D;。如果后面总结知识点我大概率会手打，截图属实起不到加强记忆的效果，如果可以我会尽量做一个知识点目录（同参考课程进度）\n概述有这次的①包含有从0-3周课程的代码实例，也包括Python123里的作业部分实例代码，以及运行结果。总体描述方式就是类似下图 \n主体1.基本语法元素①实例：温度转换要求\n\n\n\n\n\n\n\n\n实现华摄氏度（F）与摄氏度（C）的转换自动根据最后的符号判断输入的是什么类型的温度计量并转换\n分析题设要求有对于两个单位之间的转换以及识别 所以会用到两者之间的转换公式。\n\n\n\n\n\n\n\n\n\n摄氏&#x3D;5&#x2F;9（°F-32）华氏°F&#x3D;℃×9&#x2F;5+32\n 对于单位的F和C的识别要通过最后一个字符的识别来进行判断。\n\n\n\n\n\n\n\n\n\n输入设定变量[-1]\n代码部分123456789TempStr = input(&quot;请输入带有符号的温度值: &quot;)if TempStr[-1] in [&#x27;F&#x27;, &#x27;f&#x27;]:    C = (eval(TempStr[0:-1]) - 32)/1.8    print(&quot;转换后的温度是&#123;:.2f&#125;C&quot;.format(C))elif TempStr[-1] in [&#x27;C&#x27;, &#x27;c&#x27;]:    F = 1.8*eval(TempStr[0:-1]) + 32    print(&quot;转换后的温度是&#123;:.2f&#125;F&quot;.format(F))else:    print(&quot;输入格式错误&quot;)\n运行结果 摄氏度转华氏度\n12请输入带有符号的温度值: 12C转换后的温度是53.60F\n\n 华氏度转摄氏度\n12请输入带有符号的温度值: 53F转换后的温度是11.67C\n②作业：Hello World的条件输出要求\n\n\n\n\n\n\n\n\n获得用户输入的一个整数，参考该整数值，打印输出”Hello World”，要求：‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬ &#x3D;&#x3D;如果输入值是0，直接输出”Hello World”‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬&#x3D;&#x3D;&#x3D;&#x3D;如果输入值大于0，以两个字符一行方式输出”Hello World”（空格也是字符）‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬&#x3D;&#x3D;&#x3D;&#x3D;如果输入值小于0，以垂直方式输出”Hello World”&#x3D;&#x3D;\n分析 这里的要求就是条件判断决定走哪一条分支，一共三条，流程图如下：（UML建模的基础图，这里就不按照严格的画法和描述了）\n代码12345678n = eval(input())if n == 0:    print(&quot;Hello World&quot;)elif n &gt; 0:    print(&quot;He\\nll\\no \\nWo\\nrl\\nd&quot;)else:    for c in &quot;Hello World&quot;:        print(c)\n\n运行结果输入&gt;0，每两个字符进行一次换行\n123456789101Hello World进程已结束,退出代码0\n\n输入0，直接输出\n12340Hello World进程已结束,退出代码0\n输入&lt;0,垂直输出\n1234567891011121314-1Hello World进程已结束,退出代码0\n③作业：数值运算要求\n\n\n\n\n\n\n\n\n获得用户输入的一个字符串，格式如下：‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬M OP N‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬其中，M和N是任何数字，OP代表一种操作，表示为如下四种：+, -, *, &#x2F;（加减乘除）‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬根据OP，输出M OP N的运算结果，统一保存小数点后2位。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬注意：&#x3D;&#x3D;M和OP、OP和N之间可以存在多个空格，不考虑输入错误情况。&#x3D;&#x3D;\n 示例：\n\n\n\n输入\n输出\n\n\n\n10+100\n110.00\n\n\n1&#x2F;20\n0.05\n\n\n分析 简单的计算 保留小数点后两位\n\n\n\n\n\n\n\n\n\n{:.2f}\n代码12a=input()print(&quot;&#123;:.2f&#125;&quot;.format(eval(a)))\n\n运行结果123410+100110.00进程已结束,退出代码0\n\n12341/200.05进程已结束,退出代码0\n2.基本图形绘制①实例：蟒蛇绘制要求 绘制一条蟒蛇\n分析  利用Python的turtle库进行绘图\n\n\n\n\n\n\n\n\n\n准备工作：需要下载turtle库步骤（win10）：①win+r②输入cmd，进入命令行界面③输入 pip install turtle后面需要什么库就把后面的换成库的名字，如果下载速度很慢可以从国内的镜像下载&#x3D;&#x3D;临时使用：&#x3D;&#x3D;&#x3D;&#x3D;可以在使用pip的时候加参数-i https://pypi.tuna.tsinghua.edu.cn/simple==例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 库名，这样就会从清华这边的镜像去安装库。 &#x3D;&#x3D;永久修改办法：&#x3D;&#x3D;windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini，内容如下    &#x3D;&#x3D;[global]    index-url &#x3D; https://pypi.tuna.tsinghua.edu.cn/simple== 这个方法也是来自于csdn的帖子解决pip install 速度很慢的方法\n代码1234567891011121314151617import turtleturtle.setup(650,350,200,200)turtle.penup()turtle.fd(-250)turtle.pendown()turtle.pensize(25)turtle.pencolor(&quot;purple&quot;)turtle.seth(-40)for i in range(4):    turtle.circle(40,80)    turtle.circle(-40,80)turtle.circle(40,80/2)turtle.fd(40)turtle.circle(16,180)turtle.fd(40*2/3)turtle.done()\n\n运行结果这个过程是动态的而不是一瞬间呈现结果，展现给我们的是绘制的全过程\n②作业：turtle八边形绘制要求 使用turtle库，绘制一个八边形。 八边形效果如下：‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬\n‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫\n分析这种规范图形需要计算转角度数就行了，这里就是360&#x2F;8&#x3D;45 旋转8次45度，每次行进一定距离，这里设定100\n代码12345import turtle as tt.pensize(2)for i in range(8):    t.fd(100)    t.left(45)\n\n运行结果\n③作业：turtle绘制8角形要求使用turtle库，绘制一个八角图形。\n代码12345import turtle as tt.pensize(2)for i in range(8):    t.fd(150)    t.left(135)\n计算循环和角度的乘积，应该为360的整数倍\n运行结果\n3.基本数据类型①实例：天天向上的力量-工作日的努力问题\n工作日模式要努力到什么水平，才能和每天努力1%一样？\nA君：一年365天，每天进步1%，不停歇\nB君：一年365天，每周工作5天休息2天，休息日下降1%，要多努力呢？\n\n分析 我们可以先计算A君最后的效果  老师给出的方法是利用计算机的计算力直接试错\n代码 试错方式的代码：\n123456789101112def dayUP(df):    dayup = 1    for i in range(365):       if i % 7 in [6,0]:           dayup = dayup*(1 - 0.01)       else:           dayup = dayup*(1 + df)    return dayupdayfactor = 0.01while dayUP(dayfactor) &lt; 37.78:    dayfactor += 0.001print(&quot;工作日的努力参数是：&#123;:.3f&#125; &quot;.format(dayfactor))\n\n运行结果123工作日的努力参数是：0.019 进程已结束,退出代码0\n\n②实例：文本进度条-简答的开始要求 进行简单的进度条模拟，不进行动态刷新采用向下推进\n代码12345678910import timescale = 10print(&quot;------执行开始------&quot;)for i in range(scale+1):    a = &#x27;*&#x27; * i    b = &#x27;.&#x27; * (scale - i)    c = (i/scale)*100    print(&quot;&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&quot;.format(c,a,b))    time.sleep(0.1)print(&quot;------执行结束------&quot;)\n\n运行结果123456789101112131415------执行开始------ 0 %[-&gt;..........]10 %[*-&gt;.........]20 %[**-&gt;........]30 %[***-&gt;.......]40 %[****-&gt;......]50 %[*****-&gt;.....]60 %[******-&gt;....]70 %[*******-&gt;...]80 %[********-&gt;..]90 %[*********-&gt;.]100%[**********-&gt;]------执行结束------进程已结束,退出代码0\n\n③实例：文本进度条-完整版要求 动态刷新，只在该行进行系列刷新活动\n分析 基于简单版本需要都与一部分的文本进行覆盖操作\n代码123456789101112import timescale = 50print(&quot;执行开始&quot;.center(scale//2, &quot;-&quot;))start = time.perf_counter()for i in range(scale+1):    a = &#x27;*&#x27; * i    b = &#x27;.&#x27; * (scale - i)    c = (i/scale)*100    dur = time.perf_counter() - start    print(&quot;\\r&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s&quot;.format(c,a,b,dur),end=&#x27;&#x27;)    time.sleep(0.1)print(&quot;\\n&quot;+&quot;执行结束&quot;.center(scale//2,&#x27;-&#x27;))\n\n运行结果12345-----------执行开始----------100%[**************************************************-&gt;]5.00s-----------执行结束----------进程已结束,退出代码0\n④作业：平方根格式化要求\n\n\n\n\n\n\n\n\n获得用户输入的一个整数a，计算a的平方根，保留小数点后3位，并打印输出。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬输出结果采用宽度30个字符、右对齐输出、多余字符采用加号(+)填充。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬如果结果超过30个字符，则以结果宽度为准。\n分析 本题需理解格式化输出的方法。\n&#x3D;&#x3D;注意：如果平凡根后产生一个复数，由于复数的实部和虚部都是浮点数，.3f可以将实部和虚部分别取三位小数。&#x3D;&#x3D;\n代码12a = eval(input())print(&quot;&#123;:+&gt;30.3f&#125;&quot;.format(pow(a, 0.5)))\n\n运行结果1234232++++++++++++++++++++++++15.232进程已结束,退出代码0\n\n12345-232+++++++++++++++++0.000+15.232j进程已结束,退出代码0\n⑤作业：字符串分段组合要求获得输入的一个字符串s，以字符减号(-)分割s，将其中首尾两段用加号(+)组合后输出。\n\n\n\n输入\n输出\n\n\n\nAlice-Bob-Charis-David-Eric-Flurry\nAlice+Flurry\n\n\n分析s.split(k)以k为标记分割s，产生一个列表。本题需求就是掌握split（）的用法。\n代码123s = input()ls = s.split(&quot;-&quot;)print(&quot;&#123;&#125;+&#123;&#125;&quot;.format(ls[0], ls[-1]))\n运行结果1234Alice-Bob-Charis-David-Eric-FlurryAlice+Flurry进程已结束,退出代码0\n\n后注 这三章的代码难度不是很，也不是很长，但是对于部分函数的使用还是有着一定要求的，或许不使用函数也有写发但是使用函数毫无疑问会大大降低代码量。但是有时候我也很疑惑，因为以前也曾听过代码的使用月是使用一些函数的时候可能会使得这程序耗费的时间增加，以及程序出错之后不知道原因在哪。这很致命。比如再分割字符串的实例里面的&#x3D;&#x3D;split()函数&#x3D;&#x3D;，我查阅了它的源码。 如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public String[] split(String regex, int limit) &#123;        /* fastpath if the regex is a         (1)one-char String and this character is not one of the            RegEx&#x27;s meta characters &quot;.$|()[&#123;^?*+\\\\&quot;, or         (2)two-char String and the first char is the backslash and            the second is not the ascii digit or ascii letter.         */        char ch = 0;        if (((regex.value.length == 1 &amp;&amp;             &quot;.$|()[&#123;^?*+\\\\&quot;.indexOf(ch = regex.charAt(0)) == -1) ||             (regex.length() == 2 &amp;&amp;              regex.charAt(0) == &#x27;\\\\&#x27; &amp;&amp;              (((ch = regex.charAt(1))-&#x27;0&#x27;)|(&#x27;9&#x27;-ch)) &lt; 0 &amp;&amp;              ((ch-&#x27;a&#x27;)|(&#x27;z&#x27;-ch)) &lt; 0 &amp;&amp;              ((ch-&#x27;A&#x27;)|(&#x27;Z&#x27;-ch)) &lt; 0)) &amp;&amp;            (ch &lt; Character.MIN_HIGH_SURROGATE ||             ch &gt; Character.MAX_LOW_SURROGATE))        &#123;            int off = 0;            int next = 0;            boolean limited = limit &gt; 0;            ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();            while ((next = indexOf(ch, off)) != -1) &#123;                if (!limited || list.size() &lt; limit - 1) &#123;                    list.add(substring(off, next));                    off = next + 1;                &#125; else &#123;    // last one                    //assert (list.size() == limit - 1);                    list.add(substring(off, value.length));                    off = value.length;                    break;                &#125;            &#125;            // If no match was found, return this            if (off == 0)                return new String[]&#123;this&#125;;             // Add remaining segment            if (!limited || list.size() &lt; limit)                list.add(substring(off, value.length));             // Construct result            int resultSize = list.size();            if (limit == 0) &#123;                while (resultSize &gt; 0 &amp;&amp; list.get(resultSize - 1).length() == 0) &#123;                    resultSize--;                &#125;            &#125;            String[] result = new String[resultSize];            return list.subList(0, resultSize).toArray(result);        &#125;        return Pattern.compile(regex).split(this, limit);    &#125;\n 可以说对我现在而言阅读起来依然有不明白的地方，日后还是需要再多看看，输入理解。 如果文章对你有所帮助，可以加入收藏做为小笔记哦。若文中有问题也可以评论指出，方便小的加以修改。感谢！\n","slug":"Python随笔","date":"2021-10-03T05:49:00.000Z","categories_index":"Python","tags_index":"Python基础,图形绘制","author_index":"kiyose408"},{"id":"f7867369ce6c59c22c6335141c563f0b","title":"类和对象","content":"总览C++ 面向对象的三大特性： &#x3D;&#x3D;封装，继承，多态&#x3D;&#x3D;\nC++认为 **&#x3D;&#x3D;万事万物都皆为对象&#x3D;&#x3D;**，对象上有其属性和行为\n封装封装的意义封装是C++面向对象的三大特征之一封装的意义：\n\n将属性和行为作为一个整体，表现生活中的事物\n将属性和行为加以权限控制\n\n封装意义一：    在设计类的时候，属性和行为写在一起，表现事物语法  \n\n\n\n\n\n\n\n\n\nclass 类名{  访问权限： 属性&#x2F;行为 }；\n示例1：设计一个圆类，求圆的周长\n123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;//圆周率const double PI = 3.14;//设计一个圆类，求圆的周长//圆求周长的公式:2Pi * 半径//class代表设计一个类，类后面紧跟着的就是类名称class Circle&#123;\t//访问权限\t//公共权限public:\t//属性\t//半径\tint m_r;\t//行为\t//获取圆的周长\tdouble calculateZC()\t&#123;\t\treturn  2 * PI * m_r;\t&#125;&#125;;int main()&#123;\t//通过圆类创建具体的圆（对象）\t//实例化  (通过一个类来创建一个对象的过程）\tCircle c1;\t//给圆对象的属性进行赋值\tc1.m_r = 10;\tcout &lt;&lt; &quot;圆的周长为&quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n笔记：示例2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号。\n12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;//设计一个学生类，具有姓名和学号的属性，可以给姓名和学号赋值，可以显示学生的姓名与学号class Student&#123;public://访问权限\t//类中的属性与行为 我们统一称为 成员\t// 属性  成员属性 成员变量\t// 行为  成员函数 成员方法\t//姓名与学号属性\tstring s_name;\tstring s_id;\t//赋值行为\tvoid add(string name, string id)//设计是绑定一起输入，也可以分开设计为两个方法\t&#123;\t\ts_name = name;\t\ts_id = id;\t&#125;\t//输出行为\tvoid print_message()\t&#123;\t\tcout &lt;&lt; &quot;学号为 &quot; &lt;&lt; s_id &lt;&lt; &quot; 的学生姓名是：&quot; &lt;&lt; s_name &lt;&lt; endl;\t&#125;&#125;;int main()&#123;\tStudent s1;\ts1.add(&quot;json&quot;, &quot;0001&quot;);\ts1.print_message();&#125;\n笔记：封装的意义二：类在设计时，可以把属性和行为放在不同的权限下，加以控制访问权限有三种：\n\npublic 公共权限\nprotected 保护权限\nprivate 私有权限\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;//访问权限//三种//公共权限 public\t\t\t成员 类内可以访问 类外可以访问//保护权限 protected\t\t成员 类内可以访问 类外不可以访问 子类可以访问父类的保护权限成员//私有权限 private\t\t成员 类内可以访问 类外不可以访问 子类不可以访问父类的私有权限成员class Person&#123;public:\t//公共权限\tstring m_Name;//姓名protected:\t//保护权限\tstring m_Car;//汽车private:\t//私有权限\tint m_Password;//银行卡密码public:\tvoid func()\t&#123;\t\tm_Name = &quot;张三&quot;;\t\tm_Car = &quot;拖拉机&quot;;\t\tm_Password = 123456;\t&#125;&#125;;int main()&#123;\t//实例化具体对象\tPerson p1;\tp1.m_Name = &quot;李四&quot;;\t//p1.m_Car = &quot;奔驰&quot;;//保护权限内容是无法在类外访问到\t//p1.m_Password = 12345; //私有权限内容在类外也是无法访问的\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n笔记：\nstruct和class的区别在C++中 struct和class唯一的区别就在于 默认的访问权限不同\n区别：\n\nstruct 默认权限为公共\nclass   默认权限为私有\n\n12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;class C1&#123;\tint m_A;//默认权限  是私有&#125;;struct C2&#123;\tint m_A;//默认权限 是公共&#125;;int main()&#123;\t//struct和class区别\t// struct 默认权限是 公共 public\t//class 默认权限是 私有 private\tC1 c1;\t//c1.m_A = 100;//class默认私有权限类外不可访问\tC2 c2;\tc2.m_A = 100;//struct默认公共权限，类外也可以访问\treturn 0;\tsystem(&quot;pause&quot;);&#125;\n\n\n\n\n\n成员属性设置为私有 优点1:将所有成员属性设置为私有，可以自己控制读写权限\n 优点2:对于写权限，我们可以检测数据的有效性\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Person &#123;public:\t//姓名设置可读可写\tvoid setName(string name) &#123;\t\tm_Name = name;\t&#125;\tstring getName()\t&#123;\t\treturn m_Name;\t&#125;\t//获取年龄 \tint getAge() &#123;\t\treturn m_Age;\t&#125;\t//设置年龄\tvoid setAge(int age) &#123;\t\tif (age &lt; 0 || age &gt; 150) &#123;\t\t\tcout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl;\t\t\treturn;\t\t&#125;\t\tm_Age = age;\t&#125;\t//情人设置为只写\tvoid setLover(string lover) &#123;\t\tm_Lover = lover;\t&#125;private:\tstring m_Name; //可读可写  姓名\t\tint m_Age; //只读  年龄\tstring m_Lover; //只写  情人&#125;;int main() &#123;\tPerson p;\t//姓名设置\tp.setName(&quot;张三&quot;);\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl;\t//年龄设置\tp.setAge(50);\tcout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl;\t//情人设置\tp.setLover(&quot;苍&quot;);\t//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n练习案例1：设计立方体类\n设计立方体类(Cube)\n求出立方体的面积和体积\n分别用全局函数和成员函数判断两个立方体是否相等。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;iostream&gt;using namespace std;//立方体类设计//1、创建立方体类//2、设计属性//3、设计行为 获取立方体面积与体积//4、分别利用全局函数和成员函数 判断两个立方体是否相等class Cube&#123;public:\t//设置与获取长宽高\tvoid setL(int l)\t&#123;\t\tm_L = l;\t&#125;\tint getL()\t&#123;\t\treturn m_L;\t&#125;\tvoid setW(int w)\t&#123;\t\tm_W = w;\t&#125;\tint getW()\t&#123;\t\treturn m_W;\t&#125;\tvoid setH(int h)\t&#123;\t\tm_H = h;\t&#125;\tint getH()\t&#123;\t\treturn m_H;\t&#125;\t//获取立方体面积\tint calculateS()\t&#123;\t\treturn (m_H * m_W + m_W * m_L + m_L * m_H) * 2;\t&#125;\t//获取立方体体积\tint calculateV()\t&#123;\t\treturn(m_H * m_L * m_W);\t&#125;\t//利用成员函数来判断两个立方体是否相等\tbool isSameByClass(Cube &amp;c)\t&#123;\t\tif (m_L == c.getL() &amp;&amp; m_H == c.getH() &amp;&amp; m_W == c.getW())\t\t\treturn true;\t\treturn false;\t&#125;private:\tint m_L;\tint m_W;\tint m_H;&#125;;//利用全局函数判断 两个立方体是否相等bool isSame(Cube&amp; c1, Cube&amp; c2)&#123;\tif (c1.getL() == c2.getL() &amp;&amp; c1.getH() == c2.getH() &amp;&amp; c1.getW() == c2.getW())\t\treturn true;\treturn false;&#125;int main()&#123;\t//创建一个立方体对象\tCube c1;\tc1.setL(10);\tc1.setH(10);\tc1.setW(10);\t//\tcout &lt;&lt; &quot;c1的面积为：&quot; &lt;&lt; c1.calculateS() &lt;&lt; endl;\tcout &lt;&lt; &quot;c1的体积为：&quot; &lt;&lt; c1.calculateV() &lt;&lt; endl;\t//创建第二个立方体对象\tCube c2;\tc2.setL(10);\tc2.setH(10);\tc2.setW(10);\t//利用全局函数判断\tbool ret = isSame(c1, c2);\tif (ret) &#123;\t\tcout &lt;&lt; &quot;c1 和c2 是相等的 &quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;c1 和 c2 不相等 &quot; &lt;&lt; endl;\t&#125;\t//利用成员函数判断\tbool ret1 = c1.isSameByClass(c2);\tif (ret1) &#123;\t\tcout &lt;&lt; &quot;成员函数判断：c1 和c2 是相等的 &quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;成员函数判断：c1 和 c2 不相等 &quot; &lt;&lt; endl;\t&#125;\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n练习案例2：点和圆的关系\n设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。\n对象的初始化和清理\n生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全\nC++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。\n\n1. 构造函数和析构函数对象的初始化和清理也是两个非常重要的安全问题\n​\t一个对象或者变量没有初始状态，对其使用后果是未知\n​\t同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题\nc++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。\n对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供\n&#x3D;&#x3D;编译器提供的构造函数和析构函数是空实现。&#x3D;&#x3D;\n\n构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。\n析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。\n\n构造函数语法：类名()&#123;&#125;\n\n构造函数，没有返回值也不写void\n函数名称与类名相同\n&#x3D;&#x3D;构造函数可以有参数，因此可以发生重载&#x3D;&#x3D;\n程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次\n\n析构函数语法： ~类名()&#123;&#125;\n\n析构函数，没有返回值也不写void\n函数名称与类名相同,在名称前加上符号  ~\n&#x3D;&#x3D;析构函数不可以有参数，因此不可以发生重载&#x3D;&#x3D;\n程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次\n\n1234567891011121314151617181920212223242526272829class Person&#123;public:\t//构造函数\tPerson()\t&#123;\t\tcout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl;\t&#125;\t//析构函数\t~Person()\t&#123;\t\tcout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl;\t&#125;&#125;;void test01()&#123;\tPerson p;&#125;int main() &#123;\t\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n2. 构造函数的分类及调用两种分类方式：\n​\t按参数分为： 有参构造和无参构造\n​\t按类型分为： 普通构造和拷贝构造\n三种调用方式：\n​\t括号法\n​\t显示法\n​\t隐式转换法\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//1、构造函数分类// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数// 按照类型分类分为 普通构造和拷贝构造class Person &#123;public:\t//无参（默认）构造函数\tPerson() &#123;\t\tcout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\t&#125;\t//有参构造函数\tPerson(int a) &#123;\t\tage = a;\t\tcout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;\t&#125;\t//拷贝构造函数\tPerson(const Person&amp; p) &#123;\t\tage = p.age;\t\tcout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\t&#125;\t//析构函数\t~Person() &#123;\t\tcout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\t&#125;public:\tint age;&#125;;//2、构造函数的调用//调用无参构造函数void test01() &#123;\tPerson p; //调用无参构造函数&#125;//调用有参的构造函数void test02() &#123;\t//2.1  括号法，常用\tPerson p1(10);\t//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\t//Person p2();\t//2.2 显式法\tPerson p2 = Person(10); \tPerson p3 = Person(p2);\t//Person(10)单独写就是匿名对象  当前行结束之后，马上析构\t//2.3 隐式转换法\tPerson p4 = 10; // Person p4 = Person(10); \tPerson p5 = p4; // Person p5 = Person(p4); \t//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明\t//Person p5(p4);&#125;int main() &#123;\ttest01();\t//test02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n3. 拷贝构造函数调用时机C++中拷贝构造函数调用时机通常有三种情况\n\n使用一个已经创建完毕的对象来初始化一个新对象\n值传递的方式给函数参数传值\n以值方式返回局部对象\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Person &#123;public:\tPerson() &#123;\t\tcout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\t\tmAge = 0;\t&#125;\tPerson(int age) &#123;\t\tcout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;\t\tmAge = age;\t&#125;\tPerson(const Person&amp; p) &#123;\t\tcout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\t\tmAge = p.mAge;\t&#125;\t//析构函数在释放内存之前调用\t~Person() &#123;\t\tcout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\t&#125;public:\tint mAge;&#125;;//1. 使用一个已经创建完毕的对象来初始化一个新对象void test01() &#123;\tPerson man(100); //p对象已经创建完毕\tPerson newman(man); //调用拷贝构造函数\tPerson newman2 = man; //拷贝构造\t//Person newman3;\t//newman3 = man; //不是调用拷贝构造函数，赋值操作&#125;//2. 值传递的方式给函数参数传值//相当于Person p1 = p;void doWork(Person p1) &#123;&#125;void test02() &#123;\tPerson p; //无参构造函数\tdoWork(p);&#125;//3. 以值方式返回局部对象Person doWork2()&#123;\tPerson p1;\tcout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;\treturn p1;&#125;void test03()&#123;\tPerson p = doWork2();\tcout &lt;&lt; (int *)&amp;p &lt;&lt; endl;&#125;int main() &#123;\t//test01();\t//test02();\ttest03();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n4. 构造函数调用规则默认情况下，c++编译器至少给一个类添加3个函数\n1．默认构造函数(无参，函数体为空)\n2．默认析构函数(无参，函数体为空)\n3．默认拷贝构造函数，对属性进行值拷贝\n构造函数调用规则如下：\n\n如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造\n\n如果用户定义拷贝构造函数，c++不会再提供其他构造函数\n\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Person &#123;public:\t//无参（默认）构造函数\tPerson() &#123;\t\tcout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\t&#125;\t//有参构造函数\tPerson(int a) &#123;\t\tage = a;\t\tcout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;\t&#125;\t//拷贝构造函数\tPerson(const Person&amp; p) &#123;\t\tage = p.age;\t\tcout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\t&#125;\t//析构函数\t~Person() &#123;\t\tcout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\t&#125;public:\tint age;&#125;;void test01()&#123;\tPerson p1(18);\t//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作\tPerson p2(p1);\tcout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;void test02()&#123;\t//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造\tPerson p1; //此时如果用户自己没有提供默认构造，会出错\tPerson p2(10); //用户提供的有参\tPerson p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供\t//如果用户提供拷贝构造，编译器不会提供其他构造函数\tPerson p4; //此时如果用户自己没有提供默认构造，会出错\tPerson p5(10); //此时如果用户自己没有提供有参，会出错\tPerson p6(p5); //用户自己提供拷贝构造&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n5. 深拷贝与浅拷贝深浅拷贝是面试经典问题，也是常见的一个坑\n浅拷贝：简单的赋值拷贝操作\n深拷贝：在堆区重新申请空间，进行拷贝操作\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Person &#123;public:\t//无参（默认）构造函数\tPerson() &#123;\t\tcout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\t&#125;\t//有参构造函数\tPerson(int age ,int height) &#123;\t\t\t\tcout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;\t\tm_age = age;\t\tm_height = new int(height);\t\t\t&#125;\t//拷贝构造函数  \tPerson(const Person&amp; p) &#123;\t\tcout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\t\t//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题\t\tm_age = p.m_age;\t\tm_height = new int(*p.m_height);\t\t\t&#125;\t//析构函数\t~Person() &#123;\t\tcout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\t\tif (m_height != NULL)\t\t&#123;\t\t\tdelete m_height;\t\t&#125;\t&#125;public:\tint m_age;\tint* m_height;&#125;;void test01()&#123;\tPerson p1(18, 180);\tPerson p2(p1);\tcout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;\tcout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n\n\n\n\n\n\n总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题\n6. 初始化列表作用：\nC++提供了初始化列表语法，用来初始化属性\n语法：构造函数()：属性1(值1),属性2（值2）... &#123;&#125;\n示例：\n123456789101112131415161718192021222324252627282930313233class Person &#123;public:\t////传统方式初始化\t//Person(int a, int b, int c) &#123;\t//\tm_A = a;\t//\tm_B = b;\t//\tm_C = c;\t//&#125;\t//初始化列表方式初始化\tPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) &#123;&#125;\tvoid PrintPerson() &#123;\t\tcout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl;\t\tcout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl;\t\tcout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl;\t&#125;private:\tint m_A;\tint m_B;\tint m_C;&#125;;int main() &#123;\tPerson p(1, 2, 3);\tp.PrintPerson();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n7. 类对象作为类成员C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员\n例如：\n12345class A &#123;&#125;class B&#123;    A a；&#125;\n\n\n\nB类中有对象A作为成员，A为对象成员\n那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Phone&#123;public:\tPhone(string name)\t&#123;\t\tm_PhoneName = name;\t\tcout &lt;&lt; &quot;Phone构造&quot; &lt;&lt; endl;\t&#125;\t~Phone()\t&#123;\t\tcout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl;\t&#125;\tstring m_PhoneName;&#125;;class Person&#123;public:\t//初始化列表可以告诉编译器调用哪一个构造函数\tPerson(string name, string pName) :m_Name(name), m_Phone(pName)\t&#123;\t\tcout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl;\t&#125;\t~Person()\t&#123;\t\tcout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl;\t&#125;\tvoid playGame()\t&#123;\t\tcout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl;\t&#125;\tstring m_Name;\tPhone m_Phone;&#125;;void test01()&#123;\t//当类中成员是其他类对象时，我们称该成员为 对象成员\t//构造的顺序是 ：先调用对象成员的构造，再调用本类构造\t//析构顺序与构造相反\tPerson p(&quot;张三&quot; , &quot;苹果X&quot;);\tp.playGame();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n8. 静态成员静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员\n静态成员分为：\n\n静态成员变量\n所有对象共享同一份数据\n在编译阶段分配内存\n类内声明，类外初始化\n\n\n静态成员函数\n所有对象共享同一个函数\n静态成员函数只能访问静态成员变量\n\n\n\n示例1 ：静态成员变量\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Person&#123;\tpublic:\tstatic int m_A; //静态成员变量\t//静态成员变量特点：\t//1 在编译阶段分配内存\t//2 类内声明，类外初始化\t//3 所有对象共享同一份数据private:\tstatic int m_B; //静态成员变量也是有访问权限的&#125;;int Person::m_A = 10;int Person::m_B = 10;void test01()&#123;\t//静态成员变量两种访问方式\t//1、通过对象\tPerson p1;\tp1.m_A = 100;\tcout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl;\tPerson p2;\tp2.m_A = 200;\tcout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; //共享同一份数据\tcout &lt;&lt; &quot;p2.m_A = &quot; &lt;&lt; p2.m_A &lt;&lt; endl;\t//2、通过类名\tcout &lt;&lt; &quot;m_A = &quot; &lt;&lt; Person::m_A &lt;&lt; endl;\t//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n示例2：静态成员函数\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Person&#123;public:\t//静态成员函数特点：\t//1 程序共享一个函数\t//2 静态成员函数只能访问静态成员变量\t\tstatic void func()\t&#123;\t\tcout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;\t\tm_A = 100;\t\t//m_B = 100; //错误，不可以访问非静态成员变量\t&#125;\tstatic int m_A; //静态成员变量\tint m_B; // private:\t//静态成员函数也是有访问权限的\tstatic void func2()\t&#123;\t\tcout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl;\t&#125;&#125;;int Person::m_A = 10;void test01()&#123;\t//静态成员变量两种访问方式\t//1、通过对象\tPerson p1;\tp1.func();\t//2、通过类名\tPerson::func();\t//Person::func2(); //私有权限访问不到&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\nC++对象模型和this指针成员变量和成员函数分开存储在C++中，类内的成员变量和成员函数分开存储\n只有非静态成员变量才属于类的对象上\n1234567891011121314151617181920212223242526class Person &#123;public:\tPerson() &#123;\t\tmA = 0;\t&#125;\t//非静态成员变量占对象空间\tint mA;\t//静态成员变量不占对象空间\tstatic int mB; \t//函数也不占对象空间，所有函数共享一个函数实例\tvoid func() &#123;\t\tcout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl;\t&#125;\t//静态成员函数也不占对象空间\tstatic void sfunc() &#123;\t&#125;&#125;;int main() &#123;\tcout &lt;&lt; sizeof(Person) &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n\n\n\nthis指针概念通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的\n每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码\n那么问题是：这一块代码是如何区分那个对象调用自己的呢？\nc++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象\nthis指针是隐含每一个非静态成员函数内的一种指针\nthis指针不需要定义，直接使用即可\nthis指针的用途：\n\n当形参和成员变量同名时，可用this指针来区分\n在类的非静态成员函数中返回对象本身，可使用return *this\n\n1234567891011121314151617181920212223242526272829303132333435363738class Person&#123;public:\tPerson(int age)\t&#123;\t\t//1、当形参和成员变量同名时，可用this指针来区分\t\tthis-&gt;age = age;\t&#125;\tPerson&amp; PersonAddPerson(Person p)\t&#123;\t\tthis-&gt;age += p.age;\t\t//返回对象本身\t\treturn *this;\t&#125;\tint age;&#125;;void test01()&#123;\tPerson p1(10);\tcout &lt;&lt; &quot;p1.age = &quot; &lt;&lt; p1.age &lt;&lt; endl;\tPerson p2(10);\tp2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);\tcout &lt;&lt; &quot;p2.age = &quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n\n\n\n\n\n空指针访问成员函数C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针\n如果用到this指针，需要加以判断保证代码的健壮性\n示例：\n12345678910111213141516171819202122232425262728293031323334//空指针访问成员函数class Person &#123;public:\tvoid ShowClassName() &#123;\t\tcout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;\t&#125;\tvoid ShowPerson() &#123;\t\tif (this == NULL) &#123;\t\t\treturn;\t\t&#125;\t\tcout &lt;&lt; mAge &lt;&lt; endl;\t&#125;public:\tint mAge;&#125;;void test01()&#123;\tPerson * p = NULL;\tp-&gt;ShowClassName(); //空指针，可以调用成员函数\tp-&gt;ShowPerson();  //但是如果成员函数中用到了this指针，就不可以了&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n\n\n\n\n\nconst修饰成员函数常函数：\n\n成员函数后加const后我们称为这个函数为常函数\n常函数内不可以修改成员属性\n成员属性声明时加关键字mutable后，在常函数中依然可以修改\n\n常对象：\n\n声明对象前加const称该对象为常对象\n常对象只能调用常函数\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Person &#123;public:\tPerson() &#123;\t\tm_A = 0;\t\tm_B = 0;\t&#125;\t//this指针的本质是一个指针常量，指针的指向不可修改\t//如果想让指针指向的值也不可以修改，需要声明常函数\tvoid ShowPerson() const &#123;\t\t//const Type* const pointer;\t\t//this = NULL; //不能修改指针的指向 Person* const this;\t\t//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的\t\t//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量\t\tthis-&gt;m_B = 100;\t&#125;\tvoid MyFunc() const &#123;\t\t//mA = 10000;\t&#125;public:\tint m_A;\tmutable int m_B; //可修改 可变的&#125;;//const修饰对象  常对象void test01() &#123;\tconst Person person; //常量对象  \tcout &lt;&lt; person.m_A &lt;&lt; endl;\t//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问\tperson.m_B = 100; //但是常对象可以修改mutable修饰成员变量\t//常对象访问成员函数\tperson.MyFunc(); //常对象不能调用const的函数&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n友元生活中你的家有客厅(Public)，有你的卧室(Private)\n客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去\n但是呢，你也可以允许你的好闺蜜好基友进去。\n在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术\n友元的目的就是让一个函数或者类 访问另一个类中私有成员\n友元的关键字为  &#x3D;&#x3D;friend&#x3D;&#x3D;\n友元的三种实现\n\n全局函数做友元\n类做友元\n成员函数做友元\n\n全局函数做友元123456789101112131415161718192021222324252627282930313233343536373839404142class Building&#123;\t//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容\tfriend void goodGay(Building * building);public:\tBuilding()\t&#123;\t\tthis-&gt;m_SittingRoom = &quot;客厅&quot;;\t\tthis-&gt;m_BedRoom = &quot;卧室&quot;;\t&#125;public:\tstring m_SittingRoom; //客厅private:\tstring m_BedRoom; //卧室&#125;;void goodGay(Building * building)&#123;\tcout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\tcout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123;\tBuilding b;\tgoodGay(&amp;b);&#125;int main()&#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n类做友元12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Building;class goodGay&#123;public:\tgoodGay();\tvoid visit();private:\tBuilding *building;&#125;;class Building&#123;\t//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容\tfriend class goodGay;public:\tBuilding();public:\tstring m_SittingRoom; //客厅private:\tstring m_BedRoom;//卧室&#125;;Building::Building()&#123;\tthis-&gt;m_SittingRoom = &quot;客厅&quot;;\tthis-&gt;m_BedRoom = &quot;卧室&quot;;&#125;goodGay::goodGay()&#123;\tbuilding = new Building;&#125;void goodGay::visit()&#123;\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123;\tgoodGay gg;\tgg.visit();&#125;int main()&#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n\n成员函数做友元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Building;class goodGay&#123;public:\tgoodGay();\tvoid visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容\tvoid visit2(); private:\tBuilding *building;&#125;;class Building&#123;\t//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容\tfriend void goodGay::visit();public:\tBuilding();public:\tstring m_SittingRoom; //客厅private:\tstring m_BedRoom;//卧室&#125;;Building::Building()&#123;\tthis-&gt;m_SittingRoom = &quot;客厅&quot;;\tthis-&gt;m_BedRoom = &quot;卧室&quot;;&#125;goodGay::goodGay()&#123;\tbuilding = new Building;&#125;void goodGay::visit()&#123;\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void goodGay::visit2()&#123;\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\t//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123;\tgoodGay  gg;\tgg.visit();&#125;int main()&#123;    \ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n运算符重载运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型\n加号运算符重载作用：实现两个自定义数据类型相加的运算\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Person &#123;public:\tPerson() &#123;&#125;;\tPerson(int a, int b)\t&#123;\t\tthis-&gt;m_A = a;\t\tthis-&gt;m_B = b;\t&#125;\t//成员函数实现 + 号运算符重载\tPerson operator+(const Person&amp; p) &#123;\t\tPerson temp;\t\ttemp.m_A = this-&gt;m_A + p.m_A;\t\ttemp.m_B = this-&gt;m_B + p.m_B;\t\treturn temp;\t&#125;public:\tint m_A;\tint m_B;&#125;;//全局函数实现 + 号运算符重载//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;//\tPerson temp(0, 0);//\ttemp.m_A = p1.m_A + p2.m_A;//\ttemp.m_B = p1.m_B + p2.m_B;//\treturn temp;//&#125;//运算符重载 可以发生函数重载 Person operator+(const Person&amp; p2, int val)  &#123;\tPerson temp;\ttemp.m_A = p2.m_A + val;\ttemp.m_B = p2.m_B + val;\treturn temp;&#125;void test() &#123;\tPerson p1(10, 10);\tPerson p2(20, 20);\t//成员函数方式\tPerson p3 = p2 + p1;  //相当于 p2.operaor+(p1)\tcout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;\tPerson p4 = p3 + 10; //相当于 operator+(p3,10)\tcout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;&#125;int main() &#123;\ttest();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n总结1：对于内置的数据类型的表达式的的运算符是不可能改变的\n\n\n\n\n\n\n\n\n\n总结2：不要滥用运算符重载\n左移运算符重载作用：可以输出自定义数据类型\n123456789101112131415161718192021222324252627282930313233343536373839404142class Person &#123;\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);public:\tPerson(int a, int b)\t&#123;\t\tthis-&gt;m_A = a;\t\tthis-&gt;m_B = b;\t&#125;\t//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果\t//void operator&lt;&lt;(Person&amp; p)&#123;\t//&#125;private:\tint m_A;\tint m_B;&#125;;//全局函数实现左移重载//ostream对象只能有一个ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;\tout &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;\treturn out;&#125;void test() &#123;\tPerson p1(10, 20);\tcout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程&#125;int main() &#123;\ttest();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n总结：重载左移运算符配合友元可以实现输出自定义数据类型\n递增运算符重载作用： 通过重载递增运算符，实现自己的整型数据\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class MyInteger &#123;\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);public:\tMyInteger() &#123;\t\tm_Num = 0;\t&#125;\t//前置++\tMyInteger&amp; operator++() &#123;\t\t//先++\t\tm_Num++;\t\t//再返回\t\treturn *this;\t&#125;\t//后置++\tMyInteger operator++(int) &#123;\t\t//先返回\t\tMyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；\t\tm_Num++;\t\treturn temp;\t&#125;private:\tint m_Num;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;\tout &lt;&lt; myint.m_Num;\treturn out;&#125;//前置++ 先++ 再返回void test01() &#123;\tMyInteger myInt;\tcout &lt;&lt; ++myInt &lt;&lt; endl;\tcout &lt;&lt; myInt &lt;&lt; endl;&#125;//后置++ 先返回 再++void test02() &#123;\tMyInteger myInt;\tcout &lt;&lt; myInt++ &lt;&lt; endl;\tcout &lt;&lt; myInt &lt;&lt; endl;&#125;int main() &#123;\ttest01();\t//test02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n总结： 前置递增返回引用，后置递增返回值\n赋值运算符重载c++编译器至少给一个类添加4个函数\n\n默认构造函数(无参，函数体为空)\n默认析构函数(无参，函数体为空)\n默认拷贝构造函数，对属性进行值拷贝\n赋值运算符 operator&#x3D;, 对属性进行值拷贝\n\n如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Person&#123;public:\tPerson(int age)\t&#123;\t\t//将年龄数据开辟到堆区\t\tm_Age = new int(age);\t&#125;\t//重载赋值运算符 \tPerson&amp; operator=(Person &amp;p)\t&#123;\t\tif (m_Age != NULL)\t\t&#123;\t\t\tdelete m_Age;\t\t\tm_Age = NULL;\t\t&#125;\t\t//编译器提供的代码是浅拷贝\t\t//m_Age = p.m_Age;\t\t//提供深拷贝 解决浅拷贝的问题\t\tm_Age = new int(*p.m_Age);\t\t//返回自身\t\treturn *this;\t&#125;\t~Person()\t&#123;\t\tif (m_Age != NULL)\t\t&#123;\t\t\tdelete m_Age;\t\t\tm_Age = NULL;\t\t&#125;\t&#125;\t//年龄的指针\tint *m_Age;&#125;;void test01()&#123;\tPerson p1(18);\tPerson p2(20);\tPerson p3(30);\tp3 = p2 = p1; //赋值操作\tcout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;\tcout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;\tcout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;&#125;int main() &#123;\ttest01();\t//int a = 10;\t//int b = 20;\t//int c = 30;\t//c = b = a;\t//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\t//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\t//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n\n\n\n\n\n关系运算符重载作用：重载关系运算符，可以让两个自定义类型对象进行对比操作\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Person&#123;public:\tPerson(string name, int age)\t&#123;\t\tthis-&gt;m_Name = name;\t\tthis-&gt;m_Age = age;\t&#125;;\tbool operator==(Person &amp; p)\t&#123;\t\tif (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)\t\t&#123;\t\t\treturn true;\t\t&#125;\t\telse\t\t&#123;\t\t\treturn false;\t\t&#125;\t&#125;\tbool operator!=(Person &amp; p)\t&#123;\t\tif (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)\t\t&#123;\t\t\treturn false;\t\t&#125;\t\telse\t\t&#123;\t\t\treturn true;\t\t&#125;\t&#125;\tstring m_Name;\tint m_Age;&#125;;void test01()&#123;\t//int a = 0;\t//int b = 0;\tPerson a(&quot;孙悟空&quot;, 18);\tPerson b(&quot;孙悟空&quot;, 18);\tif (a == b)\t&#123;\t\tcout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\t&#125;\tif (a != b)\t&#123;\t\tcout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\t&#125;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n\n函数调用运算符重载\n函数调用运算符 ()  也可以重载\n由于重载后使用的方式非常像函数的调用，因此称为仿函数\n仿函数没有固定写法，非常灵活\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445class MyPrint&#123;public:\tvoid operator()(string text)\t&#123;\t\tcout &lt;&lt; text &lt;&lt; endl;\t&#125;&#125;;void test01()&#123;\t//重载的（）操作符 也称为仿函数\tMyPrint myFunc;\tmyFunc(&quot;hello world&quot;);&#125;class MyAdd&#123;public:\tint operator()(int v1, int v2)\t&#123;\t\treturn v1 + v2;\t&#125;&#125;;void test02()&#123;\tMyAdd add;\tint ret = add(10, 10);\tcout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl;\t//匿名对象调用  \tcout &lt;&lt; &quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;&#125;int main() &#123;\ttest01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n继承继承是面向对象三大特性之一\n有些类与类之间存在特殊的关系，例如下图中：\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lGZKE7ee-1691982898272)(assets&#x2F;1544861202252.png)]\n我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。\n这个时候我们就可以考虑利用继承的技术，减少重复代码\n继承的基本语法例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同\n接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处\n普通实现：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//Java页面class Java &#123;public:\tvoid header()\t&#123;\t\tcout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\t&#125;\tvoid footer()\t&#123;\t\tcout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\t&#125;\tvoid left()\t&#123;\t\tcout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\t&#125;\tvoid content()\t&#123;\t\tcout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;\t&#125;&#125;;//Python页面class Python&#123;public:\tvoid header()\t&#123;\t\tcout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\t&#125;\tvoid footer()\t&#123;\t\tcout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\t&#125;\tvoid left()\t&#123;\t\tcout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\t&#125;\tvoid content()\t&#123;\t\tcout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;\t&#125;&#125;;//C++页面class CPP &#123;public:\tvoid header()\t&#123;\t\tcout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\t&#125;\tvoid footer()\t&#123;\t\tcout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\t&#125;\tvoid left()\t&#123;\t\tcout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\t&#125;\tvoid content()\t&#123;\t\tcout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;\t&#125;&#125;;void test01()&#123;\t//Java页面\tcout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;\tJava ja;\tja.header();\tja.footer();\tja.left();\tja.content();\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\t//Python页面\tcout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\tPython py;\tpy.header();\tpy.footer();\tpy.left();\tpy.content();\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\t//C++页面\tcout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\tCPP cp;\tcp.header();\tcp.footer();\tcp.left();\tcp.content();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n继承实现：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//公共页面class BasePage&#123;public:\tvoid header()\t&#123;\t\tcout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\t&#125;\tvoid footer()\t&#123;\t\tcout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\t&#125;\tvoid left()\t&#123;\t\tcout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\t&#125;&#125;;//Java页面class Java : public BasePage&#123;public:\tvoid content()\t&#123;\t\tcout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;\t&#125;&#125;;//Python页面class Python : public BasePage&#123;public:\tvoid content()\t&#123;\t\tcout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;\t&#125;&#125;;//C++页面class CPP : public BasePage&#123;public:\tvoid content()\t&#123;\t\tcout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;\t&#125;&#125;;void test01()&#123;\t//Java页面\tcout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;\tJava ja;\tja.header();\tja.footer();\tja.left();\tja.content();\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\t//Python页面\tcout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\tPython py;\tpy.header();\tpy.footer();\tpy.left();\tpy.content();\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\t//C++页面\tcout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\tCPP cp;\tcp.header();\tcp.footer();\tcp.left();\tcp.content();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n总结：\n继承的好处：&#x3D;&#x3D;可以减少重复的代码&#x3D;&#x3D;\nclass A : public B; \nA 类称为子类 或 派生类\nB 类称为父类 或 基类\n派生类中的成员，包含两大部分：\n一类是从基类继承过来的，一类是自己增加的成员。\n从基类继承过过来的表现其共性，而新增的成员体现了其个性。\n继承方式继承的语法：class 子类 : 继承方式  父类\n继承方式一共有三种：\n\n公共继承\n保护继承\n私有继承\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZySriANK-1691982898273)(assets&#x2F;clip_image002.png)]\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class Base1&#123;public: \tint m_A;protected:\tint m_B;private:\tint m_C;&#125;;//公共继承class Son1 :public Base1&#123;public:\tvoid func()\t&#123;\t\tm_A; //可访问 public权限\t\tm_B; //可访问 protected权限\t\t//m_C; //不可访问\t&#125;&#125;;void myClass()&#123;\tSon1 s1;\ts1.m_A; //其他类只能访问到公共权限&#125;//保护继承class Base2&#123;public:\tint m_A;protected:\tint m_B;private:\tint m_C;&#125;;class Son2:protected Base2&#123;public:\tvoid func()\t&#123;\t\tm_A; //可访问 protected权限\t\tm_B; //可访问 protected权限\t\t//m_C; //不可访问\t&#125;&#125;;void myClass2()&#123;\tSon2 s;\t//s.m_A; //不可访问&#125;//私有继承class Base3&#123;public:\tint m_A;protected:\tint m_B;private:\tint m_C;&#125;;class Son3:private Base3&#123;public:\tvoid func()\t&#123;\t\tm_A; //可访问 private权限\t\tm_B; //可访问 private权限\t\t//m_C; //不可访问\t&#125;&#125;;class GrandSon3 :public Son3&#123;public:\tvoid func()\t&#123;\t\t//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到\t\t//m_A;\t\t//m_B;\t\t//m_C;\t&#125;&#125;;\n\n\n\n\n\n\n\n\n\n继承中的对象模型问题：从父类继承过来的成员，哪些属于子类对象中？\n示例：\n123456789101112131415161718192021222324252627282930class Base&#123;public:\tint m_A;protected:\tint m_B;private:\tint m_C; //私有成员只是被隐藏了，但是还是会继承下去&#125;;//公共继承class Son :public Base&#123;public:\tint m_D;&#125;;void test01()&#123;\tcout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n利用工具查看：\n打开工具窗口后，定位到当前CPP文件的盘符\n然后输入： cl &#x2F;d1 reportSingleClassLayout查看的类名   所属文件名\n效果如下图：\n\n\n\n\n\n\n\n\n\n结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到\n继承中构造和析构顺序子类继承父类后，当创建子类对象，也会调用父类的构造函数\n问题：父类和子类的构造和析构顺序是谁先谁后？\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142class Base &#123;public:\tBase()\t&#123;\t\tcout &lt;&lt; &quot;Base构造函数!&quot; &lt;&lt; endl;\t&#125;\t~Base()\t&#123;\t\tcout &lt;&lt; &quot;Base析构函数!&quot; &lt;&lt; endl;\t&#125;&#125;;class Son : public Base&#123;public:\tSon()\t&#123;\t\tcout &lt;&lt; &quot;Son构造函数!&quot; &lt;&lt; endl;\t&#125;\t~Son()\t&#123;\t\tcout &lt;&lt; &quot;Son析构函数!&quot; &lt;&lt; endl;\t&#125;&#125;;void test01()&#123;\t//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\tSon s;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n继承同名成员处理方式问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？\n\n访问子类同名成员   直接访问即可\n访问父类同名成员   需要加作用域\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Base &#123;public:\tBase()\t&#123;\t\tm_A = 100;\t&#125;\tvoid func()\t&#123;\t\tcout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl;\t&#125;\tvoid func(int a)\t&#123;\t\tcout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl;\t&#125;public:\tint m_A;&#125;;class Son : public Base &#123;public:\tSon()\t&#123;\t\tm_A = 200;\t&#125;\t//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数\t//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域\tvoid func()\t&#123;\t\tcout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl;\t&#125;public:\tint m_A;&#125;;void test01()&#123;\tSon s;\tcout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;\tcout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\ts.func();\ts.Base::func();\ts.Base::func(10);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn EXIT_SUCCESS;&#125;\n\n总结：\n\n子类对象可以直接访问到子类中同名成员\n子类对象加作用域可以访问到父类同名成员\n当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数\n\n继承同名静态成员处理方式问题：继承中同名的静态成员在子类对象上如何进行访问？\n静态成员和非静态成员出现同名，处理方式一致\n\n访问子类同名成员   直接访问即可\n访问父类同名成员   需要加作用域\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Base &#123;public:\tstatic void func()\t&#123;\t\tcout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl;\t&#125;\tstatic void func(int a)\t&#123;\t\tcout &lt;&lt; &quot;Base - static void func(int a)&quot; &lt;&lt; endl;\t&#125;\tstatic int m_A;&#125;;int Base::m_A = 100;class Son : public Base &#123;public:\tstatic void func()\t&#123;\t\tcout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl;\t&#125;\tstatic int m_A;&#125;;int Son::m_A = 200;//同名成员属性void test01()&#123;\t//通过对象访问\tcout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;\tSon s;\tcout &lt;&lt; &quot;Son  下 m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;\tcout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\t//通过类名访问\tcout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;Son  下 m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl;\tcout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;&#125;//同名成员函数void test02()&#123;\t//通过对象访问\tcout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;\tSon s;\ts.func();\ts.Base::func();\tcout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\tSon::func();\tSon::Base::func();\t//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问\tSon::Base::func(100);&#125;int main() &#123;\t//test01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n\n\n\n\n\n\n总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）\n多继承语法C++允许一个类继承多个类\n语法： class 子类 ：继承方式 父类1 ， 继承方式 父类2...\n多继承可能会引发父类中有同名成员出现，需要加作用域区分\nC++实际开发中不建议用多继承\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Base1 &#123;public:\tBase1()\t&#123;\t\tm_A = 100;\t&#125;public:\tint m_A;&#125;;class Base2 &#123;public:\tBase2()\t&#123;\t\tm_A = 200;  //开始是m_B 不会出问题，但是改为mA就会出现不明确\t&#125;public:\tint m_A;&#125;;//语法：class 子类：继承方式 父类1 ，继承方式 父类2 class Son : public Base2, public Base1 &#123;public:\tSon()\t&#123;\t\tm_C = 300;\t\tm_D = 400;\t&#125;public:\tint m_C;\tint m_D;&#125;;//多继承容易产生成员同名的情况//通过使用类名作用域可以区分调用哪一个基类的成员void test01()&#123;\tSon s;\tcout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(s) &lt;&lt; endl;\tcout &lt;&lt; s.Base1::m_A &lt;&lt; endl;\tcout &lt;&lt; s.Base2::m_A &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域\n菱形继承菱形继承概念：\n​\t两个派生类继承同一个基类\n​\t又有某个类同时继承者两个派生类\n​\t这种继承被称为菱形继承，或者钻石继承\n典型的菱形继承案例：\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hevQrPxx-1691982943433)(assets&#x2F;clip_image002.jpg)]\n菱形继承问题：\n\ntxt羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。\n草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。\n\n\n示例：\n1234567891011121314151617181920212223242526272829303132class Animal&#123;public:\tint m_Age;&#125;;//继承前加virtual关键字后，变为虚继承//此时公共的父类Animal称为虚基类class Sheep : virtual public Animal &#123;&#125;;class Tuo   : virtual public Animal &#123;&#125;;class SheepTuo : public Sheep, public Tuo &#123;&#125;;void test01()&#123;\tSheepTuo st;\tst.Sheep::m_Age = 100;\tst.Tuo::m_Age = 200;\tcout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;\tcout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;\tcout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n总结：\n\n菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义\n利用虚继承可以解决菱形继承问题\n\n多态1 多态的基本概念多态是C++面向对象三大特性之一\n多态分为两类\n\n静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名\n动态多态: 派生类和虚函数实现运行时多态\n\n静态多态和动态多态区别：\n\n静态多态的函数地址早绑定  -  编译阶段确定函数地址\n动态多态的函数地址晚绑定  -  运行阶段确定函数地址\n\n下面通过案例进行讲解多态\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Animal&#123;public:\t//Speak函数就是虚函数\t//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。\tvirtual void speak()\t&#123;\t\tcout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;\t&#125;&#125;;class Cat :public Animal&#123;public:\tvoid speak()\t&#123;\t\tcout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl;\t&#125;&#125;;class Dog :public Animal&#123;public:\tvoid speak()\t&#123;\t\tcout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;\t&#125;&#125;;//我们希望传入什么对象，那么就调用什么对象的函数//如果函数地址在编译阶段就能确定，那么静态联编//如果函数地址在运行阶段才能确定，就是动态联编void DoSpeak(Animal &amp; animal)&#123;\tanimal.speak();&#125;////多态满足条件： //1、有继承关系//2、子类重写父类中的虚函数//多态使用：//父类指针或引用指向子类对象void test01()&#123;\tCat cat;\tDoSpeak(cat);\tDog dog;\tDoSpeak(dog);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n多态满足条件\n\n有继承关系\n子类重写父类中的虚函数\n\n多态使用条件\n\n父类指针或引用指向子类对象\n\n重写：函数返回值类型  函数名 参数列表 完全一致称为重写\n2 多态案例一-计算器类案例描述：\n分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类\n多态的优点：\n\n代码组织结构清晰\n可读性强\n利于前期和后期的扩展以及维护\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//普通实现class Calculator &#123;public:\tint getResult(string oper)\t&#123;\t\tif (oper == &quot;+&quot;) &#123;\t\t\treturn m_Num1 + m_Num2;\t\t&#125;\t\telse if (oper == &quot;-&quot;) &#123;\t\t\treturn m_Num1 - m_Num2;\t\t&#125;\t\telse if (oper == &quot;*&quot;) &#123;\t\t\treturn m_Num1 * m_Num2;\t\t&#125;\t\t//如果要提供新的运算，需要修改源码\t&#125;public:\tint m_Num1;\tint m_Num2;&#125;;void test01()&#123;\t//普通实现测试\tCalculator c;\tc.m_Num1 = 10;\tc.m_Num2 = 10;\tcout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl;\tcout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;\tcout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;&#125;//多态实现//抽象计算器类//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护class AbstractCalculator&#123;public :\tvirtual int getResult()\t&#123;\t\treturn 0;\t&#125;\tint m_Num1;\tint m_Num2;&#125;;//加法计算器class AddCalculator :public AbstractCalculator&#123;public:\tint getResult()\t&#123;\t\treturn m_Num1 + m_Num2;\t&#125;&#125;;//减法计算器class SubCalculator :public AbstractCalculator&#123;public:\tint getResult()\t&#123;\t\treturn m_Num1 - m_Num2;\t&#125;&#125;;//乘法计算器class MulCalculator :public AbstractCalculator&#123;public:\tint getResult()\t&#123;\t\treturn m_Num1 * m_Num2;\t&#125;&#125;;void test02()&#123;\t//创建加法计算器\tAbstractCalculator *abc = new AddCalculator;\tabc-&gt;m_Num1 = 10;\tabc-&gt;m_Num2 = 10;\tcout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\tdelete abc;  //用完了记得销毁\t//创建减法计算器\tabc = new SubCalculator;\tabc-&gt;m_Num1 = 10;\tabc-&gt;m_Num2 = 10;\tcout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\tdelete abc;  \t//创建乘法计算器\tabc = new MulCalculator;\tabc-&gt;m_Num1 = 10;\tabc-&gt;m_Num2 = 10;\tcout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\tdelete abc;&#125;int main() &#123;\t//test01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n\n\n\n\n\n\n总结：C++开发提倡利用多态设计程序架构，因为多态优点很多\n3 纯虚函数和抽象类在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容\n因此可以将虚函数改为纯虚函数\n纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ;\n当类中有了纯虚函数，这个类也称为&#x3D;&#x3D;抽象类&#x3D;&#x3D;\n抽象类特点：\n\n无法实例化对象\n子类必须重写抽象类中的纯虚函数，否则也属于抽象类\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536class Base&#123;public:\t//纯虚函数\t//类中只要有一个纯虚函数就称为抽象类\t//抽象类无法实例化对象\t//子类必须重写父类中的纯虚函数，否则也属于抽象类\tvirtual void func() = 0;&#125;;class Son :public Base&#123;public:\tvirtual void func() \t&#123;\t\tcout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;\t&#125;;&#125;;void test01()&#123;\tBase * base = NULL;\t//base = new Base; // 错误，抽象类无法实例化对象\tbase = new Son;\tbase-&gt;func();\tdelete base;//记得销毁&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4 多态案例二-制作饮品案例描述：\n制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料\n利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-JV8LLq0q-1691982974822)(assets&#x2F;1545985945198.png)]\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//抽象制作饮品class AbstractDrinking &#123;public:\t//烧水\tvirtual void Boil() = 0;\t//冲泡\tvirtual void Brew() = 0;\t//倒入杯中\tvirtual void PourInCup() = 0;\t//加入辅料\tvirtual void PutSomething() = 0;\t//规定流程\tvoid MakeDrink() &#123;\t\tBoil();\t\tBrew();\t\tPourInCup();\t\tPutSomething();\t&#125;&#125;;//制作咖啡class Coffee : public AbstractDrinking &#123;public:\t//烧水\tvirtual void Boil() &#123;\t\tcout &lt;&lt; &quot;煮农夫山泉!&quot; &lt;&lt; endl;\t&#125;\t//冲泡\tvirtual void Brew() &#123;\t\tcout &lt;&lt; &quot;冲泡咖啡!&quot; &lt;&lt; endl;\t&#125;\t//倒入杯中\tvirtual void PourInCup() &#123;\t\tcout &lt;&lt; &quot;将咖啡倒入杯中!&quot; &lt;&lt; endl;\t&#125;\t//加入辅料\tvirtual void PutSomething() &#123;\t\tcout &lt;&lt; &quot;加入牛奶!&quot; &lt;&lt; endl;\t&#125;&#125;;//制作茶水class Tea : public AbstractDrinking &#123;public:\t//烧水\tvirtual void Boil() &#123;\t\tcout &lt;&lt; &quot;煮自来水!&quot; &lt;&lt; endl;\t&#125;\t//冲泡\tvirtual void Brew() &#123;\t\tcout &lt;&lt; &quot;冲泡茶叶!&quot; &lt;&lt; endl;\t&#125;\t//倒入杯中\tvirtual void PourInCup() &#123;\t\tcout &lt;&lt; &quot;将茶水倒入杯中!&quot; &lt;&lt; endl;\t&#125;\t//加入辅料\tvirtual void PutSomething() &#123;\t\tcout &lt;&lt; &quot;加入枸杞!&quot; &lt;&lt; endl;\t&#125;&#125;;//业务函数void DoWork(AbstractDrinking* drink) &#123;\tdrink-&gt;MakeDrink();\tdelete drink;&#125;void test01() &#123;\tDoWork(new Coffee);\tcout &lt;&lt; &quot;--------------&quot; &lt;&lt; endl;\tDoWork(new Tea);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n5 虚析构和纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码\n解决方式：将父类中的析构函数改为虚析构或者纯虚析构\n虚析构和纯虚析构共性：\n\n可以解决父类指针释放子类对象\n都需要有具体的函数实现\n\n虚析构和纯虚析构区别：\n\n如果是纯虚析构，该类属于抽象类，无法实例化对象\n\n虚析构语法：\nvirtual ~类名()&#123;&#125;\n纯虚析构语法：\n virtual ~类名() = 0;\n类名::~类名()&#123;&#125;\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Animal &#123;public:\tAnimal()\t&#123;\t\tcout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;\t&#125;\tvirtual void Speak() = 0;\t//析构函数加上virtual关键字，变成虚析构函数\t//virtual ~Animal()\t//&#123;\t//\tcout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;\t//&#125;\tvirtual ~Animal() = 0;&#125;;Animal::~Animal()&#123;\tcout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;&#125;//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。class Cat : public Animal &#123;public:\tCat(string name)\t&#123;\t\tcout &lt;&lt; &quot;Cat构造函数调用！&quot; &lt;&lt; endl;\t\tm_Name = new string(name);\t&#125;\tvirtual void Speak()\t&#123;\t\tcout &lt;&lt; *m_Name &lt;&lt;  &quot;小猫在说话!&quot; &lt;&lt; endl;\t&#125;\t~Cat()\t&#123;\t\tcout &lt;&lt; &quot;Cat析构函数调用!&quot; &lt;&lt; endl;\t\tif (this-&gt;m_Name != NULL) &#123;\t\t\tdelete m_Name;\t\t\tm_Name = NULL;\t\t&#125;\t&#125;public:\tstring *m_Name;&#125;;void test01()&#123;\tAnimal *animal = new Cat(&quot;Tom&quot;);\tanimal-&gt;Speak();\t//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏\t//怎么解决？给基类增加一个虚析构函数\t//虚析构函数就是用来解决通过父类指针释放子类对象\tdelete animal;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n总结：\n​\t1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象\n​\t2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构\n​\t3. 拥有纯虚析构函数的类也属于抽象类\n6 多态案例三-电脑组装案例描述：\n电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）\n将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商\n创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口\n测试时组装三台不同的电脑进行工作\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;iostream&gt;using namespace std;//抽象CPU类class CPU&#123;public:\t//抽象的计算函数\tvirtual void calculate() = 0;&#125;;//抽象显卡类class VideoCard&#123;public:\t//抽象的显示函数\tvirtual void display() = 0;&#125;;//抽象内存条类class Memory&#123;public:\t//抽象的存储函数\tvirtual void storage() = 0;&#125;;//电脑类class Computer&#123;public:\tComputer(CPU * cpu, VideoCard * vc, Memory * mem)\t&#123;\t\tm_cpu = cpu;\t\tm_vc = vc;\t\tm_mem = mem;\t&#125;\t//提供工作的函数\tvoid work()\t&#123;\t\t//让零件工作起来，调用接口\t\tm_cpu-&gt;calculate();\t\tm_vc-&gt;display();\t\tm_mem-&gt;storage();\t&#125;\t//提供析构函数 释放3个电脑零件\t~Computer()\t&#123;\t\t//释放CPU零件\t\tif (m_cpu != NULL)\t\t&#123;\t\t\tdelete m_cpu;\t\t\tm_cpu = NULL;\t\t&#125;\t\t//释放显卡零件\t\tif (m_vc != NULL)\t\t&#123;\t\t\tdelete m_vc;\t\t\tm_vc = NULL;\t\t&#125;\t\t//释放内存条零件\t\tif (m_mem != NULL)\t\t&#123;\t\t\tdelete m_mem;\t\t\tm_mem = NULL;\t\t&#125;\t&#125;private:\tCPU * m_cpu; //CPU的零件指针\tVideoCard * m_vc; //显卡零件指针\tMemory * m_mem; //内存条零件指针&#125;;//具体厂商//Intel厂商class IntelCPU :public CPU&#123;public:\tvirtual void calculate()\t&#123;\t\tcout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl;\t&#125;&#125;;class IntelVideoCard :public VideoCard&#123;public:\tvirtual void display()\t&#123;\t\tcout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl;\t&#125;&#125;;class IntelMemory :public Memory&#123;public:\tvirtual void storage()\t&#123;\t\tcout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl;\t&#125;&#125;;//Lenovo厂商class LenovoCPU :public CPU&#123;public:\tvirtual void calculate()\t&#123;\t\tcout &lt;&lt; &quot;Lenovo的CPU开始计算了！&quot; &lt;&lt; endl;\t&#125;&#125;;class LenovoVideoCard :public VideoCard&#123;public:\tvirtual void display()\t&#123;\t\tcout &lt;&lt; &quot;Lenovo的显卡开始显示了！&quot; &lt;&lt; endl;\t&#125;&#125;;class LenovoMemory :public Memory&#123;public:\tvirtual void storage()\t&#123;\t\tcout &lt;&lt; &quot;Lenovo的内存条开始存储了！&quot; &lt;&lt; endl;\t&#125;&#125;;void test01()&#123;\t//第一台电脑零件\tCPU * intelCpu = new IntelCPU;\tVideoCard * intelCard = new IntelVideoCard;\tMemory * intelMem = new IntelMemory;\tcout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl;\t//创建第一台电脑\tComputer * computer1 = new Computer(intelCpu, intelCard, intelMem);\tcomputer1-&gt;work();\tdelete computer1;\tcout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl;\t//第二台电脑组装\tComputer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;\tcomputer2-&gt;work();\tdelete computer2;\tcout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl;\t//第三台电脑组装\tComputer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;\tcomputer3-&gt;work();\tdelete computer3;&#125;\n\n\n\n\n\n","slug":"类和对象_2","date":"2021-09-16T09:49:00.000Z","categories_index":"C++高级","tags_index":"C++,构造函数,面向对象,类,拷贝控制","author_index":"kiyose408"},{"id":"e79fdcc412b995815cc4152ea34468ff","title":"LeetCode需求实现一","content":"实现初始化一个和已知vector大小相同的新的vector。在C++中，你可以使用构造函数来初始化一个和已知vector大小相同的新的vector。这里有一个例子：\n123456789#include &lt;vector&gt;// 假设你有一个vectorstd::vector&lt;int&gt; original_vector = &#123;1, 2, 3, 4, 5&#125;;// 你可以使用original_vector的size()方法来初始化一个新的相同大小的vectorstd::vector&lt;int&gt; new_vector(original_vector.size());// 现在new_vector已经被初始化为和original_vector相同大小了\n\n\n\n\n\n\n\n\n\n\n这段代码首先定义了一个名为original_vector的vector，然后使用original_vector.size()的方法来初始化一个新的vector new_vector，使其大小与original_vector相同。\n注意，这样做只是创建了一个大小相同但元素未初始化（默认初始化，对于基本类型如int，默认值通常是0）的新vector。如果你想要新vector的每个元素也和原vector相同，你需要用拷贝构造函数或赋值操作：\n123456// 使用拷贝构造函数std::vector&lt;int&gt; new_vector(original_vector);// 或者使用赋值操作std::vector&lt;int&gt; new_vector;new_vector = original_vector;\n\n这两种方式都会创建一个内容和original_vector完全相同的新vector。\n将二维vector转化为一维vector将一个二维vector（vector&lt;vector&lt;int&gt;&gt;）转换为一维vector（vector&lt;int&gt;），可以通过遍历二维vector的每个元素并将它们逐一插入到新的一维vector中实现。下面是一个简单的示例代码：\n123456789101112131415161718192021222324252627282930#include &lt;vector&gt;std::vector&lt;int&gt; convert2DTo1D(const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; twoDVector) &#123;    std::vector&lt;int&gt; oneDVector;    // 遍历二维vector的每一行    for(const auto&amp; row : twoDVector) &#123;        // 将当前行的所有元素添加到一维vector中        oneDVector.insert(oneDVector.end(), row.begin(), row.end());    &#125;    return oneDVector;&#125;int main() &#123;    std::vector&lt;std::vector&lt;int&gt;&gt; originalGrid = &#123;        &#123;1, 2, 3&#125;,        &#123;4, 5, 6&#125;,        &#123;7, 8, 9&#125;    &#125;;    std::vector&lt;int&gt; flattenedVector = convert2DTo1D(originalGrid);    // 打印转化后的一维vector    for(int num : flattenedVector) &#123;        std::cout &lt;&lt; num &lt;&lt; &#x27; &#x27;;    &#125;    return 0;&#125;\n\n这段代码定义了一个函数convert2DTo1D，它接收一个二维vector作为参数，并返回一个包含所有元素的一维vector。在main函数中，我们创建了一个二维vector originalGrid，然后调用convert2DTo1D函数将其转换为一维vector flattenedVector，最后打印出转换后的一维vector。\n快速遍历一维vector数组遍历一维vector数组（即普通的vector）在C++中非常直接，可以使用标准的循环或者C++11引入的范围for循环（range-based for loop）来完成。下面是两种方法的示例：\n方法1: 使用标准的for循环1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123;    std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;;    // 使用迭代器遍历    for(std::vector&lt;int&gt;::iterator it = vec.begin(); it != vec.end(); ++it) &#123;        std::cout &lt;&lt; *it &lt;&lt; &#x27; &#x27;;    &#125;    std::cout &lt;&lt; &#x27;\\n&#x27;;    // 使用索引遍历    for(size_t i = 0; i &lt; vec.size(); ++i) &#123;        std::cout &lt;&lt; vec[i] &lt;&lt; &#x27; &#x27;;    &#125;    return 0;&#125;\n\n方法2: 使用范围for循环 (C++11及以上)范围for循环提供了一种更简洁的方式来遍历容器中的元素，不需要显式管理迭代器或索引。\n12345678910111213#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123;    std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;;    // 范围for循环遍历    for(const auto&amp; elem : vec) &#123;        std::cout &lt;&lt; elem &lt;&lt; &#x27; &#x27;;    &#125;    return 0;&#125;\n\n在这个例子中，const auto&amp; elem自动依次取vector中的每个元素，使得代码更加简洁且易于阅读。这是遍历一维vector数组的推荐方法，因为它既简单又安全。\n实现快速遍历二维vector数组在C++中，遍历二维vector（即vector的vector）可以通过嵌套循环来完成。下面是一个基本的例子：\n1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123;    // 初始化一个二维vector    std::vector&lt;std::vector&lt;int&gt;&gt; vec = &#123;        &#123;1, 2, 3&#125;,        &#123;4, 5, 6&#125;,        &#123;7, 8, 9&#125;    &#125;;    // 双重循环遍历二维vector    for(size_t i = 0; i &lt; vec.size(); ++i) &#123;        for(size_t j = 0; j &lt; vec[i].size(); ++j) &#123;            // 输出当前元素            std::cout &lt;&lt; vec[i][j] &lt;&lt; &#x27; &#x27;;        &#125;        // 换行，表示完成一行的打印        std::cout &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;\n\n这段代码首先定义并初始化了一个二维的vector，然后通过两层循环遍历它：外层循环遍历vector的每一行，内层循环遍历每一行中的每个元素。这样就可以访问到二维vector中的每一个元素。\n\n\n\n\n\n\n\n\n\n如果你对C++11及以后版本的范围基础语句熟悉，你也可以使用更简洁的for-each循环（range-based for loop）来遍历，但遍历二维数组时仍需要嵌套循环：\n12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123;    std::vector&lt;std::vector&lt;int&gt;&gt; vec = &#123;        &#123;1, 2, 3&#125;,        &#123;4, 5, 6&#125;,        &#123;7, 8, 9&#125;    &#125;;    for(const auto&amp; row : vec) &#123;        for(const auto&amp; elem : row) &#123;            std::cout &lt;&lt; elem &lt;&lt; &#x27; &#x27;;        &#125;        std::cout &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;\n\n这种方式代码更为简洁，可读性更强。\n","slug":"LeetCode需求实现一","date":"2021-09-06T23:49:00.000Z","categories_index":"LeetCode","tags_index":"LeetCode,vector","author_index":"kiyose408"},{"id":"ae53cbdfb185be70e1c06b4739ffc47b","title":"函数提高","content":"函数默认参数在C++中，函数的形参列表是可以有默认值的。语法：\n1返回值类型  函数名  (参数 = 默认值)&#123;&#125;\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;//函数默认参数//如果我们传入了自己的数据就使用自己的数据，否则就是使用默认值//语法： 返回值类型 函数名（形参 = 默认值）&#123;&#125;int func(int a, int b = 20, int c = 30)&#123;\treturn a + b + c;&#125;//注意事项//1、如果某个位置已经有了默认参数，那么从这个位置往后从左到右，都必须有默认值//int func02(int a, int b = 10, int c)//&#123;//\treturn a + b + c;//&#125;//2、如果函数声明有了默认参数，函数的实现就不能有默认参数// 声明和实现只能有一个有默认参数//原因：二义性int func2(int a = 10, int b = 10);int func2(int a, int b)&#123;\treturn a + b;&#125;int main()&#123;\tcout &lt;&lt; func(10, 30) &lt;&lt; endl;\tcout &lt;&lt; func2(10, 30) &lt;&lt; endl;\t//cout &lt;&lt; func02(10) &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n\n\n\n\n\n\n第一注意点\n第二注意点\n\n笔记：\n函数占位参数C++ 中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\n语法：\n1返回值类型 函数名（数据类型）&#123;&#125;\n函数占位参数存在意义在后面的学习中会使用到该技术。示例：\n1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;//占位参数//返回值类型 函数名 （数据类型）&#123;&#125;//目前阶段的占位参数 我们还用不到 后面学习深入会用到//占位参数可以有默认参数void func(int a , int = 10)void func(int a , int )&#123;\tcout &lt;&lt; &quot; this is a function&quot; &lt;&lt; endl;&#125;int main()&#123;\tfunc(10,10);\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n笔记：\n函数重载函数重载概述作用：函数名可以相同，提高复用性函数重载满足条件：\n\n同一个作用域下\n函数名称相同\n函数参数类型不同或者个数不同或者顺序不同\n\n注意：函数的返回值不可以作为函数重载的条件\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;using namespace std;//函数重载//可以让函数名相同，提高复用性//函数重载满足条件//1、同一个作用域下//2、函数名称相同//3、函数参数类型不同，或者个数不同，或者顺序不同void func()&#123;\tcout &lt;&lt; &quot;func的调用&quot; &lt;&lt; endl;&#125;void func(int a)&#123;\tcout &lt;&lt; &quot;func(int a)的调用!&quot; &lt;&lt; endl;&#125;void func(double a)&#123;\tcout &lt;&lt; &quot;func(double a)的调用!&quot; &lt;&lt; endl;&#125;void func(int a,double b)&#123;\tcout &lt;&lt; &quot;func(int a,double b))的调用!&quot; &lt;&lt; endl;&#125;void func(double a, int b)&#123;\tcout &lt;&lt; &quot;func(double a, int b)的调用!&quot; &lt;&lt; endl;&#125;//注意事项//函数的返回值不可以作为函数重载的条件（返回值不同不是重载）//int func(double a, int b)//&#123;//\tcout &lt;&lt; &quot;func(double a, int b)的调用!&quot; &lt;&lt; endl;//&#125;int main()&#123;\t//func();\t//func(10);\t//func(3.14);\t//func(10, 3.14);\tfunc(3.14, 10);\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n笔记：\n函数重载注意事项\n引用作为重载条件\n函数重载碰到函数默认参数\n\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;//函数重载的注意事项//1、引用作为重载的条件void func(int &amp;a)&#123;\tcout &lt;&lt; &quot;func(int &amp;a)调用&quot; &lt;&lt; endl;&#125;void func(const int &amp;a)//const int&amp; a = 10；相当与创建了一个临时数据，让a指向那个临时空间&#123;\tcout &lt;&lt; &quot;func(const int &amp;a)调用&quot; &lt;&lt; endl;&#125;//2、函数重载碰到的默认参数void func2(int a,int b = 10)&#123;\tcout &lt;&lt; &quot;func2(int a,int b)的调用&quot; &lt;&lt; endl;&#125;void func2(int a)&#123;\tcout &lt;&lt; &quot;func2(int a)的调用&quot; &lt;&lt; endl;&#125;int main()&#123;\t//int a = 10;//变量 可读可写  \t//func(a);//此时传入会使用非const版本\t//func(10);//此段如果还是使用非const版本，语法就会变为 int &amp;a=10；非法语法（引用不可以=10），走const版本语法就是 const int &amp;a=10；为合法语法。\t//func2(10);//当函数重载碰到默认参数，出现二义性，报错，避免出现这种情况。写函数重载尽量避免写默认参数\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n笔记：\n","slug":"函数提高","date":"2021-08-31T23:49:00.000Z","categories_index":"C++高级","tags_index":"C++,函数,默认参数,重载,多态","author_index":"kiyose408"},{"id":"a55fc9d3e63ec59352fa8738bb767a18","title":"C++中的引用","content":"C++中的引用引用的基本语法作用：给变量起别名语法：&#x3D;&#x3D;数据类型 &amp; 别名 &#x3D; 原名&#x3D;&#x3D;\n12345//比如给一个int变量a命名一个别名 bint &amp;b = a;b = 20;cout&lt;&lt; a &lt;&lt; endl;//a= 20\n\n引用的注意事项\n引用必须初始化\n\n1int &amp;b;//错误的\n\n\n引用在初始化后，就不可以改变了\n示例:\n\n12345678int mian()&#123;int a = 10;int b = 20;int &amp;c = a;c=b;cout\n\n引用做函数参数作用:函数传参时，可以利用引用的技术让形参修饰实参优点:可以简化指针修改实参\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;//交换函数//1、值传递void mySwap01(int a, int b)&#123;\tint temp = a;\ta = b;\tb = temp;\tcout &lt;&lt; &quot;swap01 a = &quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;swap01 b = &quot; &lt;&lt; b &lt;&lt; endl;&#125;//2、地址传递void mySwap02(int *a,int *b)&#123;\tint temp = *a;\t*a = *b;\t*b = temp;&#125;// //3、引用传递void mySwap03(int &amp;a,int &amp;b)//a，b已经时引用作为别名进行操作修改，理解为就是对于实参进行操作&#123;\tint temp = a;\ta = b;\tb = temp;&#125;int main()&#123;\tint a = 10;\tint b = 20;\t//mySwap01(a, b);//值传递，形参不会改变实参\t//mySwap02(&amp;a, &amp;b);//地址传递，形参会修饰实参\tmySwap03(a, b);//引用传递，形参会修饰实参\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;\tsystem(&quot;pause&quot;);&#125;\n\n引用做函数返回值作用：引用时可以作为函数的返回值存在的。\n注意：不要返回局部变量引用用法：函数调用做左值\n示例：\n12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;//引用做函数的返回值//1、不要返回局部变量的引用int&amp; test01()&#123;\tint a = 10;\t//局部变量存放在四区中的  栈区\treturn a;&#125;//2、函数的调用可以做为左值int&amp; test02()&#123;\tstatic int a = 10;\t//静态变量，存放在全局区，全局区上的数据在程序结束后系统释放\treturn a;&#125;int main()&#123;\tint&amp; ref = test01();\tcout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\tcout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;\tint&amp; ref1 = test02();\tcout &lt;&lt; &quot;ref1 = &quot; &lt;&lt; ref1 &lt;&lt; endl;//实现对于静态变量的返回\tcout &lt;&lt; &quot;ref1 = &quot; &lt;&lt; ref1 &lt;&lt; endl;//在程序结束之前不会被释放\t//如果函数的返回值是引用，这个函数调用可以作为左值\ttest02() = 1000;//返回的是a，相当于对a直接操作\tcout &lt;&lt; &quot;ref1 = &quot; &lt;&lt; ref1 &lt;&lt; endl;//ref1就是a的别名，所以此时就会改变此处的值了\tcout &lt;&lt; &quot;ref1 = &quot; &lt;&lt; ref1 &lt;&lt; endl;\tsystem(&quot;pause&quot;);&#125;\n\n引用的本质本质：引用的本质在C++内部实现是一个指针常量（指针的指向是不可更改的）\n示例：\n12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;//发现是引用，转换为 int* const ref = &amp;a;void func(int&amp; ref) &#123;\tref = 100;//ref是引用，转换为*ref = 100&#125;int main()&#123;\tint a = 10;\t//自动转换成 int* const ref = &amp;a;指针常量是指针指向不可改，也说明为什么引用不可更改\tint&amp; ref = a;\tref = 20;//内部发现ref是引用，自动帮我们转换为：*ref = 20；\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl;\tfunc(a);\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl;\treturn 0;&#125;\n结论：C++推荐引用技术，因为语法方便，引用本质就是指针常量，但是所有的指针操作编译器都帮我们做了。\n常量引用作用:常量引用主要用来修饰形参，防止误操作在函数形参列表中，可以加const修饰形参，防止形参改变实参\n示例：\n1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;//打印数据函数void showValue(const int&amp; val)&#123;\t//val = 1000;\tcout &lt;&lt; &quot;val = &quot; &lt;&lt; val &lt;&lt; endl;&#125;int main()&#123;\t//常量引用\t//使用场景，用来修饰形参,防止误操作\t//int a = 10;\t//加上const之后 编译器将代码修改  int temp = 10； const int &amp; ref = temp;\t//const int&amp; ref = 10;//引用必须引用一块合法的引用空间\t//ref = 20；//加入const之后变为只读，不可以修改\tint a = 100;\tshowValue(a);\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n","slug":"C++中的引用","date":"2021-08-14T03:49:00.000Z","categories_index":"C++高级","tags_index":"C++,内存管理,分区模型","author_index":"kiyose408"},{"id":"bddeee4d46cae4292f5af8a8347e08fc","title":"内存分区模型","content":"const修饰符常常需要在c++中使用到，需要注意到他对于指针修饰的时候的不同区别。\n12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;int main()&#123;\t//1.const修饰指针\tint a = 10;\tint b = 10;\tconst int* p = &amp;a;\t//指针指向的值不可以改，指针的指向可以改\t// \t//*p = 20;\t\t错误\tp = &amp;b;//正确\t//2.const修饰常量     指针常量\t//指针的指向不可以改，指针指向的值可以改\tint * const p2 = &amp;a;\t*p2 = 100; //正确的\t//p2 = &amp;b;\t//错误，指针的指向不可以改\t//3.const修饰指针和常量\tconst int* const p3 = &amp;a;\t//指针的指向 和 指针指向的值 都不可以改\t//*p3 = 100; //错误\t//p3 = &amp;b;   //错误\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n\n\n\n\n\n\n技巧：看const右侧紧跟着的是指针还是常量，是指针就是常量指针，是常量就是指针常量\n","slug":"const修饰符修饰指针","date":"2021-08-03T03:49:00.000Z","categories_index":"C++高级","tags_index":"C++,内存管理,分区模型","author_index":"kiyose408"},{"id":"bddeee4d46cae4292f5af8a8347e08fc","title":"内存分区模型","content":"内存分区模型 C++程序在执行时，将内存大方向分为四个区域。\n\n代码区：存放函数体的二进制代码，由操作系统进行管理。\n全局区：存放全局变量和静态变量以及常量。\n栈区：由编译器自动分配释放，存放函数的参数值，局部变量等\n堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收\n\n 内存四区意义：不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程。\n程序运行前在程序编译后，生成exe可执行程序，未执行该程序前分为两个区域。代码区：\n\n存放CPU执行的机器指令\n代码区时共享的，共享的目的时对于频繁被执行的程序，只需要在内存中有一份代码即可\n代码区是只读的，使其只读的原因是防止程序意外地修改了他的指令\n\n全局区：\n\n全局变量和静态变量存放在此处\n全局区还包含了常量区，字符串常量和其他常量也存放在此\n&#x3D;&#x3D;该区域的数据在程序结束后由操作系统释放&#x3D;&#x3D;\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;//全局变量  int g_a = 10;int g_b = 10;//const修饰的全局变量const int c_g_a = 10;const int c_g_b = 10;int main()&#123;\t//全局区\t//全局变量、静态变量、常量\t//创建普通局部变量\tint a = 10;\tint b = 10;\tcout &lt;&lt; &quot;局部变量a的地址为：&quot; &lt;&lt; (int)&amp;a &lt;&lt; endl;\tcout &lt;&lt; &quot;局部变量b的地址为：&quot; &lt;&lt; (int)&amp;b &lt;&lt; endl;\tcout &lt;&lt; &quot;全局变量g_a的地址为：&quot; &lt;&lt; (int)&amp;g_a &lt;&lt; endl;\tcout &lt;&lt; &quot;全局变量g_b的地址为：&quot; &lt;&lt; (int)&amp;g_b &lt;&lt; endl;\t//静态变量\t在普通变量前添加static，属于静态变量\tstatic int s_a = 10;\tstatic int s_b = 10;\tcout &lt;&lt; &quot;静态变量s_a的地址为：&quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl;\tcout &lt;&lt; &quot;静态变量s_b的地址为：&quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl;\t//常量\t//字符串常量\tcout &lt;&lt; &quot;字符串常量的地址为：&quot; &lt;&lt; (int)&amp;&quot;hello,world&quot; &lt;&lt; endl;\t//const修饰的变量\tcout &lt;&lt; &quot;全局常量 c_g_a的地址为：&quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl;\tcout &lt;&lt; &quot;全局常量 c_g_b的地址为：&quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl;\t//const修饰的局部变量\tconst int c_l_a = 10;\tconst int c_l_b = 10;\tcout &lt;&lt; &quot;局部常量 c_l_a的地址为：&quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl;\tcout &lt;&lt; &quot;局部常量 c_l_b的地址为：&quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n程序运行后栈区：\n\n由编译器自动分配释放，存放函数的参数值，局部变量等\n注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放\n\n1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;//栈区数据注意事项 --- 不要返回局部变量的地址//栈区的数据由编译器管理开辟和释放int* func(int b)\t//形参数据也会放在栈区&#123;\tb = 100;\tint a = 10; //局部变量     存放在栈区，栈区的数据在函数执行完后自动释放\treturn &amp;a;\t\t//返回局部变量的地址   &#125;int main()&#123;\t//接受func函数的返回值\tint * p = func(1);\tcout &lt;&lt; *p &lt;&lt; endl;\t//第一次可以答应正确的数字，是因为编译器做了保留\tcout &lt;&lt; *p &lt;&lt; endl;\t//第二次这数据就不再保留了（2022版本的vs做出改版，对返回值保留持续了）\tsystem(&quot;pause&quot;);&#125;\n编译器编译时会提示不要返回局部变量或者临时变量的地址。一般会被释放产生问题（在2022VS中加入了更高的适配，对其做出了保留，但是不要如此使用）堆区\n\n由程序员分配释放，若是程序员不释放，程序结束时由操作做系统回收\n在C++中主要利用new在堆区开辟内存示例\n\n12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;int* func()&#123;\t//利用new关键字可以将数据开辟到堆区\t//指针 本质也是局部变量，放在栈上\tint* p=new int(10);\treturn p;&#125;int main()&#123;\t//在堆区开辟数据\tint* p = func();\tcout &lt;&lt; *p &lt;&lt; endl;\tcout &lt;&lt; *p &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n总结：\n\n堆区数据由程序员管理开辟和释放\n堆区数据利用new关键字进行开辟内存\n\nnew操作符\nc++中利用new操作符在堆区开辟数据\n堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete\n语法 ： new 数据类型\n利用new创建的数据，会返回该数据对应的类型的指针\n示例：\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;using namespace std;//1、new的基本语法int* func()&#123;\t//在堆区创建整型数据\t//new返回的是   该数据类型的指针\tint * p = new int(10);\treturn p;&#125;void test01()&#123;\tint * p = func();\tcout &lt;&lt; *p &lt;&lt; endl;\tcout &lt;&lt; *p &lt;&lt; endl;\tcout &lt;&lt; *p &lt;&lt; endl;\t//堆区的数据  由程序员管理开辟，程序员管理释放\t//如果想释放堆区的数据，利用关键字 delete\tdelete p;\t//cout &lt;&lt; *p &lt;&lt; endl;\t\t//内存已经释放，再次访问是非法操作，会报错&#125;//2、在堆区利用new开辟一个数组void test02()&#123;\t//创建10整型数组，在堆区\tint * arr = new int[10];\t\t//10代表数组有10个元素\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tarr[i] = i + 100; //给10个元素赋值 100~109\t&#125;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tcout &lt;&lt; arr[i] &lt;&lt; endl;\t&#125;\t//释放堆区的数组\t//释放数组的时候 要加【】才可以\tdelete[] arr;&#125;int main()&#123;    test01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n","slug":"内存分区模型","date":"2021-07-31T03:49:00.000Z","categories_index":"C++高级","tags_index":"C++,内存管理,分区模型","author_index":"kiyose408"},{"id":"c11341765c3dcde8916cd12b11e4e28c","title":"STL常用算法","content":"概述:\n\n算法主要是由头文件&lt;algorithm&gt; &lt;functional&gt; &lt;numeric&gt;组成。\n\n&lt;algorithm&gt;是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等\n\n&lt;numeric&gt;体积很小，只包括几个在序列上面进行简单数学运算的模板函数\n\n&lt;functional&gt;定义了一些模板类,用以声明函数对象。\n\n\n1 常用遍历算法学习目标：\n\n掌握常用的遍历算法\n\n算法简介：\n\nfor_each     &#x2F;&#x2F;遍历容器\ntransform   &#x2F;&#x2F;搬运容器到另一个容器中\n\n1.1 for_each功能描述：\n\n实现遍历容器\n\n函数原型：\n\nfor_each(iterator beg, iterator end, _func);  \n&#x2F;&#x2F; 遍历算法 遍历容器元素\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; _func 函数或者函数对象\n\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;algorithm&gt;#include &lt;vector&gt;//普通函数void print01(int val) &#123;\tcout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;//函数对象class print02 &#123; public:\tvoid operator()(int val) \t&#123;\t\tcout &lt;&lt; val &lt;&lt; &quot; &quot;;\t&#125;&#125;;//for_each算法基本用法void test01() &#123;\tvector&lt;int&gt; v;\tfor (int i = 0; i &lt; 10; i++) \t&#123;\t\tv.push_back(i);\t&#125;\t//遍历算法\tfor_each(v.begin(), v.end(), print01);\tcout &lt;&lt; endl;\tfor_each(v.begin(), v.end(), print02());\tcout &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：for_each在实际开发中是最常用遍历算法，需要熟练掌握\n1.2 transform功能描述：\n\n搬运容器到另一个容器中\n\n函数原型：\n\ntransform(iterator beg1, iterator end1, iterator beg2, _func);\n\n&#x2F;&#x2F;beg1 源容器开始迭代器\n&#x2F;&#x2F;end1 源容器结束迭代器\n&#x2F;&#x2F;beg2 目标容器开始迭代器\n&#x2F;&#x2F;_func 函数或者函数对象\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;vector&gt;#include&lt;algorithm&gt;//常用遍历算法  搬运 transformclass TransForm&#123;public:\tint operator()(int val)\t&#123;\t\treturn val;\t&#125;&#125;;class MyPrint&#123;public:\tvoid operator()(int val)\t&#123;\t\tcout &lt;&lt; val &lt;&lt; &quot; &quot;;\t&#125;&#125;;void test01()&#123;\tvector&lt;int&gt;v;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tv.push_back(i);\t&#125;\tvector&lt;int&gt;vTarget; //目标容器\tvTarget.resize(v.size()); // 目标容器需要提前开辟空间\ttransform(v.begin(), v.end(), vTarget.begin(), TransForm());\tfor_each(vTarget.begin(), vTarget.end(), MyPrint());&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运\n2 常用查找算法学习目标：\n\n掌握常用的查找算法\n\n算法简介：\n\nfind                     &#x2F;&#x2F;查找元素\nfind_if               &#x2F;&#x2F;按条件查找元素\nadjacent_find    &#x2F;&#x2F;查找相邻重复元素\nbinary_search    &#x2F;&#x2F;二分查找法\ncount                   &#x2F;&#x2F;统计元素个数\ncount_if             &#x2F;&#x2F;按条件统计元素个数\n\n2.1 find功能描述：\n\n查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()\n\n函数原型：\n\nfind(iterator beg, iterator end, value);  \n&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; value 查找的元素\n\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;void test01() &#123;\tvector&lt;int&gt; v;\tfor (int i = 0; i &lt; 10; i++) &#123;\t\tv.push_back(i + 1);\t&#125;\t//查找容器中是否有 5 这个元素\tvector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5);\tif (it == v.end()) \t&#123;\t\tcout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;\t&#125;\telse \t&#123;\t\tcout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;\t&#125;&#125;class Person &#123;public:\tPerson(string name, int age) \t&#123;\t\tthis-&gt;m_Name = name;\t\tthis-&gt;m_Age = age;\t&#125;\t//重载==\tbool operator==(const Person&amp; p) \t&#123;\t\tif (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) \t\t&#123;\t\t\treturn true;\t\t&#125;\t\treturn false;\t&#125;public:\tstring m_Name;\tint m_Age;&#125;;void test02() &#123;\tvector&lt;Person&gt; v;\t//创建数据\tPerson p1(&quot;aaa&quot;, 10);\tPerson p2(&quot;bbb&quot;, 20);\tPerson p3(&quot;ccc&quot;, 30);\tPerson p4(&quot;ddd&quot;, 40);\tv.push_back(p1);\tv.push_back(p2);\tv.push_back(p3);\tv.push_back(p4);\tvector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2);\tif (it == v.end()) \t&#123;\t\tcout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;\t&#125;\telse \t&#123;\t\tcout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;\t&#125;&#125;\n\n总结： 利用find可以在容器中找指定的元素，返回值是迭代器\n2.2 find_if功能描述：\n\n按条件查找元素\n\n函数原型：\n\nfind_if(iterator beg, iterator end, _Pred);  \n&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; _Pred 函数或者谓词（返回bool类型的仿函数）\n\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;//内置数据类型class GreaterFive&#123;public:\tbool operator()(int val)\t&#123;\t\treturn val &gt; 5;\t&#125;&#125;;void test01() &#123;\tvector&lt;int&gt; v;\tfor (int i = 0; i &lt; 10; i++) &#123;\t\tv.push_back(i + 1);\t&#125;\tvector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());\tif (it == v.end()) &#123;\t\tcout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;\t&#125;\telse &#123;\t\tcout &lt;&lt; &quot;找到大于5的数字:&quot; &lt;&lt; *it &lt;&lt; endl;\t&#125;&#125;//自定义数据类型class Person &#123;public:\tPerson(string name, int age)\t&#123;\t\tthis-&gt;m_Name = name;\t\tthis-&gt;m_Age = age;\t&#125;public:\tstring m_Name;\tint m_Age;&#125;;class Greater20&#123;public:\tbool operator()(Person &amp;p)\t&#123;\t\treturn p.m_Age &gt; 20;\t&#125;&#125;;void test02() &#123;\tvector&lt;Person&gt; v;\t//创建数据\tPerson p1(&quot;aaa&quot;, 10);\tPerson p2(&quot;bbb&quot;, 20);\tPerson p3(&quot;ccc&quot;, 30);\tPerson p4(&quot;ddd&quot;, 40);\tv.push_back(p1);\tv.push_back(p2);\tv.push_back(p3);\tv.push_back(p4);\tvector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20());\tif (it == v.end())\t&#123;\t\tcout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;\t&#125;&#125;int main() &#123;\t//test01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略\n2.3 adjacent_find功能描述：\n\n查找相邻重复元素\n\n函数原型：\n\nadjacent_find(iterator beg, iterator end);  \n&#x2F;&#x2F; 查找相邻重复元素,返回相邻元素的第一个位置的迭代器\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n​\n\n\n示例：\n1234567891011121314151617181920212223#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123;\tvector&lt;int&gt; v;\tv.push_back(1);\tv.push_back(2);\tv.push_back(5);\tv.push_back(2);\tv.push_back(4);\tv.push_back(4);\tv.push_back(3);\t//查找相邻重复元素\tvector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end());\tif (it == v.end()) &#123;\t\tcout &lt;&lt; &quot;找不到!&quot; &lt;&lt; endl;\t&#125;\telse &#123;\t\tcout &lt;&lt; &quot;找到相邻重复元素为:&quot; &lt;&lt; *it &lt;&lt; endl;\t&#125;&#125;\n\n总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法\n2.4 binary_search功能描述：\n\n查找指定元素是否存在\n\n函数原型：\n\nbool binary_search(iterator beg, iterator end, value);  \n&#x2F;&#x2F; 查找指定的元素，查到 返回true  否则false\n&#x2F;&#x2F; 注意: 在无序序列中不可用\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; value 查找的元素\n\n\n示例：\n12345678910111213141516171819202122232425262728293031#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123;\tvector&lt;int&gt;v;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tv.push_back(i);\t&#125;\t//二分查找\tbool ret = binary_search(v.begin(), v.end(),2);\tif (ret)\t&#123;\t\tcout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;\t&#125;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列\n2.5 count功能描述：\n\n统计元素个数\n\n函数原型：\n\ncount(iterator beg, iterator end, value);  \n&#x2F;&#x2F; 统计元素出现次数\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; value 统计的元素\n\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;algorithm&gt;#include &lt;vector&gt;//内置数据类型void test01()&#123;\tvector&lt;int&gt; v;\tv.push_back(1);\tv.push_back(2);\tv.push_back(4);\tv.push_back(5);\tv.push_back(3);\tv.push_back(4);\tv.push_back(4);\tint num = count(v.begin(), v.end(), 4);\tcout &lt;&lt; &quot;4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;&#125;//自定义数据类型class Person&#123;public:\tPerson(string name, int age)\t&#123;\t\tthis-&gt;m_Name = name;\t\tthis-&gt;m_Age = age;\t&#125;\tbool operator==(const Person &amp; p)\t&#123;\t\tif (this-&gt;m_Age == p.m_Age)\t\t&#123;\t\t\treturn true;\t\t&#125;\t\telse\t\t&#123;\t\t\treturn false;\t\t&#125;\t&#125;\tstring m_Name;\tint m_Age;&#125;;void test02()&#123;\tvector&lt;Person&gt; v;\tPerson p1(&quot;刘备&quot;, 35);\tPerson p2(&quot;关羽&quot;, 35);\tPerson p3(&quot;张飞&quot;, 35);\tPerson p4(&quot;赵云&quot;, 30);\tPerson p5(&quot;曹操&quot;, 25);\tv.push_back(p1);\tv.push_back(p2);\tv.push_back(p3);\tv.push_back(p4);\tv.push_back(p5);        Person p(&quot;诸葛亮&quot;,35);\tint num = count(v.begin(), v.end(), p);\tcout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;\t//test01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结： 统计自定义数据类型时候，需要配合重载 operator==\n2.6 count_if功能描述：\n\n按条件统计元素个数\n\n函数原型：\n\ncount_if(iterator beg, iterator end, _Pred);  \n&#x2F;&#x2F; 按条件统计元素出现次数\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; _Pred 谓词\n​\n\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;algorithm&gt;#include &lt;vector&gt;class Greater4&#123;public:\tbool operator()(int val)\t&#123;\t\treturn val &gt;= 4;\t&#125;&#125;;//内置数据类型void test01()&#123;\tvector&lt;int&gt; v;\tv.push_back(1);\tv.push_back(2);\tv.push_back(4);\tv.push_back(5);\tv.push_back(3);\tv.push_back(4);\tv.push_back(4);\tint num = count_if(v.begin(), v.end(), Greater4());\tcout &lt;&lt; &quot;大于4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;&#125;//自定义数据类型class Person&#123;public:\tPerson(string name, int age)\t&#123;\t\tthis-&gt;m_Name = name;\t\tthis-&gt;m_Age = age;\t&#125;\tstring m_Name;\tint m_Age;&#125;;class AgeLess35&#123;public:\tbool operator()(const Person &amp;p)\t&#123;\t\treturn p.m_Age &lt; 35;\t&#125;&#125;;void test02()&#123;\tvector&lt;Person&gt; v;\tPerson p1(&quot;刘备&quot;, 35);\tPerson p2(&quot;关羽&quot;, 35);\tPerson p3(&quot;张飞&quot;, 35);\tPerson p4(&quot;赵云&quot;, 30);\tPerson p5(&quot;曹操&quot;, 25);\tv.push_back(p1);\tv.push_back(p2);\tv.push_back(p3);\tv.push_back(p4);\tv.push_back(p5);\tint num = count_if(v.begin(), v.end(), AgeLess35());\tcout &lt;&lt; &quot;小于35岁的个数：&quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;\t//test01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：按值统计用count，按条件统计用count_if\n3 常用排序算法学习目标：\n\n掌握常用的排序算法\n\n算法简介：\n\nsort             &#x2F;&#x2F;对容器内元素进行排序\nrandom_shuffle   &#x2F;&#x2F;洗牌   指定范围内的元素随机调整次序\nmerge            &#x2F;&#x2F; 容器元素合并，并存储到另一容器中\nreverse       &#x2F;&#x2F; 反转指定范围的元素\n\n3.1 sort功能描述：\n\n对容器内元素进行排序\n\n函数原型：\n\nsort(iterator beg, iterator end, _Pred);  \n&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置\n&#x2F;&#x2F;  beg    开始迭代器\n&#x2F;&#x2F;  end    结束迭代器\n&#x2F;&#x2F; _Pred  谓词\n\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435#include &lt;algorithm&gt;#include &lt;vector&gt;void myPrint(int val)&#123;\tcout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;void test01() &#123;\tvector&lt;int&gt; v;\tv.push_back(10);\tv.push_back(30);\tv.push_back(50);\tv.push_back(20);\tv.push_back(40);\t//sort默认从小到大排序\tsort(v.begin(), v.end());\tfor_each(v.begin(), v.end(), myPrint);\tcout &lt;&lt; endl;\t//从大到小排序\tsort(v.begin(), v.end(), greater&lt;int&gt;());\tfor_each(v.begin(), v.end(), myPrint);\tcout &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：sort属于开发中最常用的算法之一，需熟练掌握\n3.2 random_shuffle功能描述：\n\n洗牌   指定范围内的元素随机调整次序\n\n函数原型：\n\nrandom_shuffle(iterator beg, iterator end);  \n&#x2F;&#x2F; 指定范围内的元素随机调整次序\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n​\n\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;ctime&gt;class myPrint&#123;public:\tvoid operator()(int val)\t&#123;\t\tcout &lt;&lt; val &lt;&lt; &quot; &quot;;\t&#125;&#125;;void test01()&#123;\tsrand((unsigned int)time(NULL));\tvector&lt;int&gt; v;\tfor(int i = 0 ; i &lt; 10;i++)\t&#123;\t\tv.push_back(i);\t&#125;\tfor_each(v.begin(), v.end(), myPrint());\tcout &lt;&lt; endl;\t//打乱顺序\trandom_shuffle(v.begin(), v.end());\tfor_each(v.begin(), v.end(), myPrint());\tcout &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：random_shuffle洗牌算法比较实用，使用时记得加随机数种子\n3.3 merge功能描述：\n\n两个容器元素合并，并存储到另一容器中\n\n函数原型：\n\nmerge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  \n&#x2F;&#x2F; 容器元素合并，并存储到另一容器中\n&#x2F;&#x2F; 注意: 两个容器必须是有序的\n&#x2F;&#x2F; beg1   容器1开始迭代器&#x2F;&#x2F; end1   容器1结束迭代器&#x2F;&#x2F; beg2   容器2开始迭代器&#x2F;&#x2F; end2   容器2结束迭代器&#x2F;&#x2F; dest    目标容器开始迭代器\n​\n\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:\tvoid operator()(int val)\t&#123;\t\tcout &lt;&lt; val &lt;&lt; &quot; &quot;;\t&#125;&#125;;void test01()&#123;\tvector&lt;int&gt; v1;\tvector&lt;int&gt; v2;\tfor (int i = 0; i &lt; 10 ; i++)     &#123;\t\tv1.push_back(i);\t\tv2.push_back(i + 1);\t&#125;\tvector&lt;int&gt; vtarget;\t//目标容器需要提前开辟空间\tvtarget.resize(v1.size() + v2.size());\t//合并  需要两个有序序列\tmerge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());\tfor_each(vtarget.begin(), vtarget.end(), myPrint());\tcout &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：merge合并的两个容器必须的有序序列\n3.4 reverse功能描述：\n\n将容器内元素进行反转\n\n函数原型：\n\nreverse(iterator beg, iterator end);  \n&#x2F;&#x2F; 反转指定范围的元素\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n​\n\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:\tvoid operator()(int val)\t&#123;\t\tcout &lt;&lt; val &lt;&lt; &quot; &quot;;\t&#125;&#125;;void test01()&#123;\tvector&lt;int&gt; v;\tv.push_back(10);\tv.push_back(30);\tv.push_back(50);\tv.push_back(20);\tv.push_back(40);\tcout &lt;&lt; &quot;反转前： &quot; &lt;&lt; endl;\tfor_each(v.begin(), v.end(), myPrint());\tcout &lt;&lt; endl;\tcout &lt;&lt; &quot;反转后： &quot; &lt;&lt; endl;\treverse(v.begin(), v.end());\tfor_each(v.begin(), v.end(), myPrint());\tcout &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：reverse反转区间内元素，面试题可能涉及到\n4 常用拷贝和替换算法学习目标：\n\n掌握常用的拷贝和替换算法\n\n算法简介：\n\ncopy                      &#x2F;&#x2F; 容器内指定范围的元素拷贝到另一容器中\nreplace                &#x2F;&#x2F; 将容器内指定范围的旧元素修改为新元素\nreplace_if           &#x2F;&#x2F; 容器内指定范围满足条件的元素替换为新元素\nswap                     &#x2F;&#x2F; 互换两个容器的元素\n\n4.1 copy功能描述：\n\n容器内指定范围的元素拷贝到另一容器中\n\n函数原型：\n\ncopy(iterator beg, iterator end, iterator dest);  \n&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置\n&#x2F;&#x2F; beg  开始迭代器\n&#x2F;&#x2F; end  结束迭代器\n&#x2F;&#x2F; dest 目标起始迭代器\n\n\n示例：\n12345678910111213141516171819202122232425262728293031323334#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:\tvoid operator()(int val)\t&#123;\t\tcout &lt;&lt; val &lt;&lt; &quot; &quot;;\t&#125;&#125;;void test01()&#123;\tvector&lt;int&gt; v1;\tfor (int i = 0; i &lt; 10; i++) &#123;\t\tv1.push_back(i + 1);\t&#125;\tvector&lt;int&gt; v2;\tv2.resize(v1.size());\tcopy(v1.begin(), v1.end(), v2.begin());\tfor_each(v2.begin(), v2.end(), myPrint());\tcout &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：利用copy算法在拷贝时，目标容器记得提前开辟空间\n4.2 replace功能描述：\n\n将容器内指定范围的旧元素修改为新元素\n\n函数原型：\n\nreplace(iterator beg, iterator end, oldvalue, newvalue);  \n&#x2F;&#x2F; 将区间内旧元素 替换成 新元素\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; oldvalue 旧元素\n&#x2F;&#x2F; newvalue 新元素\n\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:\tvoid operator()(int val)\t&#123;\t\tcout &lt;&lt; val &lt;&lt; &quot; &quot;;\t&#125;&#125;;void test01()&#123;\tvector&lt;int&gt; v;\tv.push_back(20);\tv.push_back(30);\tv.push_back(20);\tv.push_back(40);\tv.push_back(50);\tv.push_back(10);\tv.push_back(20);\tcout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;\tfor_each(v.begin(), v.end(), myPrint());\tcout &lt;&lt; endl;\t//将容器中的20 替换成 2000\tcout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;\treplace(v.begin(), v.end(), 20,2000);\tfor_each(v.begin(), v.end(), myPrint());\tcout &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：replace会替换区间内满足条件的元素\n4.3 replace_if功能描述:  \n\n将区间内满足条件的元素，替换成指定元素\n\n函数原型：\n\nreplace_if(iterator beg, iterator end, _pred, newvalue);  \n&#x2F;&#x2F; 按条件替换元素，满足条件的替换成指定元素\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; _pred 谓词\n&#x2F;&#x2F; newvalue 替换的新元素\n\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:\tvoid operator()(int val)\t&#123;\t\tcout &lt;&lt; val &lt;&lt; &quot; &quot;;\t&#125;&#125;;class ReplaceGreater30&#123;public:\tbool operator()(int val)\t&#123;\t\treturn val &gt;= 30;\t&#125;&#125;;void test01()&#123;\tvector&lt;int&gt; v;\tv.push_back(20);\tv.push_back(30);\tv.push_back(20);\tv.push_back(40);\tv.push_back(50);\tv.push_back(10);\tv.push_back(20);\tcout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;\tfor_each(v.begin(), v.end(), myPrint());\tcout &lt;&lt; endl;\t//将容器中大于等于的30 替换成 3000\tcout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;\treplace_if(v.begin(), v.end(), ReplaceGreater30(), 3000);\tfor_each(v.begin(), v.end(), myPrint());\tcout &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：replace_if按条件查找，可以利用仿函数灵活筛选满足的条件\n4.4 swap功能描述：\n\n互换两个容器的元素\n\n函数原型：\n\nswap(container c1, container c2);  \n&#x2F;&#x2F; 互换两个容器的元素\n&#x2F;&#x2F; c1容器1\n&#x2F;&#x2F; c2容器2\n​\n\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public:\tvoid operator()(int val)\t&#123;\t\tcout &lt;&lt; val &lt;&lt; &quot; &quot;;\t&#125;&#125;;void test01()&#123;\tvector&lt;int&gt; v1;\tvector&lt;int&gt; v2;\tfor (int i = 0; i &lt; 10; i++) &#123;\t\tv1.push_back(i);\t\tv2.push_back(i+100);\t&#125;\tcout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;\tfor_each(v1.begin(), v1.end(), myPrint());\tcout &lt;&lt; endl;\tfor_each(v2.begin(), v2.end(), myPrint());\tcout &lt;&lt; endl;\tcout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;\tswap(v1, v2);\tfor_each(v1.begin(), v1.end(), myPrint());\tcout &lt;&lt; endl;\tfor_each(v2.begin(), v2.end(), myPrint());\tcout &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：swap交换容器时，注意交换的容器要同种类型\n5 常用算术生成算法学习目标：\n\n掌握常用的算术生成算法\n\n注意：\n\n算术生成算法属于小型算法，使用时包含的头文件为 #include &lt;numeric&gt;\n\n算法简介：\n\naccumulate      &#x2F;&#x2F; 计算容器元素累计总和\n\nfill                 &#x2F;&#x2F; 向容器中添加元素\n​\n\n\n5.1 accumulate功能描述：\n\n计算区间内 容器元素累计总和\n\n函数原型：\n\naccumulate(iterator beg, iterator end, value);  \n&#x2F;&#x2F; 计算容器元素累计总和\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; value 起始值\n\n\n示例：\n12345678910111213141516171819202122#include &lt;numeric&gt;#include &lt;vector&gt;void test01()&#123;\tvector&lt;int&gt; v;\tfor (int i = 0; i &lt;= 100; i++) &#123;\t\tv.push_back(i);\t&#125;\tint total = accumulate(v.begin(), v.end(), 0);\tcout &lt;&lt; &quot;total = &quot; &lt;&lt; total &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：accumulate使用时头文件注意是 numeric，这个算法很实用\n5.2 fill功能描述：\n\n向容器中填充指定的元素\n\n函数原型：\n\nfill(iterator beg, iterator end, value);  \n&#x2F;&#x2F; 向容器中填充元素\n&#x2F;&#x2F; beg 开始迭代器\n&#x2F;&#x2F; end 结束迭代器\n&#x2F;&#x2F; value 填充的值\n\n\n示例：\n123456789101112131415161718192021222324252627282930313233#include &lt;numeric&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:\tvoid operator()(int val)\t&#123;\t\tcout &lt;&lt; val &lt;&lt; &quot; &quot;;\t&#125;&#125;;void test01()&#123;\tvector&lt;int&gt; v;\tv.resize(10);\t//填充\tfill(v.begin(), v.end(), 100);\tfor_each(v.begin(), v.end(), myPrint());\tcout &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：利用fill可以将容器区间内元素填充为 指定的值\n6 常用集合算法学习目标：\n\n掌握常用的集合算法\n\n算法简介：\n\nset_intersection          &#x2F;&#x2F; 求两个容器的交集\n\nset_union                       &#x2F;&#x2F; 求两个容器的并集\n\nset_difference               &#x2F;&#x2F; 求两个容器的差集\n​\n\n\n6.1 set_intersection功能描述：\n\n求两个容器的交集\n\n函数原型：\n\nset_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  \n&#x2F;&#x2F; 求两个集合的交集\n&#x2F;&#x2F; 注意:两个集合必须是有序序列\n&#x2F;&#x2F; beg1 容器1开始迭代器&#x2F;&#x2F; end1 容器1结束迭代器&#x2F;&#x2F; beg2 容器2开始迭代器&#x2F;&#x2F; end2 容器2结束迭代器&#x2F;&#x2F; dest 目标容器开始迭代器\n\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:\tvoid operator()(int val)\t&#123;\t\tcout &lt;&lt; val &lt;&lt; &quot; &quot;;\t&#125;&#125;;void test01()&#123;\tvector&lt;int&gt; v1;\tvector&lt;int&gt; v2;\tfor (int i = 0; i &lt; 10; i++)    &#123;\t\tv1.push_back(i);\t\tv2.push_back(i+5);\t&#125;\tvector&lt;int&gt; vTarget;\t//取两个里面较小的值给目标容器开辟空间\tvTarget.resize(min(v1.size(), v2.size()));\t//返回目标容器的最后一个元素的迭代器地址\tvector&lt;int&gt;::iterator itEnd =         set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());\tfor_each(vTarget.begin(), itEnd, myPrint());\tcout &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结： \n\n求交集的两个集合必须的有序序列\n目标容器开辟空间需要从两个容器中取小值\nset_intersection返回值既是交集中最后一个元素的位置\n\n6.2 set_union功能描述：\n\n求两个集合的并集\n\n函数原型：\n\nset_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  \n&#x2F;&#x2F; 求两个集合的并集\n&#x2F;&#x2F; 注意:两个集合必须是有序序列\n&#x2F;&#x2F; beg1 容器1开始迭代器&#x2F;&#x2F; end1 容器1结束迭代器&#x2F;&#x2F; beg2 容器2开始迭代器&#x2F;&#x2F; end2 容器2结束迭代器&#x2F;&#x2F; dest 目标容器开始迭代器\n​\n\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:\tvoid operator()(int val)\t&#123;\t\tcout &lt;&lt; val &lt;&lt; &quot; &quot;;\t&#125;&#125;;void test01()&#123;\tvector&lt;int&gt; v1;\tvector&lt;int&gt; v2;\tfor (int i = 0; i &lt; 10; i++) &#123;\t\tv1.push_back(i);\t\tv2.push_back(i+5);\t&#125;\tvector&lt;int&gt; vTarget;\t//取两个容器的和给目标容器开辟空间\tvTarget.resize(v1.size() + v2.size());\t//返回目标容器的最后一个元素的迭代器地址\tvector&lt;int&gt;::iterator itEnd =         set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());\tfor_each(vTarget.begin(), itEnd, myPrint());\tcout &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结： \n\n求并集的两个集合必须的有序序列\n目标容器开辟空间需要两个容器相加\nset_union返回值既是并集中最后一个元素的位置\n\n6.3  set_difference功能描述：\n\n求两个集合的差集\n\n函数原型：\n\nset_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  \n&#x2F;&#x2F; 求两个集合的差集\n&#x2F;&#x2F; 注意:两个集合必须是有序序列\n&#x2F;&#x2F; beg1 容器1开始迭代器&#x2F;&#x2F; end1 容器1结束迭代器&#x2F;&#x2F; beg2 容器2开始迭代器&#x2F;&#x2F; end2 容器2结束迭代器&#x2F;&#x2F; dest 目标容器开始迭代器\n​\n\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public:\tvoid operator()(int val)\t&#123;\t\tcout &lt;&lt; val &lt;&lt; &quot; &quot;;\t&#125;&#125;;void test01()&#123;\tvector&lt;int&gt; v1;\tvector&lt;int&gt; v2;\tfor (int i = 0; i &lt; 10; i++) &#123;\t\tv1.push_back(i);\t\tv2.push_back(i+5);\t&#125;\tvector&lt;int&gt; vTarget;\t//取两个里面较大的值给目标容器开辟空间\tvTarget.resize( max(v1.size() , v2.size()));\t//返回目标容器的最后一个元素的迭代器地址\tcout &lt;&lt; &quot;v1与v2的差集为： &quot; &lt;&lt; endl;\tvector&lt;int&gt;::iterator itEnd =         set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());\tfor_each(vTarget.begin(), itEnd, myPrint());\tcout &lt;&lt; endl;\tcout &lt;&lt; &quot;v2与v1的差集为： &quot; &lt;&lt; endl;\titEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());\tfor_each(vTarget.begin(), itEnd, myPrint());\tcout &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结： \n\n求差集的两个集合必须的有序序列\n目标容器开辟空间需要从两个容器取较大值\nset_difference返回值既是差集中最后一个元素的位置\n\n","slug":"STL常用算法","date":"2021-07-24T02:49:00.000Z","categories_index":"STL","tags_index":"STL,算法,遍历,查找,排序,集合算法","author_index":"kiyose408"},{"id":"59f4fe88c44206beeb3d56cc24c7cea8","title":"C++模版","content":"1 模板的概念模板就是建立通用的模具，大大提高复用性\n模板的特点：\n\n模板不可以直接使用，它只是一个框架\n模板的通用并不是万能的\n\n2 函数模板\nC++另一种编程思想称为 &#x3D;&#x3D;泛型编程&#x3D;&#x3D; ，主要利用的技术就是模板\n\nC++提供两种模板机制:函数模板和类模板 \n2.1 函数模板语法\n\n函数模板作用：\n建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。\n语法： \n12template&lt;typename T&gt;函数声明或定义\n\n解释：\ntemplate  —  声明创建模板\ntypename  — 表面其后面的符号是一种数据类型，可以用class代替\nT    —   通用的数据类型，名称可以替换，通常为大写字母\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//交换整型函数void swapInt(int&amp; a, int&amp; b) &#123;\tint temp = a;\ta = b;\tb = temp;&#125;//交换浮点型函数void swapDouble(double&amp; a, double&amp; b) &#123;\tdouble temp = a;\ta = b;\tb = temp;&#125;//利用模板提供通用的交换函数template&lt;typename T&gt;void mySwap(T&amp; a, T&amp; b)&#123;\tT temp = a;\ta = b;\tb = temp;&#125;void test01()&#123;\tint a = 10;\tint b = 20;\t\t//swapInt(a, b);\t//利用模板实现交换\t//1、自动类型推导\tmySwap(a, b);\t//2、显示指定类型\tmySwap&lt;int&gt;(a, b);\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n函数模板利用关键字 template\n\n使用函数模板有两种方式：自动类型推导、显示指定类型\n\n模板的目的是为了提高复用性，将类型参数化\n2.2 函数模板注意事项\n\n注意事项：\n\n自动类型推导，必须推导出一致的数据类型T,才可以使用\n\n模板必须要确定出T的数据类型，才可以使用\n\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344//利用模板提供通用的交换函数template&lt;class T&gt;void mySwap(T&amp; a, T&amp; b)&#123;\tT temp = a;\ta = b;\tb = temp;&#125;// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用void test01()&#123;\tint a = 10;\tint b = 20;\tchar c = &#x27;c&#x27;;\tmySwap(a, b); // 正确，可以推导出一致的T\t//mySwap(a, c); // 错误，推导不出一致的T类型&#125;// 2、模板必须要确定出T的数据类型，才可以使用template&lt;class T&gt;void func()&#123;\tcout &lt;&lt; &quot;func 调用&quot; &lt;&lt; endl;&#125;void test02()&#123;\t//func(); //错误，模板不能独立使用，必须确定出T的类型\tfunc&lt;int&gt;(); //利用显示指定类型的方式，给T一个类型，才可以使用该模板&#125;int main() &#123;\ttest01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型\n2.3 函数模板案例\n\n案例描述：\n\n利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序\n排序规则从大到小，排序算法为选择排序\n分别利用char数组和int数组进行测试\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//交换的函数模板template&lt;typename T&gt;void mySwap(T &amp;a, T&amp;b)&#123;\tT temp = a;\ta = b;\tb = temp;&#125;template&lt;class T&gt; // 也可以替换成typename//利用选择排序，进行对数组从大到小的排序void mySort(T arr[], int len)&#123;\tfor (int i = 0; i &lt; len; i++)\t&#123;\t\tint max = i; //最大数的下标\t\tfor (int j = i + 1; j &lt; len; j++)\t\t&#123;\t\t\tif (arr[max] &lt; arr[j])\t\t\t&#123;\t\t\t\tmax = j;\t\t\t&#125;\t\t&#125;\t\tif (max != i) //如果最大数的下标不是i，交换两者\t\t&#123;\t\t\tmySwap(arr[max], arr[i]);\t\t&#125;\t&#125;&#125;template&lt;typename T&gt;void printArray(T arr[], int len) &#123;\tfor (int i = 0; i &lt; len; i++) &#123;\t\tcout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;void test01()&#123;\t//测试char数组\tchar charArr[] = &quot;bdcfeagh&quot;;\tint num = sizeof(charArr) / sizeof(char);\tmySort(charArr, num);\tprintArray(charArr, num);&#125;void test02()&#123;\t//测试int数组\tint intArr[] = &#123; 7, 5, 8, 1, 3, 9, 2, 4, 6 &#125;;\tint num = sizeof(intArr) / sizeof(int);\tmySort(intArr, num);\tprintArray(intArr, num);&#125;int main() &#123;\ttest01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：模板可以提高代码复用，需要熟练掌握\n2.4 普通函数与函数模板的区别普通函数与函数模板区别：\n\n普通函数调用时可以发生自动类型转换（隐式类型转换）\n函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换\n如果利用显示指定类型的方式，可以发生隐式类型转换\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435//普通函数int myAdd01(int a, int b)&#123;\treturn a + b;&#125;//函数模板template&lt;class T&gt;T myAdd02(T a, T b)  &#123;\treturn a + b;&#125;//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换void test01()&#123;\tint a = 10;\tint b = 20;\tchar c = &#x27;c&#x27;;\t\tcout &lt;&lt; myAdd01(a, c) &lt;&lt; endl; //正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99\t//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换\tmyAdd02&lt;int&gt;(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T\n2.5 普通函数与函数模板的调用规则调用规则如下：\n\n如果函数模板和普通函数都可以实现，优先调用普通函数\n可以通过空模板参数列表来强制调用函数模板\n函数模板也可以发生重载\n如果函数模板可以产生更好的匹配,优先调用函数模板\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//普通函数与函数模板调用规则void myPrint(int a, int b)&#123;\tcout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;&#125;template&lt;typename T&gt;void myPrint(T a, T b) &#123; \tcout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;&#125;template&lt;typename T&gt;void myPrint(T a, T b, T c) &#123; \tcout &lt;&lt; &quot;调用重载的模板&quot; &lt;&lt; endl; &#125;void test01()&#123;\t//1、如果函数模板和普通函数都可以实现，优先调用普通函数\t// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到\tint a = 10;\tint b = 20;\tmyPrint(a, b); //调用普通函数\t//2、可以通过空模板参数列表来强制调用函数模板\tmyPrint&lt;&gt;(a, b); //调用函数模板\t//3、函数模板也可以发生重载\tint c = 30;\tmyPrint(a, b, c); //调用重载的函数模板\t//4、 如果函数模板可以产生更好的匹配,优先调用函数模板\tchar c1 = &#x27;a&#x27;;\tchar c2 = &#x27;b&#x27;;\tmyPrint(c1, c2); //调用函数模板&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性\n2.6 模板的局限性局限性：\n\n模板的通用性并不是万能的\n\n例如：\n12345template&lt;class T&gt;void f(T a, T b)&#123;    \ta = b;   &#125;\n\n在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了\n再例如：\n12345template&lt;class T&gt;void f(T a, T b)&#123;    \tif(a &gt; b) &#123; ... &#125;   &#125;\n\n在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行\n因此C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;using namespace std;#include &lt;string&gt;class Person&#123;public:\tPerson(string name, int age)\t&#123;\t\tthis-&gt;m_Name = name;\t\tthis-&gt;m_Age = age;\t&#125;\tstring m_Name;\tint m_Age;&#125;;//普通函数模板template&lt;class T&gt;bool myCompare(T&amp; a, T&amp; b)&#123;\tif (a == b)\t&#123;\t\treturn true;\t&#125;\telse\t&#123;\t\treturn false;\t&#125;&#125;//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型//具体化优先于常规模板template&lt;&gt; bool myCompare(Person &amp;p1, Person &amp;p2)&#123;\tif ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)\t&#123;\t\treturn true;\t&#125;\telse\t&#123;\t\treturn false;\t&#125;&#125;void test01()&#123;\tint a = 10;\tint b = 20;\t//内置数据类型可以直接使用通用的函数模板\tbool ret = myCompare(a, b);\tif (ret)\t&#123;\t\tcout &lt;&lt; &quot;a == b &quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;a != b &quot; &lt;&lt; endl;\t&#125;&#125;void test02()&#123;\tPerson p1(&quot;Tom&quot;, 10);\tPerson p2(&quot;Tom&quot;, 10);\t//自定义数据类型，不会调用普通的函数模板\t//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型\tbool ret = myCompare(p1, p2);\tif (ret)\t&#123;\t\tcout &lt;&lt; &quot;p1 == p2 &quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;p1 != p2 &quot; &lt;&lt; endl;\t&#125;&#125;int main() &#123;\ttest01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n利用具体化的模板，可以解决自定义类型的通用化\n学习模板并不是为了写模板，而是在STL能够运用系统提供的模板\n\n3 类模板3.1 类模板语法类模板作用：\n\n建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。\n\n语法： \n12template&lt;typename T&gt;类\n\n解释：\ntemplate  —  声明创建模板\ntypename  — 表面其后面的符号是一种数据类型，可以用class代替\nT    —   通用的数据类型，名称可以替换，通常为大写字母\n示例：\n1234567891011121314151617181920212223242526272829303132333435#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType&gt; class Person&#123;public:\tPerson(NameType name, AgeType age)\t&#123;\t\tthis-&gt;mName = name;\t\tthis-&gt;mAge = age;\t&#125;\tvoid showPerson()\t&#123;\t\tcout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;\t&#125;public:\tNameType mName;\tAgeType mAge;&#125;;void test01()&#123;\t// 指定NameType 为string类型，AgeType 为 int类型\tPerson&lt;string, int&gt;P1(&quot;孙悟空&quot;, 999);\tP1.showPerson();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板\n3.2 类模板与函数模板区别类模板与函数模板区别主要有两点：\n\n类模板没有自动类型推导的使用方式\n类模板在模板参数列表中可以有默认参数\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType = int&gt; class Person&#123;public:\tPerson(NameType name, AgeType age)\t&#123;\t\tthis-&gt;mName = name;\t\tthis-&gt;mAge = age;\t&#125;\tvoid showPerson()\t&#123;\t\tcout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;\t&#125;public:\tNameType mName;\tAgeType mAge;&#125;;//1、类模板没有自动类型推导的使用方式void test01()&#123;\t// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导\tPerson &lt;string ,int&gt;p(&quot;孙悟空&quot;, 1000); //必须使用显示指定类型的方式，使用类模板\tp.showPerson();&#125;//2、类模板在模板参数列表中可以有默认参数void test02()&#123;\tPerson &lt;string&gt; p(&quot;猪八戒&quot;, 999); //类模板中的模板参数列表 可以指定默认参数\tp.showPerson();&#125;int main() &#123;\ttest01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n类模板使用只能用显示指定类型方式\n类模板中的模板参数列表可以有默认参数\n\n3.3 类模板中成员函数创建时机类模板中成员函数和普通类中成员函数创建时机是有区别的：\n\n普通类中的成员函数一开始就可以创建\n类模板中的成员函数在调用时才创建\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Person1&#123;public:\tvoid showPerson1()\t&#123;\t\tcout &lt;&lt; &quot;Person1 show&quot; &lt;&lt; endl;\t&#125;&#125;;class Person2&#123;public:\tvoid showPerson2()\t&#123;\t\tcout &lt;&lt; &quot;Person2 show&quot; &lt;&lt; endl;\t&#125;&#125;;template&lt;class T&gt;class MyClass&#123;public:\tT obj;\t//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成\tvoid fun1() &#123; obj.showPerson1(); &#125;\tvoid fun2() &#123; obj.showPerson2(); &#125;&#125;;void test01()&#123;\tMyClass&lt;Person1&gt; m;\t\tm.fun1();\t//m.fun2();//编译会出错，说明函数调用才会去创建成员函数&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建\n3.4 类模板对象做函数参数学习目标：\n\n类模板实例化出的对象，向函数传参的方式\n\n一共有三种传入方式：\n\n指定传入的类型   — 直接显示对象的数据类型\n参数模板化           — 将对象中的参数变为模板进行传递\n整个类模板化       — 将这个对象类型 模板化进行传递\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType = int&gt; class Person&#123;public:\tPerson(NameType name, AgeType age)\t&#123;\t\tthis-&gt;mName = name;\t\tthis-&gt;mAge = age;\t&#125;\tvoid showPerson()\t&#123;\t\tcout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;\t&#125;public:\tNameType mName;\tAgeType mAge;&#125;;//1、指定传入的类型void printPerson1(Person&lt;string, int&gt; &amp;p) &#123;\tp.showPerson();&#125;void test01()&#123;\tPerson &lt;string, int &gt;p(&quot;孙悟空&quot;, 100);\tprintPerson1(p);&#125;//2、参数模板化template &lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt;&amp;p)&#123;\tp.showPerson();\tcout &lt;&lt; &quot;T1的类型为： &quot; &lt;&lt; typeid(T1).name() &lt;&lt; endl;\tcout &lt;&lt; &quot;T2的类型为： &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl;&#125;void test02()&#123;\tPerson &lt;string, int &gt;p(&quot;猪八戒&quot;, 90);\tprintPerson2(p);&#125;//3、整个类模板化template&lt;class T&gt;void printPerson3(T &amp; p)&#123;\tcout &lt;&lt; &quot;T的类型为： &quot; &lt;&lt; typeid(T).name() &lt;&lt; endl;\tp.showPerson();&#125;void test03()&#123;\tPerson &lt;string, int &gt;p(&quot;唐僧&quot;, 30);\tprintPerson3(p);&#125;int main() &#123;\ttest01();\ttest02();\ttest03();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n通过类模板创建的对象，可以有三种方式向函数中进行传参\n\n使用比较广泛是第一种：指定传入的类型\n3.5 类模板与继承\n\n当类模板碰到继承时，需要注意一下几点：\n\n当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型\n如果不指定，编译器无法给子类分配内存\n如果想灵活指定出父类中T的类型，子类也需变为类模板\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243template&lt;class T&gt;class Base&#123;\tT m;&#125;;//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承class Son :public Base&lt;int&gt; //必须指定一个类型&#123;&#125;;void test01()&#123;\tSon c;&#125;//类模板继承类模板 ,可以用T2指定父类中的T类型template&lt;class T1, class T2&gt;class Son2 :public Base&lt;T2&gt;&#123;public:\tSon2()\t&#123;\t\tcout &lt;&lt; typeid(T1).name() &lt;&lt; endl;\t\tcout &lt;&lt; typeid(T2).name() &lt;&lt; endl;\t&#125;&#125;;void test02()&#123;\tSon2&lt;int, char&gt; child1;&#125;int main() &#123;\ttest01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：如果父类是类模板，子类需要指定出父类中T的数据类型\n3.6 类模板成员函数类外实现学习目标：能够掌握类模板中的成员函数类外实现\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;string&gt;//类模板中成员函数类外实现template&lt;class T1, class T2&gt;class Person &#123;public:\t//成员函数类内声明\tPerson(T1 name, T2 age);\tvoid showPerson();public:\tT1 m_Name;\tT2 m_Age;&#125;;//构造函数 类外实现template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;\tthis-&gt;m_Name = name;\tthis-&gt;m_Age = age;&#125;//成员函数 类外实现template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson() &#123;\tcout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;void test01()&#123;\tPerson&lt;string, int&gt; p(&quot;Tom&quot;, 20);\tp.showPerson();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：类模板中成员函数类外实现时，需要加上模板参数列表\n3.7 类模板分文件编写学习目标：\n\n掌握类模板成员函数分文件编写产生的问题以及解决方式\n\n问题：\n\n类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到\n\n解决：\n\n解决方式1：直接包含.cpp源文件\n解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制\n\n示例：\nperson.hpp中代码：\n123456789101112131415161718192021222324252627#pragma once#include &lt;iostream&gt;using namespace std;#include &lt;string&gt;template&lt;class T1, class T2&gt;class Person &#123;public:\tPerson(T1 name, T2 age);\tvoid showPerson();public:\tT1 m_Name;\tT2 m_Age;&#125;;//构造函数 类外实现template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;\tthis-&gt;m_Name = name;\tthis-&gt;m_Age = age;&#125;//成员函数 类外实现template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson() &#123;\tcout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;\n\n\n\n类模板分文件编写.cpp中代码\n12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;//#include &quot;person.h&quot;#include &quot;person.cpp&quot; //解决方式1，包含cpp源文件//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp#include &quot;person.hpp&quot;void test01()&#123;\tPerson&lt;string, int&gt; p(&quot;Tom&quot;, 10);\tp.showPerson();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp\n3.8 类模板与友元学习目标：\n\n掌握类模板配合友元函数的类内和类外实现\n\n全局函数类内实现 - 直接在类内声明友元即可\n全局函数类外实现 - 需要提前让编译器知道全局函数的存在\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;string&gt;//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元template&lt;class T1, class T2&gt; class Person;//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); template&lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt; &amp; p)&#123;\tcout &lt;&lt; &quot;类外实现 ---- 姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;template&lt;class T1, class T2&gt;class Person&#123;\t//1、全局函数配合友元   类内实现\tfriend void printPerson(Person&lt;T1, T2&gt; &amp; p)\t&#123;\t\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;\t&#125;\t//全局函数配合友元  类外实现\tfriend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);public:\tPerson(T1 name, T2 age)\t&#123;\t\tthis-&gt;m_Name = name;\t\tthis-&gt;m_Age = age;\t&#125;private:\tT1 m_Name;\tT2 m_Age;&#125;;//1、全局函数在类内实现void test01()&#123;\tPerson &lt;string, int &gt;p(&quot;Tom&quot;, 20);\tprintPerson(p);&#125;//2、全局函数在类外实现void test02()&#123;\tPerson &lt;string, int &gt;p(&quot;Jerry&quot;, 30);\tprintPerson2(p);&#125;int main() &#123;\t//test01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别\n3.9 类模板案例   案例描述:  实现一个通用的数组类，要求如下：\n\n可以对内置数据类型以及自定义数据类型的数据进行存储\n将数组中的数据存储到堆区\n构造函数中可以传入数组的容量\n提供对应的拷贝构造函数以及operator&#x3D;防止浅拷贝问题\n提供尾插法和尾删法对数组中的数据进行增加和删除\n可以通过下标的方式访问数组中的元素\n可以获取数组中当前元素个数和数组的容量\n\n示例：\nmyArray.hpp中代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#pragma once#include &lt;iostream&gt;using namespace std;template&lt;class T&gt;class MyArray&#123;public:    \t//构造函数\tMyArray(int capacity)\t&#123;\t\tthis-&gt;m_Capacity = capacity;\t\tthis-&gt;m_Size = 0;\t\tpAddress = new T[this-&gt;m_Capacity];\t&#125;\t//拷贝构造\tMyArray(const MyArray &amp; arr)\t&#123;\t\tthis-&gt;m_Capacity = arr.m_Capacity;\t\tthis-&gt;m_Size = arr.m_Size;\t\tthis-&gt;pAddress = new T[this-&gt;m_Capacity];\t\tfor (int i = 0; i &lt; this-&gt;m_Size; i++)\t\t&#123;\t\t\t//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，\t\t\t// 普通类型可以直接= 但是指针类型需要深拷贝\t\t\tthis-&gt;pAddress[i] = arr.pAddress[i];\t\t&#125;\t&#125;\t//重载= 操作符  防止浅拷贝问题\tMyArray&amp; operator=(const MyArray&amp; myarray) &#123;\t\tif (this-&gt;pAddress != NULL) &#123;\t\t\tdelete[] this-&gt;pAddress;\t\t\tthis-&gt;m_Capacity = 0;\t\t\tthis-&gt;m_Size = 0;\t\t&#125;\t\tthis-&gt;m_Capacity = myarray.m_Capacity;\t\tthis-&gt;m_Size = myarray.m_Size;\t\tthis-&gt;pAddress = new T[this-&gt;m_Capacity];\t\tfor (int i = 0; i &lt; this-&gt;m_Size; i++) &#123;\t\t\tthis-&gt;pAddress[i] = myarray[i];\t\t&#125;\t\treturn *this;\t&#125;\t//重载[] 操作符  arr[0]\tT&amp; operator [](int index)\t&#123;\t\treturn this-&gt;pAddress[index]; //不考虑越界，用户自己去处理\t&#125;\t//尾插法\tvoid Push_back(const T &amp; val)\t&#123;\t\tif (this-&gt;m_Capacity == this-&gt;m_Size)\t\t&#123;\t\t\treturn;\t\t&#125;\t\tthis-&gt;pAddress[this-&gt;m_Size] = val;\t\tthis-&gt;m_Size++;\t&#125;\t//尾删法\tvoid Pop_back()\t&#123;\t\tif (this-&gt;m_Size == 0)\t\t&#123;\t\t\treturn;\t\t&#125;\t\tthis-&gt;m_Size--;\t&#125;\t//获取数组容量\tint getCapacity()\t&#123;\t\treturn this-&gt;m_Capacity;\t&#125;\t//获取数组大小\tint\tgetSize()\t&#123;\t\treturn this-&gt;m_Size;\t&#125;\t//析构\t~MyArray()\t&#123;\t\tif (this-&gt;pAddress != NULL)\t\t&#123;\t\t\tdelete[] this-&gt;pAddress;\t\t\tthis-&gt;pAddress = NULL;\t\t\tthis-&gt;m_Capacity = 0;\t\t\tthis-&gt;m_Size = 0;\t\t&#125;\t&#125;private:\tT * pAddress;  //指向一个堆空间，这个空间存储真正的数据\tint m_Capacity; //容量\tint m_Size;   // 大小&#125;;\n\n\n\n类模板案例—数组类封装.cpp中\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &quot;myArray.hpp&quot;#include &lt;string&gt;void printIntArray(MyArray&lt;int&gt;&amp; arr) &#123;\tfor (int i = 0; i &lt; arr.getSize(); i++) &#123;\t\tcout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;//测试内置数据类型void test01()&#123;\tMyArray&lt;int&gt; array1(10);\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tarray1.Push_back(i);\t&#125;\tcout &lt;&lt; &quot;array1打印输出：&quot; &lt;&lt; endl;\tprintIntArray(array1);\tcout &lt;&lt; &quot;array1的大小：&quot; &lt;&lt; array1.getSize() &lt;&lt; endl;\tcout &lt;&lt; &quot;array1的容量：&quot; &lt;&lt; array1.getCapacity() &lt;&lt; endl;\tcout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl;\tMyArray&lt;int&gt; array2(array1);\tarray2.Pop_back();\tcout &lt;&lt; &quot;array2打印输出：&quot; &lt;&lt; endl;\tprintIntArray(array2);\tcout &lt;&lt; &quot;array2的大小：&quot; &lt;&lt; array2.getSize() &lt;&lt; endl;\tcout &lt;&lt; &quot;array2的容量：&quot; &lt;&lt; array2.getCapacity() &lt;&lt; endl;&#125;//测试自定义数据类型class Person &#123;public:\tPerson() &#123;&#125; \t\tPerson(string name, int age) &#123;\t\tthis-&gt;m_Name = name;\t\tthis-&gt;m_Age = age;\t&#125;public:\tstring m_Name;\tint m_Age;&#125;;void printPersonArray(MyArray&lt;Person&gt;&amp; personArr)&#123;\tfor (int i = 0; i &lt; personArr.getSize(); i++) &#123;\t\tcout &lt;&lt; &quot;姓名：&quot; &lt;&lt; personArr[i].m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; personArr[i].m_Age &lt;&lt; endl;\t&#125;&#125;void test02()&#123;\t//创建数组\tMyArray&lt;Person&gt; pArray(10);\tPerson p1(&quot;孙悟空&quot;, 30);\tPerson p2(&quot;韩信&quot;, 20);\tPerson p3(&quot;妲己&quot;, 18);\tPerson p4(&quot;王昭君&quot;, 15);\tPerson p5(&quot;赵云&quot;, 24);\t//插入数据\tpArray.Push_back(p1);\tpArray.Push_back(p2);\tpArray.Push_back(p3);\tpArray.Push_back(p4);\tpArray.Push_back(p5);\tprintPersonArray(pArray);\tcout &lt;&lt; &quot;pArray的大小：&quot; &lt;&lt; pArray.getSize() &lt;&lt; endl;\tcout &lt;&lt; &quot;pArray的容量：&quot; &lt;&lt; pArray.getCapacity() &lt;&lt; endl;&#125;int main() &#123;\t//test01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n能够利用所学知识点实现通用的数组\n","slug":"C++模板","date":"2021-07-16T10:50:36.000Z","categories_index":"C++高级","tags_index":"C++,函数模版,类模版","author_index":"kiyose408"},{"id":"2c98e19b326147a6809d9ac893abf8aa","title":"STL函数对象","content":"1 函数对象1.1 函数对象概念概念：\n\n重载函数调用操作符的类，其对象常称为函数对象\n函数对象使用重载的()时，行为类似函数调用，也叫仿函数\n\n本质：\n函数对象(仿函数)是一个类，不是一个函数\n1.2  函数对象使用特点：\n\n函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值\n函数对象超出普通函数的概念，函数对象可以有自己的状态\n函数对象可以作为参数传递\n\n示例:\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;string&gt;//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值class MyAdd&#123;public :\tint operator()(int v1,int v2)\t&#123;\t\treturn v1 + v2;\t&#125;&#125;;void test01()&#123;\tMyAdd myAdd;\tcout &lt;&lt; myAdd(10, 10) &lt;&lt; endl;&#125;//2、函数对象可以有自己的状态class MyPrint&#123;public:\tMyPrint()\t&#123;\t\tcount = 0;\t&#125;\tvoid operator()(string test)\t&#123;\t\tcout &lt;&lt; test &lt;&lt; endl;\t\tcount++; //统计使用次数\t&#125;\tint count; //内部自己的状态&#125;;void test02()&#123;\tMyPrint myPrint;\tmyPrint(&quot;hello world&quot;);\tmyPrint(&quot;hello world&quot;);\tmyPrint(&quot;hello world&quot;);\tcout &lt;&lt; &quot;myPrint调用次数为： &quot; &lt;&lt; myPrint.count &lt;&lt; endl;&#125;//3、函数对象可以作为参数传递void doPrint(MyPrint &amp;mp , string test)&#123;\tmp(test);&#125;void test03()&#123;\tMyPrint myPrint;\tdoPrint(myPrint, &quot;Hello C++&quot;);&#125;int main() &#123;\t//test01();\t//test02();\ttest03();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n仿函数写法非常灵活，可以作为参数进行传递。\n\n2  谓词2.1 谓词概念概念：\n\n返回bool类型的仿函数称为谓词\n如果operator()接受一个参数，那么叫做一元谓词\n如果operator()接受两个参数，那么叫做二元谓词\n\n2.2 一元谓词示例：\n123456789101112131415161718192021222324252627282930313233343536#include &lt;vector&gt;#include &lt;algorithm&gt;//1.一元谓词struct GreaterFive&#123;\tbool operator()(int val) &#123;\t\treturn val &gt; 5;\t&#125;&#125;;void test01() &#123;\tvector&lt;int&gt; v;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tv.push_back(i);\t&#125;\tvector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());\tif (it == v.end()) &#123;\t\tcout &lt;&lt; &quot;没找到!&quot; &lt;&lt; endl;\t&#125;\telse &#123;\t\tcout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;\t&#125;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：参数只有一个的谓词，称为一元谓词\n2.3 二元谓词示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;vector&gt;#include &lt;algorithm&gt;//二元谓词class MyCompare&#123;public:\tbool operator()(int num1, int num2)\t&#123;\t\treturn num1 &gt; num2;\t&#125;&#125;;void test01()&#123;\tvector&lt;int&gt; v;\tv.push_back(10);\tv.push_back(40);\tv.push_back(20);\tv.push_back(30);\tv.push_back(50);\t//默认从小到大\tsort(v.begin(), v.end());\tfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)\t&#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\tcout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;\t//使用函数对象改变算法策略，排序从大到小\tsort(v.begin(), v.end(), MyCompare());\tfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)\t&#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：参数只有两个的谓词，称为二元谓词\n3 内建函数对象3.1 内建函数对象意义概念：\n\nSTL内建了一些函数对象\n\n分类:\n\n算术仿函数\n\n关系仿函数\n\n逻辑仿函数\n\n\n用法：\n\n这些仿函数所产生的对象，用法和一般函数完全相同\n使用内建函数对象，需要引入头文件 #include&lt;functional&gt;\n\n3.2 算术仿函数功能描述：\n\n实现四则运算\n其中negate是一元运算，其他都是二元运算\n\n仿函数原型：\n\ntemplate&lt;class T&gt; T plus&lt;T&gt;                &#x2F;&#x2F;加法仿函数\ntemplate&lt;class T&gt; T minus&lt;T&gt;              &#x2F;&#x2F;减法仿函数\ntemplate&lt;class T&gt; T multiplies&lt;T&gt;    &#x2F;&#x2F;乘法仿函数\ntemplate&lt;class T&gt; T divides&lt;T&gt;         &#x2F;&#x2F;除法仿函数\ntemplate&lt;class T&gt; T modulus&lt;T&gt;         &#x2F;&#x2F;取模仿函数\ntemplate&lt;class T&gt; T negate&lt;T&gt;           &#x2F;&#x2F;取反仿函数\n\n示例：\n123456789101112131415161718192021222324#include &lt;functional&gt;//negatevoid test01()&#123;\tnegate&lt;int&gt; n;\tcout &lt;&lt; n(50) &lt;&lt; endl;&#125;//plusvoid test02()&#123;\tplus&lt;int&gt; p;\tcout &lt;&lt; p(10, 20) &lt;&lt; endl;&#125;int main() &#123;\ttest01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：使用内建函数对象时，需要引入头文件 #include &lt;functional&gt;\n3.3 关系仿函数功能描述：\n\n实现关系对比\n\n仿函数原型：\n\ntemplate&lt;class T&gt; bool equal_to&lt;T&gt;                    &#x2F;&#x2F;等于\ntemplate&lt;class T&gt; bool not_equal_to&lt;T&gt;            &#x2F;&#x2F;不等于\ntemplate&lt;class T&gt; bool greater&lt;T&gt;                      &#x2F;&#x2F;大于\ntemplate&lt;class T&gt; bool greater_equal&lt;T&gt;          &#x2F;&#x2F;大于等于\ntemplate&lt;class T&gt; bool less&lt;T&gt;                           &#x2F;&#x2F;小于\ntemplate&lt;class T&gt; bool less_equal&lt;T&gt;               &#x2F;&#x2F;小于等于\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;functional&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class MyCompare&#123;public:\tbool operator()(int v1,int v2)\t&#123;\t\treturn v1 &gt; v2;\t&#125;&#125;;void test01()&#123;\tvector&lt;int&gt; v;\tv.push_back(10);\tv.push_back(30);\tv.push_back(50);\tv.push_back(40);\tv.push_back(20);\tfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\t//自己实现仿函数\t//sort(v.begin(), v.end(), MyCompare());\t//STL内建仿函数  大于仿函数\tsort(v.begin(), v.end(), greater&lt;int&gt;());\tfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：关系仿函数中最常用的就是greater&lt;&gt;大于\n3.4 逻辑仿函数功能描述：\n\n实现逻辑运算\n\n函数原型：\n\ntemplate&lt;class T&gt; bool logical_and&lt;T&gt;              &#x2F;&#x2F;逻辑与\ntemplate&lt;class T&gt; bool logical_or&lt;T&gt;                &#x2F;&#x2F;逻辑或\ntemplate&lt;class T&gt; bool logical_not&lt;T&gt;              &#x2F;&#x2F;逻辑非\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536#include &lt;vector&gt;#include &lt;functional&gt;#include &lt;algorithm&gt;void test01()&#123;\tvector&lt;bool&gt; v;\tv.push_back(true);\tv.push_back(false);\tv.push_back(true);\tv.push_back(false);\tfor (vector&lt;bool&gt;::iterator it = v.begin();it!= v.end();it++)\t&#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\t//逻辑非  将v容器搬运到v2中，并执行逻辑非运算\tvector&lt;bool&gt; v2;\tv2.resize(v.size());\ttransform(v.begin(), v.end(),  v2.begin(), logical_not&lt;bool&gt;());\tfor (vector&lt;bool&gt;::iterator it = v2.begin(); it != v2.end(); it++)\t&#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：逻辑仿函数实际应用较少，了解即可\n","slug":"STL函数对象","date":"2021-07-10T10:49:00.000Z","categories_index":"STL","tags_index":"STL,函数对象,仿函数,谓词,内建函数","author_index":"kiyose408"},{"id":"e365ba1ee6a6112eb6b41afc5aaaf6ad","title":"STL常用容器2","content":"5 stack容器5.1 stack 基本概念概念：stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口\n栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为\n栈中进入数据称为  — 入栈  push\n栈中弹出数据称为  — 出栈  pop\n5.2 stack 常用接口功能描述：栈容器常用的对外接口\n构造函数：\n\nstack&lt;T&gt; stk;                                 &#x2F;&#x2F;stack采用模板类实现， stack对象的默认构造形式\nstack(const stack &amp;stk);            &#x2F;&#x2F;拷贝构造函数\n\n赋值操作：\n\nstack&amp; operator=(const stack &amp;stk);           &#x2F;&#x2F;重载等号操作符\n\n数据存取：\n\npush(elem);      &#x2F;&#x2F;向栈顶添加元素\npop();                &#x2F;&#x2F;从栈顶移除第一个元素\ntop();                 &#x2F;&#x2F;返回栈顶元素\n\n大小操作：\n\nempty();            &#x2F;&#x2F;判断堆栈是否为空\nsize();               &#x2F;&#x2F;返回栈的大小\n\n示例：\n12345678910111213141516171819202122232425262728293031#include &lt;stack&gt;//栈容器常用接口void test01()&#123;\t//创建栈容器 栈容器必须符合先进后出\tstack&lt;int&gt; s;\t//向栈中添加元素，叫做 压栈 入栈\ts.push(10);\ts.push(20);\ts.push(30);\twhile (!s.empty()) &#123;\t\t//输出栈顶元素\t\tcout &lt;&lt; &quot;栈顶元素为： &quot; &lt;&lt; s.top() &lt;&lt; endl;\t\t//弹出栈顶元素\t\ts.pop();\t&#125;\tcout &lt;&lt; &quot;栈的大小为：&quot; &lt;&lt; s.size() &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n入栈   — push\n出栈   — pop\n返回栈顶   — top\n判断栈是否为空   — empty\n返回栈大小   — size\n\n6 queue 容器6.1 queue 基本概念概念：Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口\n队列容器允许从一端新增元素，从另一端移除元素\n队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为\n队列中进数据称为 — 入队    push\n队列中出数据称为 — 出队    pop\n6.2 queue 常用接口功能描述：栈容器常用的对外接口\n构造函数：\n\nqueue&lt;T&gt; que;                                 &#x2F;&#x2F;queue采用模板类实现，queue对象的默认构造形式\nqueue(const queue &amp;que);            &#x2F;&#x2F;拷贝构造函数\n\n赋值操作：\n\nqueue&amp; operator=(const queue &amp;que);           &#x2F;&#x2F;重载等号操作符\n\n数据存取：\n\npush(elem);                             &#x2F;&#x2F;往队尾添加元素\npop();                                      &#x2F;&#x2F;从队头移除第一个元素\nback();                                    &#x2F;&#x2F;返回最后一个元素\nfront();                                   &#x2F;&#x2F;返回第一个元素\n\n大小操作：\n\nempty();            &#x2F;&#x2F;判断堆栈是否为空\nsize();               &#x2F;&#x2F;返回栈的大小\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;queue&gt;#include &lt;string&gt;class Person&#123;public:\tPerson(string name, int age)\t&#123;\t\tthis-&gt;m_Name = name;\t\tthis-&gt;m_Age = age;\t&#125;\tstring m_Name;\tint m_Age;&#125;;void test01() &#123;\t//创建队列\tqueue&lt;Person&gt; q;\t//准备数据\tPerson p1(&quot;唐僧&quot;, 30);\tPerson p2(&quot;孙悟空&quot;, 1000);\tPerson p3(&quot;猪八戒&quot;, 900);\tPerson p4(&quot;沙僧&quot;, 800);\t//向队列中添加元素  入队操作\tq.push(p1);\tq.push(p2);\tq.push(p3);\tq.push(p4);\t//队列不提供迭代器，更不支持随机访问\t\twhile (!q.empty()) &#123;\t\t//输出队头元素\t\tcout &lt;&lt; &quot;队头元素-- 姓名： &quot; &lt;&lt; q.front().m_Name               &lt;&lt; &quot; 年龄： &quot;&lt;&lt; q.front().m_Age &lt;&lt; endl;        \t\tcout &lt;&lt; &quot;队尾元素-- 姓名： &quot; &lt;&lt; q.back().m_Name                &lt;&lt; &quot; 年龄： &quot; &lt;&lt; q.back().m_Age &lt;&lt; endl;        \t\tcout &lt;&lt; endl;\t\t//弹出队头元素\t\tq.pop();\t&#125;\tcout &lt;&lt; &quot;队列大小为：&quot; &lt;&lt; q.size() &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n入队   — push\n出队   — pop\n返回队头元素   — front\n返回队尾元素   — back\n判断队是否为空   — empty\n返回队列大小   — size\n\n7 list容器7.1 list基本概念功能：将数据进行链式存储\n链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的\n链表的组成：链表由一系列结点组成\n结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域\nSTL中的链表是一个双向循环链表\n由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器\nlist的优点：\n\n采用动态存储分配，不会造成内存浪费和溢出\n链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素\n\nlist的缺点：\n\n链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大\n\nList有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。\n总结：STL中List和vector是两个最常被使用的容器，各有优缺点\n7.2  list构造函数功能描述：\n\n创建list容器\n\n函数原型：\n\nlist&lt;T&gt; lst;                               &#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式：\nlist(beg,end);                           &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。\nlist(n,elem);                             &#x2F;&#x2F;构造函数将n个elem拷贝给本身。\nlist(const list &amp;lst);            &#x2F;&#x2F;拷贝构造函数。\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;\tfor (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;void test01()&#123;\tlist&lt;int&gt;L1;\tL1.push_back(10);\tL1.push_back(20);\tL1.push_back(30);\tL1.push_back(40);\tprintList(L1);\tlist&lt;int&gt;L2(L1.begin(),L1.end());\tprintList(L2);\tlist&lt;int&gt;L3(L2);\tprintList(L3);\tlist&lt;int&gt;L4(10, 1000);\tprintList(L4);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：list构造方式同其他几个STL常用容器，熟练掌握即可\n7.3 list 赋值和交换功能描述：\n\n给list容器进行赋值，以及交换list容器\n\n函数原型：\n\nassign(beg, end);            &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。\nassign(n, elem);              &#x2F;&#x2F;将n个elem拷贝赋值给本身。\nlist&amp; operator=(const list &amp;lst);         &#x2F;&#x2F;重载等号操作符\nswap(lst);                         &#x2F;&#x2F;将lst与本身的元素互换。\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;\tfor (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;//赋值和交换void test01()&#123;\tlist&lt;int&gt;L1;\tL1.push_back(10);\tL1.push_back(20);\tL1.push_back(30);\tL1.push_back(40);\tprintList(L1);\t//赋值\tlist&lt;int&gt;L2;\tL2 = L1;\tprintList(L2);\tlist&lt;int&gt;L3;\tL3.assign(L2.begin(), L2.end());\tprintList(L3);\tlist&lt;int&gt;L4;\tL4.assign(10, 100);\tprintList(L4);&#125;//交换void test02()&#123;\tlist&lt;int&gt;L1;\tL1.push_back(10);\tL1.push_back(20);\tL1.push_back(30);\tL1.push_back(40);\tlist&lt;int&gt;L2;\tL2.assign(10, 100);\tcout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;\tprintList(L1);\tprintList(L2);\tcout &lt;&lt; endl;\tL1.swap(L2);\tcout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;\tprintList(L1);\tprintList(L2);&#125;int main() &#123;\t//test01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：list赋值和交换操作能够灵活运用即可\n7.4 list 大小操作功能描述：\n\n对list容器的大小进行操作\n\n函数原型：\n\nsize();                              &#x2F;&#x2F;返回容器中元素的个数\n\nempty();                            &#x2F;&#x2F;判断容器是否为空\n\nresize(num);                   &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。\n​\t\t\t\t\t    &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。\n\nresize(num, elem);        &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。            \t​\t\t\t\t\t            \t    &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。\n\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;\tfor (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;//大小操作void test01()&#123;\tlist&lt;int&gt;L1;\tL1.push_back(10);\tL1.push_back(20);\tL1.push_back(30);\tL1.push_back(40);\tif (L1.empty())\t&#123;\t\tcout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl;\t\tcout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl;\t&#125;\t//重新指定大小\tL1.resize(10);\tprintList(L1);\tL1.resize(2);\tprintList(L1);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n判断是否为空   — empty\n返回元素个数   — size\n重新指定个数   — resize\n\n7.5 list 插入和删除功能描述：\n\n对list容器进行数据的插入和删除\n\n函数原型：\n\npush_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素\npop_back();&#x2F;&#x2F;删除容器中最后一个元素\npush_front(elem);&#x2F;&#x2F;在容器开头插入一个元素\npop_front();&#x2F;&#x2F;从容器开头移除第一个元素\ninsert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。\ninsert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。\ninsert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。\nclear();&#x2F;&#x2F;移除容器的所有数据\nerase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。\nerase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。\nremove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123;\tfor (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;//插入和删除void test01()&#123;\tlist&lt;int&gt; L;\t//尾插\tL.push_back(10);\tL.push_back(20);\tL.push_back(30);\t//头插\tL.push_front(100);\tL.push_front(200);\tL.push_front(300);\tprintList(L);\t//尾删\tL.pop_back();\tprintList(L);\t//头删\tL.pop_front();\tprintList(L);\t//插入\tlist&lt;int&gt;::iterator it = L.begin();\tL.insert(++it, 1000);\tprintList(L);\t//删除\tit = L.begin();\tL.erase(++it);\tprintList(L);\t//移除\tL.push_back(10000);\tL.push_back(10000);\tL.push_back(10000);\tprintList(L);\tL.remove(10000);\tprintList(L);        //清空\tL.clear();\tprintList(L);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n尾插   — push_back\n尾删   — pop_back\n头插   — push_front\n头删   — pop_front\n插入   — insert\n删除   — erase\n移除   — remove\n清空   — clear\n\n7.6 list 数据存取功能描述：\n\n对list容器中数据进行存取\n\n函数原型：\n\nfront();        &#x2F;&#x2F;返回第一个元素。\nback();         &#x2F;&#x2F;返回最后一个元素。\n\n示例：\n12345678910111213141516171819202122232425262728293031#include &lt;list&gt;//数据存取void test01()&#123;\tlist&lt;int&gt;L1;\tL1.push_back(10);\tL1.push_back(20);\tL1.push_back(30);\tL1.push_back(40);\t\t//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据\t//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据\tcout &lt;&lt; &quot;第一个元素为： &quot; &lt;&lt; L1.front() &lt;&lt; endl;\tcout &lt;&lt; &quot;最后一个元素为： &quot; &lt;&lt; L1.back() &lt;&lt; endl;\t//list容器的迭代器是双向迭代器，不支持随机访问\tlist&lt;int&gt;::iterator it = L1.begin();\t//it = it + 1;//错误，不可以跳跃访问，即使是+1&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\nlist容器中不可以通过[]或者at方式访问数据\n返回第一个元素   — front\n返回最后一个元素   — back\n\n7.7 list 反转和排序功能描述：\n\n将容器中的元素反转，以及将容器中的数据进行排序\n\n函数原型：\n\nreverse();   &#x2F;&#x2F;反转链表\nsort();        &#x2F;&#x2F;链表排序\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243void printList(const list&lt;int&gt;&amp; L) &#123;\tfor (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;bool myCompare(int val1 , int val2)&#123;\treturn val1 &gt; val2;&#125;//反转和排序void test01()&#123;\tlist&lt;int&gt; L;\tL.push_back(90);\tL.push_back(30);\tL.push_back(20);\tL.push_back(70);\tprintList(L);\t//反转容器的元素\tL.reverse();\tprintList(L);\t//排序\tL.sort(); //默认的排序规则 从小到大\tprintList(L);\tL.sort(myCompare); //指定规则，从大到小\tprintList(L);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n反转   — reverse\n排序   — sort （成员函数）\n\n7.8 排序案例案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高\n排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;list&gt;#include &lt;string&gt;class Person &#123;public:\tPerson(string name, int age , int height) &#123;\t\tm_Name = name;\t\tm_Age = age;\t\tm_Height = height;\t&#125;public:\tstring m_Name;  //姓名\tint m_Age;      //年龄\tint m_Height;   //身高&#125;;bool ComparePerson(Person&amp; p1, Person&amp; p2) &#123;\tif (p1.m_Age == p2.m_Age) &#123;\t\treturn p1.m_Height  &gt; p2.m_Height;\t&#125;\telse\t&#123;\t\treturn  p1.m_Age &lt; p2.m_Age;\t&#125;&#125;void test01() &#123;\tlist&lt;Person&gt; L;\tPerson p1(&quot;刘备&quot;, 35 , 175);\tPerson p2(&quot;曹操&quot;, 45 , 180);\tPerson p3(&quot;孙权&quot;, 40 , 170);\tPerson p4(&quot;赵云&quot;, 25 , 190);\tPerson p5(&quot;张飞&quot;, 35 , 160);\tPerson p6(&quot;关羽&quot;, 35 , 200);\tL.push_back(p1);\tL.push_back(p2);\tL.push_back(p3);\tL.push_back(p4);\tL.push_back(p5);\tL.push_back(p6);\tfor (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;\t\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age               &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;\t&#125;\tcout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl;\tL.sort(ComparePerson); //排序\tfor (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;\t\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age               &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;\t&#125;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n总结：\n\n对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序\n\n高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂\n\n\n8 set&#x2F; multiset 容器8.1 set基本概念简介：\n\n所有元素都会在插入时自动被排序\n\n本质：\n\nset&#x2F;multiset属于关联式容器，底层结构是用二叉树实现。\n\nset和multiset区别：\n\nset不允许容器中有重复的元素\nmultiset允许容器中有重复的元素\n\n8.2 set构造和赋值功能描述：创建set容器以及赋值\n构造：\n\nset&lt;T&gt; st;                        &#x2F;&#x2F;默认构造函数：\nset(const set &amp;st);       &#x2F;&#x2F;拷贝构造函数\n\n赋值：\n\nset&amp; operator=(const set &amp;st);    &#x2F;&#x2F;重载等号操作符\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123;\tfor (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)\t&#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;//构造和赋值void test01()&#123;\tset&lt;int&gt; s1;\ts1.insert(10);\ts1.insert(30);\ts1.insert(20);\ts1.insert(40);\tprintSet(s1);\t//拷贝构造\tset&lt;int&gt;s2(s1);\tprintSet(s2);\t//赋值\tset&lt;int&gt;s3;\ts3 = s2;\tprintSet(s3);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\nset容器插入数据时用insert\nset容器插入数据的数据会自动排序\n\n8.3 set大小和交换功能描述：\n\n统计set容器大小以及交换set容器\n\n函数原型：\n\nsize();          &#x2F;&#x2F;返回容器中元素的数目\nempty();        &#x2F;&#x2F;判断容器是否为空\nswap(st);      &#x2F;&#x2F;交换两个集合容器\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123;\tfor (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)\t&#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;//大小void test01()&#123;\tset&lt;int&gt; s1;\t\ts1.insert(10);\ts1.insert(30);\ts1.insert(20);\ts1.insert(40);\tif (s1.empty())\t&#123;\t\tcout &lt;&lt; &quot;s1为空&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;s1不为空&quot; &lt;&lt; endl;\t\tcout &lt;&lt; &quot;s1的大小为： &quot; &lt;&lt; s1.size() &lt;&lt; endl;\t&#125;&#125;//交换void test02()&#123;\tset&lt;int&gt; s1;\ts1.insert(10);\ts1.insert(30);\ts1.insert(20);\ts1.insert(40);\tset&lt;int&gt; s2;\ts2.insert(100);\ts2.insert(300);\ts2.insert(200);\ts2.insert(400);\tcout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;\tprintSet(s1);\tprintSet(s2);\tcout &lt;&lt; endl;\tcout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;\ts1.swap(s2);\tprintSet(s1);\tprintSet(s2);&#125;int main() &#123;\t//test01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n统计大小   — size\n判断是否为空   — empty\n交换容器   — swap\n\n8.4 set插入和删除功能描述：\n\nset容器进行插入数据和删除数据\n\n函数原型：\n\ninsert(elem);           &#x2F;&#x2F;在容器中插入元素。\nclear();                    &#x2F;&#x2F;清除所有元素\nerase(pos);              &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。\nerase(beg, end);    &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。\nerase(elem);            &#x2F;&#x2F;删除容器中值为elem的元素。\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123;\tfor (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)\t&#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;//插入和删除void test01()&#123;\tset&lt;int&gt; s1;\t//插入\ts1.insert(10);\ts1.insert(30);\ts1.insert(20);\ts1.insert(40);\tprintSet(s1);\t//删除\ts1.erase(s1.begin());\tprintSet(s1);\ts1.erase(30);\tprintSet(s1);\t//清空\t//s1.erase(s1.begin(), s1.end());\ts1.clear();\tprintSet(s1);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n插入   — insert\n删除   — erase\n清空   — clear\n\n8.5 set查找和统计功能描述：\n\n对set容器进行查找数据以及统计数据\n\n函数原型：\n\nfind(key);                  &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();\ncount(key);                &#x2F;&#x2F;统计key的元素个数\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637#include &lt;set&gt;//查找和统计void test01()&#123;\tset&lt;int&gt; s1;\t//插入\ts1.insert(10);\ts1.insert(30);\ts1.insert(20);\ts1.insert(40);\t\t//查找\tset&lt;int&gt;::iterator pos = s1.find(30);\tif (pos != s1.end())\t&#123;\t\tcout &lt;&lt; &quot;找到了元素 ： &quot; &lt;&lt; *pos &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;\t&#125;\t//统计\tint num = s1.count(30);\tcout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n查找   —  find    （返回的是迭代器）\n统计   —  count  （对于set，结果为0或者1）\n\n8.6 set和multiset区别学习目标：\n\n掌握set和multiset的区别\n\n区别：\n\nset不可以插入重复数据，而multiset可以\nset插入数据的同时会返回插入结果，表示插入是否成功\nmultiset不会检测数据，因此可以插入重复数据\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;set&gt;//set和multiset区别void test01()&#123;\tset&lt;int&gt; s;\tpair&lt;set&lt;int&gt;::iterator, bool&gt;  ret = s.insert(10);\tif (ret.second) &#123;\t\tcout &lt;&lt; &quot;第一次插入成功!&quot; &lt;&lt; endl;\t&#125;\telse &#123;\t\tcout &lt;&lt; &quot;第一次插入失败!&quot; &lt;&lt; endl;\t&#125;\tret = s.insert(10);\tif (ret.second) &#123;\t\tcout &lt;&lt; &quot;第二次插入成功!&quot; &lt;&lt; endl;\t&#125;\telse &#123;\t\tcout &lt;&lt; &quot;第二次插入失败!&quot; &lt;&lt; endl;\t&#125;    \t//multiset\tmultiset&lt;int&gt; ms;\tms.insert(10);\tms.insert(10);\tfor (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n如果不允许插入重复数据可以利用set\n如果需要插入重复数据利用multiset\n\n8.7 pair对组创建功能描述：\n\n成对出现的数据，利用对组可以返回两个数据\n\n两种创建方式：\n\npair&lt;type, type&gt; p ( value1, value2 );\npair&lt;type, type&gt; p = make_pair( value1, value2 );\n\n示例：\n1234567891011121314151617181920#include &lt;string&gt;//对组创建void test01()&#123;\tpair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20);\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt;  p.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.second &lt;&lt; endl;\tpair&lt;string, int&gt; p2 = make_pair(&quot;Jerry&quot;, 10);\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p2.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p2.second &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n两种方式都可以创建对组，记住一种即可\n8.8 set容器排序学习目标：\n\nset容器默认排序规则为从小到大，掌握如何改变排序规则\n\n主要技术点：\n\n利用仿函数，可以改变排序规则\n\n示例一   set存放内置数据类型\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;set&gt;class MyCompare &#123;public:\tbool operator()(int v1, int v2) &#123;\t\treturn v1 &gt; v2;\t&#125;&#125;;void test01() &#123;    \tset&lt;int&gt; s1;\ts1.insert(10);\ts1.insert(40);\ts1.insert(20);\ts1.insert(30);\ts1.insert(50);\t//默认从小到大\tfor (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\t//指定排序规则\tset&lt;int,MyCompare&gt; s2;\ts2.insert(10);\ts2.insert(40);\ts2.insert(20);\ts2.insert(30);\ts2.insert(50);\tfor (set&lt;int, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：利用仿函数可以指定set容器的排序规则\n示例二 set存放自定义数据类型\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;set&gt;#include &lt;string&gt;class Person&#123;public:\tPerson(string name, int age)\t&#123;\t\tthis-&gt;m_Name = name;\t\tthis-&gt;m_Age = age;\t&#125;\tstring m_Name;\tint m_Age;&#125;;class comparePerson&#123;public:\tbool operator()(const Person&amp; p1, const Person &amp;p2)\t&#123;\t\t//按照年龄进行排序  降序\t\treturn p1.m_Age &gt; p2.m_Age;\t&#125;&#125;;void test01()&#123;\tset&lt;Person, comparePerson&gt; s;\tPerson p1(&quot;刘备&quot;, 23);\tPerson p2(&quot;关羽&quot;, 27);\tPerson p3(&quot;张飞&quot;, 25);\tPerson p4(&quot;赵云&quot;, 21);\ts.insert(p1);\ts.insert(p2);\ts.insert(p3);\ts.insert(p4);\tfor (set&lt;Person, comparePerson&gt;::iterator it = s.begin(); it != s.end(); it++)\t&#123;\t\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;\t&#125;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n对于自定义数据类型，set必须指定排序规则才可以插入数据\n9 map&#x2F; multimap容器9.1 map基本概念简介：\n\nmap中所有元素都是pair\npair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）\n所有元素都会根据元素的键值自动排序\n\n本质：\n\nmap&#x2F;multimap属于关联式容器，底层结构是用二叉树实现。\n\n优点：\n\n可以根据key值快速找到value值\n\nmap和multimap区别：\n\nmap不允许容器中有重复key值元素\nmultimap允许容器中有重复key值元素\n\n9.2  map构造和赋值功能描述：\n\n对map容器进行构造和赋值操作\n\n函数原型：\n构造：\n\nmap&lt;T1, T2&gt; mp;                     &#x2F;&#x2F;map默认构造函数: \nmap(const map &amp;mp);             &#x2F;&#x2F;拷贝构造函数\n\n赋值：\n\nmap&amp; operator=(const map &amp;mp);    &#x2F;&#x2F;重载等号操作符\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123;\tfor (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)\t&#123;\t\tcout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\t&#125;\tcout &lt;&lt; endl;&#125;void test01()&#123;\tmap&lt;int,int&gt;m; //默认构造\tm.insert(pair&lt;int, int&gt;(1, 10));\tm.insert(pair&lt;int, int&gt;(2, 20));\tm.insert(pair&lt;int, int&gt;(3, 30));\tprintMap(m);\tmap&lt;int, int&gt;m2(m); //拷贝构造\tprintMap(m2);\tmap&lt;int, int&gt;m3;\tm3 = m2; //赋值\tprintMap(m3);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：map中所有元素都是成对出现，插入数据时候要使用对组\n9.3 map大小和交换功能描述：\n\n统计map容器大小以及交换map容器\n\n函数原型：\n\nsize();          &#x2F;&#x2F;返回容器中元素的数目\nempty();        &#x2F;&#x2F;判断容器是否为空\nswap(st);      &#x2F;&#x2F;交换两个集合容器\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123;\tfor (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)\t&#123;\t\tcout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\t&#125;\tcout &lt;&lt; endl;&#125;void test01()&#123;\tmap&lt;int, int&gt;m;\tm.insert(pair&lt;int, int&gt;(1, 10));\tm.insert(pair&lt;int, int&gt;(2, 20));\tm.insert(pair&lt;int, int&gt;(3, 30));\tif (m.empty())\t&#123;\t\tcout &lt;&lt; &quot;m为空&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;m不为空&quot; &lt;&lt; endl;\t\tcout &lt;&lt; &quot;m的大小为： &quot; &lt;&lt; m.size() &lt;&lt; endl;\t&#125;&#125;//交换void test02()&#123;\tmap&lt;int, int&gt;m;\tm.insert(pair&lt;int, int&gt;(1, 10));\tm.insert(pair&lt;int, int&gt;(2, 20));\tm.insert(pair&lt;int, int&gt;(3, 30));\tmap&lt;int, int&gt;m2;\tm2.insert(pair&lt;int, int&gt;(4, 100));\tm2.insert(pair&lt;int, int&gt;(5, 200));\tm2.insert(pair&lt;int, int&gt;(6, 300));\tcout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;\tprintMap(m);\tprintMap(m2);\tcout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;\tm.swap(m2);\tprintMap(m);\tprintMap(m2);&#125;int main() &#123;\ttest01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n统计大小   — size\n判断是否为空   — empty\n交换容器   — swap\n\n9.4 map插入和删除功能描述：\n\nmap容器进行插入数据和删除数据\n\n函数原型：\n\ninsert(elem);           &#x2F;&#x2F;在容器中插入元素。\nclear();                    &#x2F;&#x2F;清除所有元素\nerase(pos);              &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。\nerase(beg, end);    &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。\nerase(key);            &#x2F;&#x2F;删除容器中值为key的元素。\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123;\tfor (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)\t&#123;\t\tcout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\t&#125;\tcout &lt;&lt; endl;&#125;void test01()&#123;\t//插入\tmap&lt;int, int&gt; m;\t//第一种插入方式\tm.insert(pair&lt;int, int&gt;(1, 10));\t//第二种插入方式\tm.insert(make_pair(2, 20));\t//第三种插入方式\tm.insert(map&lt;int, int&gt;::value_type(3, 30));\t//第四种插入方式\tm[4] = 40; \tprintMap(m);\t//删除\tm.erase(m.begin());\tprintMap(m);\tm.erase(3);\tprintMap(m);\t//清空\tm.erase(m.begin(),m.end());\tm.clear();\tprintMap(m);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\nmap插入方式很多，记住其一即可\n\n\n插入   — insert \n删除   — erase\n清空   — clear\n\n9.5 map查找和统计功能描述：\n\n对map容器进行查找数据以及统计数据\n\n函数原型：\n\nfind(key);                  &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();\ncount(key);                &#x2F;&#x2F;统计key的元素个数\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435#include &lt;map&gt;//查找和统计void test01()&#123;\tmap&lt;int, int&gt;m; \tm.insert(pair&lt;int, int&gt;(1, 10));\tm.insert(pair&lt;int, int&gt;(2, 20));\tm.insert(pair&lt;int, int&gt;(3, 30));\t//查找\tmap&lt;int, int&gt;::iterator pos = m.find(3);\tif (pos != m.end())\t&#123;\t\tcout &lt;&lt; &quot;找到了元素 key = &quot; &lt;&lt; (*pos).first &lt;&lt; &quot; value = &quot; &lt;&lt; (*pos).second &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;\t&#125;\t//统计\tint num = m.count(3);\tcout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n查找   —  find    （返回的是迭代器）\n统计   —  count  （对于map，结果为0或者1）\n\n9.6 map容器排序学习目标：\n\nmap容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则\n\n主要技术点:\n\n利用仿函数，可以改变排序规则\n\n示例：\n123456789101112131415161718192021222324252627282930313233#include &lt;map&gt;class MyCompare &#123;public:\tbool operator()(int v1, int v2) &#123;\t\treturn v1 &gt; v2;\t&#125;&#125;;void test01() &#123;\t//默认从小到大排序\t//利用仿函数实现从大到小排序\tmap&lt;int, int, MyCompare&gt; m;\tm.insert(make_pair(1, 10));\tm.insert(make_pair(2, 20));\tm.insert(make_pair(3, 30));\tm.insert(make_pair(4, 40));\tm.insert(make_pair(5, 50));\tfor (map&lt;int, int, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;\t\tcout &lt;&lt; &quot;key:&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;\t&#125;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n利用仿函数可以指定map容器的排序规则\n对于自定义数据类型，map必须要指定排序规则,同set容器\n\n10 案例-员工分组10.1 案例描述\n公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作\n员工信息有: 姓名  工资组成；部门分为：策划、美术、研发\n随机给10名员工分配部门和工资\n通过multimap进行信息的插入  key(部门编号) value(员工)\n分部门显示员工信息\n\n10.2 实现步骤\n创建10名员工，放到vector中\n遍历vector容器，取出每个员工，进行随机分组\n分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中\n分部门显示员工信息\n\n案例代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;iostream&gt;using namespace std;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;ctime&gt;/*- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发- 随机给10名员工分配部门和工资- 通过multimap进行信息的插入  key(部门编号) value(员工)- 分部门显示员工信息*/#define CEHUA  0#define MEISHU 1#define YANFA  2class Worker&#123;public:\tstring m_Name;\tint m_Salary;&#125;;void createWorker(vector&lt;Worker&gt;&amp;v)&#123;\tstring nameSeed = &quot;ABCDEFGHIJ&quot;;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tWorker worker;\t\tworker.m_Name = &quot;员工&quot;;\t\tworker.m_Name += nameSeed[i];\t\tworker.m_Salary = rand() % 10000 + 10000; // 10000 ~ 19999\t\t//将员工放入到容器中\t\tv.push_back(worker);\t&#125;&#125;//员工分组void setGroup(vector&lt;Worker&gt;&amp;v,multimap&lt;int,Worker&gt;&amp;m)&#123;\tfor (vector&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++)\t&#123;\t\t//产生随机部门编号\t\tint deptId = rand() % 3; // 0 1 2 \t\t//将员工插入到分组中\t\t//key部门编号，value具体员工\t\tm.insert(make_pair(deptId, *it));\t&#125;&#125;void showWorkerByGourp(multimap&lt;int,Worker&gt;&amp;m)&#123;\t// 0  A  B  C   1  D  E   2  F G ...\tcout &lt;&lt; &quot;策划部门：&quot; &lt;&lt; endl;\tmultimap&lt;int,Worker&gt;::iterator pos = m.find(CEHUA);\tint count = m.count(CEHUA); // 统计具体人数\tint index = 0;\tfor (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++)\t&#123;\t\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;\t&#125;\tcout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;美术部门： &quot; &lt;&lt; endl;\tpos = m.find(MEISHU);\tcount = m.count(MEISHU); // 统计具体人数\tindex = 0;\tfor (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)\t&#123;\t\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;\t&#125;\tcout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;研发部门： &quot; &lt;&lt; endl;\tpos = m.find(YANFA);\tcount = m.count(YANFA); // 统计具体人数\tindex = 0;\tfor (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)\t&#123;\t\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;\t&#125;&#125;int main() &#123;\tsrand((unsigned int)time(NULL));\t//1、创建员工\tvector&lt;Worker&gt;vWorker;\tcreateWorker(vWorker);\t//2、员工分组\tmultimap&lt;int, Worker&gt;mWorker;\tsetGroup(vWorker, mWorker);\t//3、分组显示员工\tshowWorkerByGourp(mWorker);\t////测试\t//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)\t//&#123;\t//\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;\t//&#125;\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n当数据以键值对形式存在，可以考虑用map 或 multimap\n\n","slug":"STL常用容器_2","date":"2021-07-01T10:49:00.000Z","categories_index":"STL","tags_index":"STL,Stack,queue,list,set/multiset,map/multimap","author_index":"kiyose408"},{"id":"d3af54b11f2dd7ea1cd5b0bad6f3d323","title":"STL常用容器1","content":"1 string容器1.1 string基本概念本质：\n\nstring是C++风格的字符串，而string本质上是一个类\n\nstring和char * 区别：\n\nchar * 是一个指针\nstring是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。\n\n特点：\nstring 类内部封装了很多成员方法\n例如：查找find，拷贝copy，删除delete 替换replace，插入insert\nstring管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责\n1.2 string构造函数构造函数原型：\n\nstring();          \t\t\t\t&#x2F;&#x2F;创建一个空的字符串 例如: string str;   string(const char* s);\t        &#x2F;&#x2F;使用字符串s初始化\nstring(const string&amp; str);    &#x2F;&#x2F;使用一个string对象初始化另一个string对象\nstring(int n, char c);           &#x2F;&#x2F;使用n个字符c初始化\n\n示例：\n123456789101112131415161718192021222324252627#include &lt;string&gt;//string构造void test01()&#123;\tstring s1; //创建空字符串，调用无参构造函数\tcout &lt;&lt; &quot;str1 = &quot; &lt;&lt; s1 &lt;&lt; endl;\tconst char* str = &quot;hello world&quot;;\tstring s2(str); //把c_string转换成了string\tcout &lt;&lt; &quot;str2 = &quot; &lt;&lt; s2 &lt;&lt; endl;\tstring s3(s2); //调用拷贝构造函数\tcout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl;\tstring s4(10, &#x27;a&#x27;);\tcout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：string的多种构造方式没有可比性，灵活使用即可\n1.3 string赋值操作功能描述：\n\n给string字符串进行赋值\n\n赋值的函数原型：\n\nstring&amp; operator=(const char* s);             &#x2F;&#x2F;char*类型字符串 赋值给当前的字符串\nstring&amp; operator=(const string &amp;s);         &#x2F;&#x2F;把字符串s赋给当前的字符串\nstring&amp; operator=(char c);                          &#x2F;&#x2F;字符赋值给当前的字符串\nstring&amp; assign(const char *s);                  &#x2F;&#x2F;把字符串s赋给当前的字符串\nstring&amp; assign(const char *s, int n);     &#x2F;&#x2F;把字符串s的前n个字符赋给当前的字符串\nstring&amp; assign(const string &amp;s);              &#x2F;&#x2F;把字符串s赋给当前字符串\nstring&amp; assign(int n, char c);                  &#x2F;&#x2F;用n个字符c赋给当前字符串\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041//赋值void test01()&#123;\tstring str1;\tstr1 = &quot;hello world&quot;;\tcout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;\tstring str2;\tstr2 = str1;\tcout &lt;&lt; &quot;str2 = &quot; &lt;&lt; str2 &lt;&lt; endl;\tstring str3;\tstr3 = &#x27;a&#x27;;\tcout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;\tstring str4;\tstr4.assign(&quot;hello c++&quot;);\tcout &lt;&lt; &quot;str4 = &quot; &lt;&lt; str4 &lt;&lt; endl;\tstring str5;\tstr5.assign(&quot;hello c++&quot;,5);\tcout &lt;&lt; &quot;str5 = &quot; &lt;&lt; str5 &lt;&lt; endl;\tstring str6;\tstr6.assign(str5);\tcout &lt;&lt; &quot;str6 = &quot; &lt;&lt; str6 &lt;&lt; endl;\tstring str7;\tstr7.assign(5, &#x27;x&#x27;);\tcout &lt;&lt; &quot;str7 = &quot; &lt;&lt; str7 &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n​\tstring的赋值方式很多，operator=  这种方式是比较实用的\n1.4 string字符串拼接功能描述：\n\n实现在字符串末尾拼接字符串\n\n函数原型：\n\nstring&amp; operator+=(const char* str);                   &#x2F;&#x2F;重载+&#x3D;操作符\nstring&amp; operator+=(const char c);                         &#x2F;&#x2F;重载+&#x3D;操作符\nstring&amp; operator+=(const string&amp; str);                &#x2F;&#x2F;重载+&#x3D;操作符\nstring&amp; append(const char *s);                                &#x2F;&#x2F;把字符串s连接到当前字符串结尾\nstring&amp; append(const char *s, int n);                 &#x2F;&#x2F;把字符串s的前n个字符连接到当前字符串结尾\nstring&amp; append(const string &amp;s);                           &#x2F;&#x2F;同operator+&#x3D;(const string&amp; str)\nstring&amp; append(const string &amp;s, int pos, int n);&#x2F;&#x2F;字符串s中从pos开始的n个字符连接到字符串结尾\n\n示例：\n12345678910111213141516171819202122232425262728293031323334//字符串拼接void test01()&#123;\tstring str1 = &quot;我&quot;;\tstr1 += &quot;爱玩游戏&quot;;\tcout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;\t\tstr1 += &#x27;:&#x27;;\tcout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;\tstring str2 = &quot;LOL DNF&quot;;\tstr1 += str2;\tcout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;\tstring str3 = &quot;I&quot;;\tstr3.append(&quot; love &quot;);\tstr3.append(&quot;game abcde&quot;, 4);\t//str3.append(str2);\tstr3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾\tcout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：字符串拼接的重载版本很多，初学阶段记住几种即可\n1.5 string查找和替换功能描述：\n\n查找：查找指定字符串是否存在\n替换：在指定的位置替换字符串\n\n函数原型：\n\nint find(const string&amp; str, int pos = 0) const;              &#x2F;&#x2F;查找str第一次出现位置,从pos开始查找\nint find(const char* s, int pos = 0) const;                      &#x2F;&#x2F;查找s第一次出现位置,从pos开始查找\nint find(const char* s, int pos, int n) const;                &#x2F;&#x2F;从pos位置查找s的前n个字符第一次位置\nint find(const char c, int pos = 0) const;                        &#x2F;&#x2F;查找字符c第一次出现位置\nint rfind(const string&amp; str, int pos = npos) const;      &#x2F;&#x2F;查找str最后一次位置,从pos开始查找\nint rfind(const char* s, int pos = npos) const;              &#x2F;&#x2F;查找s最后一次出现位置,从pos开始查找\nint rfind(const char* s, int pos, int n) const;              &#x2F;&#x2F;从pos查找s的前n个字符最后一次位置\nint rfind(const char c, int pos = 0) const;                        &#x2F;&#x2F;查找字符c最后一次出现位置\nstring&amp; replace(int pos, int n, const string&amp; str);        &#x2F;&#x2F;替换从pos开始n个字符为字符串str\nstring&amp; replace(int pos, int n,const char* s);                  &#x2F;&#x2F;替换从pos开始的n个字符为字符串s\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142//查找和替换void test01()&#123;\t//查找\tstring str1 = &quot;abcdefgde&quot;;\tint pos = str1.find(&quot;de&quot;);\tif (pos == -1)\t&#123;\t\tcout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;\t&#125;\t\tpos = str1.rfind(&quot;de&quot;);\tcout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;&#125;void test02()&#123;\t//替换\tstring str1 = &quot;abcdefgde&quot;;\tstr1.replace(1, 3, &quot;1111&quot;);\tcout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;&#125;int main() &#123;\t//test01();\t//test02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\nfind查找是从左往后，rfind从右往左\nfind找到字符串后返回查找的第一个字符位置，找不到返回-1\nreplace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串\n\n1.6 string字符串比较功能描述：\n\n字符串之间的比较\n\n比较方式：\n\n字符串比较是按字符的ASCII码进行对比\n\n&#x3D; 返回   0\n&gt; 返回   1 \n&lt; 返回  -1\n函数原型：\n\nint compare(const string &amp;s) const;   &#x2F;&#x2F;与字符串s比较\nint compare(const char *s) const;      &#x2F;&#x2F;与字符串s比较\n\n示例：\n12345678910111213141516171819202122232425262728293031//字符串比较void test01()&#123;\tstring s1 = &quot;hello&quot;;\tstring s2 = &quot;aello&quot;;\tint ret = s1.compare(s2);\tif (ret == 0) &#123;\t\tcout &lt;&lt; &quot;s1 等于 s2&quot; &lt;&lt; endl;\t&#125;\telse if (ret &gt; 0)\t&#123;\t\tcout &lt;&lt; &quot;s1 大于 s2&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;s1 小于 s2&quot; &lt;&lt; endl;\t&#125;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大\n1.7 string字符存取string中单个字符存取方式有两种\n\nchar&amp; operator[](int n);      &#x2F;&#x2F;通过[]方式取字符\nchar&amp; at(int n);                       &#x2F;&#x2F;通过at方法获取字符\n\n示例：\n1234567891011121314151617181920212223242526272829303132void test01()&#123;\tstring str = &quot;hello world&quot;;\tfor (int i = 0; i &lt; str.size(); i++)\t&#123;\t\tcout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\tfor (int i = 0; i &lt; str.size(); i++)\t&#123;\t\tcout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\t//字符修改\tstr[0] = &#x27;x&#x27;;\tstr.at(1) = &#x27;x&#x27;;\tcout &lt;&lt; str &lt;&lt; endl;\t&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at\n1.8 string插入和删除功能描述：\n\n对string字符串进行插入和删除字符操作\n\n函数原型：\n\nstring&amp; insert(int pos, const char* s);                  &#x2F;&#x2F;插入字符串\nstring&amp; insert(int pos, const string&amp; str);         &#x2F;&#x2F;插入字符串\nstring&amp; insert(int pos, int n, char c);                &#x2F;&#x2F;在指定位置插入n个字符c\nstring&amp; erase(int pos, int n = npos);                    &#x2F;&#x2F;删除从Pos开始的n个字符\n\n示例：\n12345678910111213141516171819//字符串插入和删除void test01()&#123;\tstring str = &quot;hello&quot;;\tstr.insert(1, &quot;111&quot;);\tcout &lt;&lt; str &lt;&lt; endl;\tstr.erase(1, 3);  //从1号位置开始3个字符\tcout &lt;&lt; str &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：插入和删除的起始下标都是从0开始\n1.9 string子串功能描述：\n\n从字符串中获取想要的子串\n\n函数原型：\n\nstring substr(int pos = 0, int n = npos) const;   &#x2F;&#x2F;返回由pos开始的n个字符组成的字符串\n\n示例：\n1234567891011121314151617181920212223//子串void test01()&#123;\tstring str = &quot;abcdefg&quot;;\tstring subStr = str.substr(1, 3);\tcout &lt;&lt; &quot;subStr = &quot; &lt;&lt; subStr &lt;&lt; endl;\tstring email = &quot;hello@sina.com&quot;;\tint pos = email.find(&quot;@&quot;);\tstring username = email.substr(0, pos);\tcout &lt;&lt; &quot;username: &quot; &lt;&lt; username &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：灵活的运用求子串功能，可以在实际开发中获取有效的信息\n2 vector容器2.1 vector基本概念功能：\n\nvector数据结构和数组非常相似，也称为单端数组\n\nvector与普通数组区别：\n\n不同之处在于数组是静态空间，而vector可以动态扩展\n\n动态扩展：\n\n并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间\n\nvector容器的迭代器是支持随机访问的迭代器\n\n\n2.2 vector构造函数功能描述：\n\n创建vector容器\n\n函数原型：\n\nvector&lt;T&gt; v;                \t\t     &#x2F;&#x2F;采用模板实现类实现，默认构造函数\nvector(v.begin(), v.end());          &#x2F;&#x2F;将v[begin(), end())区间中的元素拷贝给本身。\nvector(n, elem);                            &#x2F;&#x2F;构造函数将n个elem拷贝给本身。\nvector(const vector &amp;vec);         &#x2F;&#x2F;拷贝构造函数。\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;\tfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;void test01()&#123;\tvector&lt;int&gt; v1; //无参构造\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tv1.push_back(i);\t&#125;\tprintVector(v1);\tvector&lt;int&gt; v2(v1.begin(), v1.end());\tprintVector(v2);\tvector&lt;int&gt; v3(10, 100);\tprintVector(v3);\t\tvector&lt;int&gt; v4(v3);\tprintVector(v4);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：vector的多种构造方式没有可比性，灵活使用即可\n2.3 vector赋值操作功能描述：\n\n给vector容器进行赋值\n\n函数原型：\n\nvector&amp; operator=(const vector &amp;vec);&#x2F;&#x2F;重载等号操作符\n\nassign(beg, end);       &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。\n\nassign(n, elem);        &#x2F;&#x2F;将n个elem拷贝赋值给本身。\n\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;\tfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;//赋值操作void test01()&#123;\tvector&lt;int&gt; v1; //无参构造\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tv1.push_back(i);\t&#125;\tprintVector(v1);\tvector&lt;int&gt;v2;\tv2 = v1;\tprintVector(v2);\tvector&lt;int&gt;v3;\tv3.assign(v1.begin(), v1.end());\tprintVector(v3);\tvector&lt;int&gt;v4;\tv4.assign(10, 100);\tprintVector(v4);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结： vector赋值方式比较简单，使用operator&#x3D;，或者assign都可以\n2.4  vector容量和大小功能描述：\n\n对vector容器的容量和大小操作\n\n函数原型：\n\nempty();                             &#x2F;&#x2F;判断容器是否为空\n\ncapacity();                      &#x2F;&#x2F;容器的容量\n\nsize();                              &#x2F;&#x2F;返回容器中元素的个数\n\nresize(int num);             &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。\n​\t\t\t\t\t      &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。\n\nresize(int num, elem);  &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。\n​\t\t\t\t              &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除\n\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;\tfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;void test01()&#123;\tvector&lt;int&gt; v1;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tv1.push_back(i);\t&#125;\tprintVector(v1);\tif (v1.empty())\t&#123;\t\tcout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl;\t\tcout &lt;&lt; &quot;v1的容量 = &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;\t\tcout &lt;&lt; &quot;v1的大小 = &quot; &lt;&lt; v1.size() &lt;&lt; endl;\t&#125;\t//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充\tv1.resize(15,10);\tprintVector(v1);\t//resize 重新指定大小 ，若指定的更小，超出部分元素被删除\tv1.resize(5);\tprintVector(v1);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n判断是否为空  — empty\n返回元素个数  — size\n返回容器容量  — capacity\n重新指定大小  —  resize\n\n2.5 vector插入和删除功能描述：\n\n对vector容器进行插入、删除操作\n\n函数原型：\n\npush_back(ele);                                         &#x2F;&#x2F;尾部插入元素ele\npop_back();                                                &#x2F;&#x2F;删除最后一个元素\ninsert(const_iterator pos, ele);        &#x2F;&#x2F;迭代器指向位置pos插入元素ele\ninsert(const_iterator pos, int count,ele);&#x2F;&#x2F;迭代器指向位置pos插入count个元素ele\nerase(const_iterator pos);                     &#x2F;&#x2F;删除迭代器指向的元素\nerase(const_iterator start, const_iterator end);&#x2F;&#x2F;删除迭代器从start到end之间的元素\nclear();                                                        &#x2F;&#x2F;删除容器中所有元素\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;\tfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;//插入和删除void test01()&#123;\tvector&lt;int&gt; v1;\t//尾插\tv1.push_back(10);\tv1.push_back(20);\tv1.push_back(30);\tv1.push_back(40);\tv1.push_back(50);\tprintVector(v1);\t//尾删\tv1.pop_back();\tprintVector(v1);\t//插入\tv1.insert(v1.begin(), 100);\tprintVector(v1);\tv1.insert(v1.begin(), 2, 1000);\tprintVector(v1);\t//删除\tv1.erase(v1.begin());\tprintVector(v1);\t//清空\tv1.erase(v1.begin(), v1.end());\tv1.clear();\tprintVector(v1);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n尾插  — push_back\n尾删  — pop_back\n插入  — insert    (位置迭代器)\n删除  — erase  （位置迭代器）\n清空  —  clear\n\n2.6 vector数据存取功能描述：\n\n对vector中的数据的存取操作\n\n函数原型：\n\nat(int idx);      &#x2F;&#x2F;返回索引idx所指的数据\noperator[];        &#x2F;&#x2F;返回索引idx所指的数据\nfront();             &#x2F;&#x2F;返回容器中第一个数据元素\nback();              &#x2F;&#x2F;返回容器中最后一个数据元素\n\n示例：\n12345678910111213141516171819202122232425262728293031323334#include &lt;vector&gt;void test01()&#123;\tvector&lt;int&gt;v1;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tv1.push_back(i);\t&#125;\tfor (int i = 0; i &lt; v1.size(); i++)\t&#123;\t\tcout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\tfor (int i = 0; i &lt; v1.size(); i++)\t&#123;\t\tcout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\tcout &lt;&lt; &quot;v1的第一个元素为： &quot; &lt;&lt; v1.front() &lt;&lt; endl;\tcout &lt;&lt; &quot;v1的最后一个元素为： &quot; &lt;&lt; v1.back() &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n除了用迭代器获取vector容器中元素，[ ]和at也可以\nfront返回容器第一个元素\nback返回容器最后一个元素\n\n2.7 vector互换容器功能描述：\n\n实现两个容器内元素进行互换\n\n函数原型：\n\nswap(vec);  &#x2F;&#x2F; 将vec与本身的元素互换\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;\tfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;void test01()&#123;\tvector&lt;int&gt;v1;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tv1.push_back(i);\t&#125;\tprintVector(v1);\tvector&lt;int&gt;v2;\tfor (int i = 10; i &gt; 0; i--)\t&#123;\t\tv2.push_back(i);\t&#125;\tprintVector(v2);\t//互换容器\tcout &lt;&lt; &quot;互换后&quot; &lt;&lt; endl;\tv1.swap(v2);\tprintVector(v1);\tprintVector(v2);&#125;void test02()&#123;\tvector&lt;int&gt; v;\tfor (int i = 0; i &lt; 100000; i++) &#123;\t\tv.push_back(i);\t&#125;\tcout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;\tcout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;\tv.resize(3);\tcout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;\tcout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;\t//收缩内存\tvector&lt;int&gt;(v).swap(v); //匿名对象\tcout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;\tcout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;&#125;int main() &#123;\ttest01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：swap可以使两个容器互换，可以达到实用的收缩内存效果\n2.8 vector预留空间功能描述：\n\n减少vector在动态扩展容量时的扩展次数\n\n函数原型：\n\nreserve(int len);&#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化，元素不可访问。\n​\n\n\n示例：\n123456789101112131415161718192021222324252627282930#include &lt;vector&gt;void test01()&#123;\tvector&lt;int&gt; v;\t//预留空间\tv.reserve(100000);\tint num = 0;\tint* p = NULL;\tfor (int i = 0; i &lt; 100000; i++) &#123;\t\tv.push_back(i);\t\tif (p != &amp;v[0]) &#123;\t\t\tp = &amp;v[0];\t\t\tnum++;\t\t&#125;\t&#125;\tcout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123;\ttest01();    \tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：如果数据量较大，可以一开始利用reserve预留空间\n3 deque容器3.1 deque容器基本概念功能：\n\n双端数组，可以对头端进行插入删除操作\n\ndeque与vector区别：\n\nvector对于头部的插入删除效率低，数据量越大，效率越低\ndeque相对而言，对头部的插入删除速度回比vector快\nvector访问元素时的速度会比deque快,这和两者内部实现有关\n\ndeque内部工作原理:\ndeque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据\n中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间\n\ndeque容器的迭代器也是支持随机访问的\n\n3.2 deque构造函数功能描述：\n\ndeque容器构造\n\n函数原型：\n\ndeque&lt;T&gt; deqT;                      &#x2F;&#x2F;默认构造形式\ndeque(beg, end);                  &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。\ndeque(n, elem);                    &#x2F;&#x2F;构造函数将n个elem拷贝给本身。\ndeque(const deque &amp;deq);   &#x2F;&#x2F;拷贝构造函数\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123;\tfor (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;//deque构造void test01() &#123;\tdeque&lt;int&gt; d1; //无参构造函数\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\td1.push_back(i);\t&#125;\tprintDeque(d1);\tdeque&lt;int&gt; d2(d1.begin(),d1.end());\tprintDeque(d2);\tdeque&lt;int&gt;d3(10,100);\tprintDeque(d3);\tdeque&lt;int&gt;d4 = d3;\tprintDeque(d4);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：deque容器和vector容器的构造方式几乎一致，灵活使用即可\n3.3 deque赋值操作功能描述：\n\n给deque容器进行赋值\n\n函数原型：\n\ndeque&amp; operator=(const deque &amp;deq);          &#x2F;&#x2F;重载等号操作符\n\nassign(beg, end);                                           &#x2F;&#x2F;将 [beg, end)区间中的数据拷贝赋值给本身。\n\nassign(n, elem);                                             &#x2F;&#x2F;将n个elem拷贝赋值给本身。\n\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123;\tfor (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;//赋值操作void test01()&#123;\tdeque&lt;int&gt; d1;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\td1.push_back(i);\t&#125;\tprintDeque(d1);\tdeque&lt;int&gt;d2;\td2 = d1;\tprintDeque(d2);\tdeque&lt;int&gt;d3;\td3.assign(d1.begin(), d1.end());\tprintDeque(d3);\tdeque&lt;int&gt;d4;\td4.assign(10, 100);\tprintDeque(d4);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：deque赋值操作也与vector相同，需熟练掌握\n3.4 deque大小操作功能描述：\n\n对deque容器的大小进行操作\n\n函数原型：\n\ndeque.empty();                       &#x2F;&#x2F;判断容器是否为空\n\ndeque.size();                         &#x2F;&#x2F;返回容器中元素的个数\n\ndeque.resize(num);                &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以默认值填充新位置。\n​\t\t\t                             &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。\n\ndeque.resize(num, elem);     &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以elem值填充新位置。\n​                                                     &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。\n​\n\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123;\tfor (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;//大小操作void test01()&#123;\tdeque&lt;int&gt; d1;\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\td1.push_back(i);\t&#125;\tprintDeque(d1);\t//判断容器是否为空\tif (d1.empty()) &#123;\t\tcout &lt;&lt; &quot;d1为空!&quot; &lt;&lt; endl;\t&#125;\telse &#123;\t\tcout &lt;&lt; &quot;d1不为空!&quot; &lt;&lt; endl;\t\t//统计大小\t\tcout &lt;&lt; &quot;d1的大小为：&quot; &lt;&lt; d1.size() &lt;&lt; endl;\t&#125;\t//重新指定大小\td1.resize(15, 1);\tprintDeque(d1);\td1.resize(5);\tprintDeque(d1);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\ndeque没有容量的概念\n判断是否为空   — empty\n返回元素个数   — size\n重新指定个数   — resize\n\n3.5 deque 插入和删除功能描述：\n\n向deque容器中插入和删除数据\n\n函数原型：\n两端插入操作：\n\npush_back(elem);          &#x2F;&#x2F;在容器尾部添加一个数据\npush_front(elem);        &#x2F;&#x2F;在容器头部插入一个数据\npop_back();                   &#x2F;&#x2F;删除容器最后一个数据\npop_front();                 &#x2F;&#x2F;删除容器第一个数据\n\n指定位置操作：\n\ninsert(pos,elem);         &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。\n\ninsert(pos,n,elem);     &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。\n\ninsert(pos,beg,end);    &#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。\n\nclear();                           &#x2F;&#x2F;清空容器的所有数据\n\nerase(beg,end);             &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。\n\nerase(pos);                    &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。\n​\n​\n\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123;\tfor (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;//两端操作void test01()&#123;\tdeque&lt;int&gt; d;\t//尾插\td.push_back(10);\td.push_back(20);\t//头插\td.push_front(100);\td.push_front(200);\tprintDeque(d);\t//尾删\td.pop_back();\t//头删\td.pop_front();\tprintDeque(d);&#125;//插入void test02()&#123;\tdeque&lt;int&gt; d;\td.push_back(10);\td.push_back(20);\td.push_front(100);\td.push_front(200);\tprintDeque(d);\td.insert(d.begin(), 1000);\tprintDeque(d);\td.insert(d.begin(), 2,10000);\tprintDeque(d);\tdeque&lt;int&gt;d2;\td2.push_back(1);\td2.push_back(2);\td2.push_back(3);\td.insert(d.begin(), d2.begin(), d2.end());\tprintDeque(d);&#125;//删除void test03()&#123;\tdeque&lt;int&gt; d;\td.push_back(10);\td.push_back(20);\td.push_front(100);\td.push_front(200);\tprintDeque(d);\td.erase(d.begin());\tprintDeque(d);\td.erase(d.begin(), d.end());\td.clear();\tprintDeque(d);&#125;int main() &#123;\t//test01();\t//test02();    test03();    \tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n插入和删除提供的位置是迭代器！\n尾插   —  push_back\n尾删   —  pop_back\n头插   —  push_front\n头删   —  pop_front\n\n3.6 deque 数据存取功能描述：\n\n对deque 中的数据的存取操作\n\n函数原型：\n\nat(int idx);      &#x2F;&#x2F;返回索引idx所指的数据\noperator[];       &#x2F;&#x2F;返回索引idx所指的数据\nfront();             &#x2F;&#x2F;返回容器中第一个数据元素\nback();              &#x2F;&#x2F;返回容器中最后一个数据元素\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123;\tfor (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;//数据存取void test01()&#123;\tdeque&lt;int&gt; d;\td.push_back(10);\td.push_back(20);\td.push_front(100);\td.push_front(200);\tfor (int i = 0; i &lt; d.size(); i++) &#123;\t\tcout &lt;&lt; d[i] &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\tfor (int i = 0; i &lt; d.size(); i++) &#123;\t\tcout &lt;&lt; d.at(i) &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;\tcout &lt;&lt; &quot;front:&quot; &lt;&lt; d.front() &lt;&lt; endl;\tcout &lt;&lt; &quot;back:&quot; &lt;&lt; d.back() &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n除了用迭代器获取deque容器中元素，[ ]和at也可以\nfront返回容器第一个元素\nback返回容器最后一个元素\n\n3.7  deque 排序功能描述：\n\n利用算法实现对deque容器进行排序\n\n算法：\n\nsort(iterator beg, iterator end)  &#x2F;&#x2F;对beg和end区间内元素进行排序\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435#include &lt;deque&gt;#include &lt;algorithm&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123;\tfor (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;void test01()&#123;\tdeque&lt;int&gt; d;\td.push_back(10);\td.push_back(20);\td.push_front(100);\td.push_front(200);\tprintDeque(d);\tsort(d.begin(), d.end());\tprintDeque(d);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：sort算法非常实用，使用时包含头文件 algorithm即可\n4 案例-评委打分4.1 案例描述有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。\n4.2 实现步骤\n创建五名选手，放到vector中\n遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中\nsort算法对deque容器中分数排序，去除最高和最低分\ndeque容器遍历一遍，累加总分\n获取平均分\n\n示例代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//选手类class Person&#123;public:\tPerson(string name, int score)\t&#123;\t\tthis-&gt;m_Name = name;\t\tthis-&gt;m_Score = score;\t&#125;\tstring m_Name; //姓名\tint m_Score;  //平均分&#125;;void createPerson(vector&lt;Person&gt;&amp;v)&#123;\tstring nameSeed = &quot;ABCDE&quot;;\tfor (int i = 0; i &lt; 5; i++)\t&#123;\t\tstring name = &quot;选手&quot;;\t\tname += nameSeed[i];\t\tint score = 0;\t\tPerson p(name, score);\t\t//将创建的person对象 放入到容器中\t\tv.push_back(p);\t&#125;&#125;//打分void setScore(vector&lt;Person&gt;&amp;v)&#123;\tfor (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)\t&#123;\t\t//将评委的分数 放入到deque容器中\t\tdeque&lt;int&gt;d;\t\tfor (int i = 0; i &lt; 10; i++)\t\t&#123;\t\t\tint score = rand() % 41 + 60;  // 60 ~ 100\t\t\td.push_back(score);\t\t&#125;\t\t//cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;\t\t//for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)\t\t//&#123;\t\t//\tcout &lt;&lt; *dit &lt;&lt; &quot; &quot;;\t\t//&#125;\t\t//cout &lt;&lt; endl;\t\t//排序\t\tsort(d.begin(), d.end());\t\t//去除最高和最低分\t\td.pop_back();\t\td.pop_front();\t\t//取平均分\t\tint sum = 0;\t\tfor (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)\t\t&#123;\t\t\tsum += *dit; //累加每个评委的分数\t\t&#125;\t\tint avg = sum / d.size();\t\t//将平均分 赋值给选手身上\t\tit-&gt;m_Score = avg;\t&#125;&#125;void showScore(vector&lt;Person&gt;&amp;v)&#123;\tfor (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)\t&#123;\t\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 平均分： &quot; &lt;&lt; it-&gt;m_Score &lt;&lt; endl;\t&#125;&#125;int main() &#123;\t//随机数种子\tsrand((unsigned int)time(NULL));\t//1、创建5名选手\tvector&lt;Person&gt;v;  //存放选手容器\tcreatePerson(v);\t//测试\t//for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)\t//&#123;\t//\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;\t//&#125;\t//2、给5名选手打分\tsetScore(v);\t//3、显示最后得分\tshowScore(v);\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结： 选取不同的容器操作数据，可以提升代码的效率\n","slug":"STL常用容器_1","date":"2021-06-27T10:49:00.000Z","categories_index":"STL","tags_index":"vector,STL,String,deque","author_index":"kiyose408"},{"id":"d29599c9d95bf25edb61aa3cfaccef26","title":"STL库入门","content":"STL初识1 STL的诞生\n长久以来，软件界一直希望建立一种可重复利用的东西\n\nC++的面向对象和泛型编程思想，目的就是复用性的提升\n\n大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作\n\n为了建立数据结构和算法的一套标准,诞生了STL\n​\n\n\n2 STL基本概念\nSTL(Standard Template Library,标准模板库)\nSTL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator)\n容器和算法之间通过迭代器进行无缝连接。\nSTL 几乎所有的代码都采用了模板类或者模板函数\n\n3 STL六大组件STL大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器\n\n容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。\n算法：各种常用的算法，如sort、find、copy、for_each等\n迭代器：扮演了容器与算法之间的胶合剂。\n仿函数：行为类似函数，可作为算法的某种策略。\n适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。\n空间配置器：负责空间的配置与管理。\n\n4  STL中容器、算法、迭代器容器：置物之所也\nSTL容器就是将运用最广泛的一些数据结构实现出来\n常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等\n这些容器分为序列式容器和关联式容器两种:\n​\t序列式容器:强调值的排序，序列式容器中的每个元素均有固定的位置。    关联式容器:二叉树结构，各元素之间没有严格的物理上的顺序关系\n算法：问题之解法也\n有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)\n算法分为:质变算法和非质变算法。\n质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等\n非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等\n迭代器：容器和算法之间粘合剂\n提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。\n每个容器都有自己专属的迭代器\n迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针\n迭代器种类：\n\n\n\n种类\n功能\n支持运算\n\n\n\n输入迭代器\n对数据的只读访问\n只读，支持++、&#x3D;&#x3D;、！&#x3D;\n\n\n输出迭代器\n对数据的只写访问\n只写，支持++\n\n\n前向迭代器\n读写操作，并能向前推进迭代器\n读写，支持++、&#x3D;&#x3D;、！&#x3D;\n\n\n双向迭代器\n读写操作，并能向前和向后操作\n读写，支持++、–，\n\n\n随机访问迭代器\n读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器\n读写，支持++、–、[n]、-n、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;\n\n\n常用的容器中迭代器种类为双向迭代器，和随机访问迭代器\n5 容器算法迭代器初识了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力\nSTL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器\n5.1 vector存放内置数据类型容器：     vector\n算法：     for_each\n迭代器： vector&lt;int&gt;::iterator\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;vector&gt;#include &lt;algorithm&gt;void MyPrint(int val)&#123;\tcout &lt;&lt; val &lt;&lt; endl;&#125;void test01() &#123;\t//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型\tvector&lt;int&gt; v;\t//向容器中放数据\tv.push_back(10);\tv.push_back(20);\tv.push_back(30);\tv.push_back(40);\t//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素\t//v.begin()返回迭代器，这个迭代器指向容器中第一个数据\t//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置\t//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型\tvector&lt;int&gt;::iterator pBegin = v.begin();\tvector&lt;int&gt;::iterator pEnd = v.end();\t//第一种遍历方式：\twhile (pBegin != pEnd) &#123;\t\tcout &lt;&lt; *pBegin &lt;&lt; endl;\t\tpBegin++;\t&#125;\t\t//第二种遍历方式：\tfor (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\t\tcout &lt;&lt; *it &lt;&lt; endl;\t&#125;\tcout &lt;&lt; endl;\t//第三种遍历方式：\t//使用STL提供标准遍历算法  头文件 algorithm\tfor_each(v.begin(), v.end(), MyPrint);&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n5.2 Vector存放自定义数据类型学习目标：vector中存放自定义数据类型，并打印输出\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;vector&gt;#include &lt;string&gt;//自定义数据类型class Person &#123;public:\tPerson(string name, int age) &#123;\t\tmName = name;\t\tmAge = age;\t&#125;public:\tstring mName;\tint mAge;&#125;;//存放对象void test01() &#123;\tvector&lt;Person&gt; v;\t//创建数据\tPerson p1(&quot;aaa&quot;, 10);\tPerson p2(&quot;bbb&quot;, 20);\tPerson p3(&quot;ccc&quot;, 30);\tPerson p4(&quot;ddd&quot;, 40);\tPerson p5(&quot;eee&quot;, 50);\tv.push_back(p1);\tv.push_back(p2);\tv.push_back(p3);\tv.push_back(p4);\tv.push_back(p5);\tfor (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\t\tcout &lt;&lt; &quot;Name:&quot; &lt;&lt; (*it).mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it).mAge &lt;&lt; endl;\t&#125;&#125;//放对象指针void test02() &#123;\tvector&lt;Person*&gt; v;\t//创建数据\tPerson p1(&quot;aaa&quot;, 10);\tPerson p2(&quot;bbb&quot;, 20);\tPerson p3(&quot;ccc&quot;, 30);\tPerson p4(&quot;ddd&quot;, 40);\tPerson p5(&quot;eee&quot;, 50);\tv.push_back(&amp;p1);\tv.push_back(&amp;p2);\tv.push_back(&amp;p3);\tv.push_back(&amp;p4);\tv.push_back(&amp;p5);\tfor (vector&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\t\tPerson * p = (*it);\t\tcout &lt;&lt; &quot;Name:&quot; &lt;&lt; p-&gt;mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;\t&#125;&#125;int main() &#123;\ttest01();    \ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n5.3 Vector容器嵌套容器学习目标：容器中嵌套容器，我们将所有数据进行遍历输出\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;vector&gt;//容器嵌套容器void test01() &#123;\tvector&lt; vector&lt;int&gt; &gt;  v;\tvector&lt;int&gt; v1;\tvector&lt;int&gt; v2;\tvector&lt;int&gt; v3;\tvector&lt;int&gt; v4;\tfor (int i = 0; i &lt; 4; i++) &#123;\t\tv1.push_back(i + 1);\t\tv2.push_back(i + 2);\t\tv3.push_back(i + 3);\t\tv4.push_back(i + 4);\t&#125;\t//将容器元素插入到vector v中\tv.push_back(v1);\tv.push_back(v2);\tv.push_back(v3);\tv.push_back(v4);\tfor (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;\t\tfor (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) &#123;\t\t\tcout &lt;&lt; *vit &lt;&lt; &quot; &quot;;\t\t&#125;\t\tcout &lt;&lt; endl;\t&#125;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\n\n\n\n\n","slug":"STL库入门","date":"2021-06-23T10:49:00.000Z","categories_index":"STL","tags_index":"C++,STL","author_index":"kiyose408"},{"id":"aa58dd8d3b218c61e8320d0bbec359ae","title":"类的访问控制","content":"私有和公有一个类里有方法和成员变量，public关键字标识后，public下的方法和变量都变为公有函数。private关键字标识后，private关键字下的方法和成员变量都变为私有。默认情况下，如果不声明public，class中所有的方法和成员都是私有的。如果不声明private, struct中所有的方法和成员都是公有的。\n友元上一篇，我们将print，read等非Sales_data类的全局函数声明为Sales_data类的友元函数，所以print，read可以访问Sales_data类的私有成员。这里再次回忆一下Sales_data类。\n123456789101112131415161718192021222324252627282930class Sales_data&#123;public:    //通过default实现默认构造    // Sales_data() = default;    //显示实现默认构造    Sales_data() : bookNo(&quot;&quot;), units_sold(0), revenue(0.0) &#123;&#125;    // copy构造，根据Sales_data类型对象构造一个新对象    Sales_data(const Sales_data &amp;sa);    Sales_data(const std::string &amp;s) : bookNo(s) &#123;&#125;    Sales_data(const std::string &amp;s, unsigned n, double p)        : bookNo(s), units_sold(n), revenue(p * n) &#123;&#125;    Sales_data(std::istream &amp;is);    //返回图书号    std::string isbn() const &#123; return bookNo; &#125;    //获取平均单价    double avg_price() const;    //将一个Sales_data对象合并到当前类对象    Sales_data &amp;combine(const Sales_data &amp;);    friend std::ostream &amp;print(std::ostream &amp;, const Sales_data &amp;);    friend std::istream &amp;read(std::istream &amp;, Sales_data &amp;);private:    //图书编号    std::string bookNo;    //销量    unsigned units_sold = 0;    //收入    double revenue = 0.0;&#125;;\n\n封装有两个重要的优点： \n\n确保用户代码不会无意间破坏封装对象的状态。 \n被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。\n\n友元的声明友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）。因此，我们的Sales_data头文件应该为read、print和add提供独立的声明（除了类内部的友元声明之外）。所以我在Sales_data类的头文件里声明了这些函数\n1234// Sales_data的非成员接口extern Sales_data add(const Sales_data &amp;, const Sales_data &amp;);extern std::ostream &amp;print(std::ostream &amp;, const Sales_data &amp;);extern std::istream &amp;read(std::istream &amp;, Sales_data &amp;);\n\n隐藏类型定义我们可以在类中定义一种新的类型，这种类型对于外部是隐藏内部实现的，外部不知道该类型是什么。\n12345678910class Screen&#123;public:    typedef std::string::size_type pos;private:    pos cursor = 0;    pos height = 0, width = 0;    std::string contents;&#125;;\n\n用来定义类型的成员必须先定义后使用，这一点与普通成员有所区别，具体原因将在7.4.1节（C++PrimerPlus第254页）解释。因此，类型成员通常出现在类开始的地方。\ninline成员函数所谓内联函数就是在编译时展开，减少运行时开销的一种手段，可以通过inline关键字声明，也可以在类的cpp文件里定义函数时前面指明inline，当然一个类的成员函数在类的头文件实现了，那它也是内联函数，我们完善Screen类，用以下三种方式实现内联函数\n1234567891011121314151617181920212223242526class Screen&#123;public:    typedef std::string::size_type pos;    //因为Screen有另一个构造函数    //所以要实现一个默认构造函数    Screen() = default;    // cursor被初始化为0    Screen(pos ht, pos wd, char c) : height(ht), width(wd), contents(ht * wd, c) &#123;&#125;    //读取光标处字符    char get() const    &#123;        //隐式内联        return contents[cursor];    &#125;    //显示内联    inline char get(pos ht, pos wd) const;    //能在之后被设为内联    Screen &amp;move(pos r, pos c);private:    pos cursor = 0;    pos height = 0, width = 0;    std::string contents;&#125;;\n\n我们可以在类的内部把inline作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义：虽然我们无须在声明和定义的地方同时说明inline，但这么做其实是合法的。不过，最好只在类外部定义的地方说明inline，这样可以使类更容易理解。\n重载成员函数类的成员函数同样支持重载。只要函数名相同，参数列表不同即可。\nmutable属性如果一个成员变量被指明mutable属性，则无论对象是否为const，无论成员函数是否为const，该成员变量都可以被修改。 我们给Screen定义一个mutable成员变量access_ctr，以及一个const成员函数some_member，并在该函数中修改access_ctr变量。\n1234567891011121314151617181920212223242526272829class Screen&#123;public:    typedef std::string::size_type pos;    //因为Screen有另一个构造函数    //所以要实现一个默认构造函数    Screen() = default;    // cursor被初始化为0    Screen(pos ht, pos wd, char c) : height(ht), width(wd), contents(ht * wd, c) &#123;&#125;    //读取光标处字符    char get() const    &#123;        //隐式内联        return contents[cursor];    &#125;    //显示内联    inline char get(pos ht, pos wd) const;    //能在之后被设为内联    Screen &amp;move(pos r, pos c);    void some_member() const;private:    pos cursor = 0;    pos height = 0, width = 0;    std::string contents;    //即使在一个const对象里access_ctr也可被修改    mutable size_t access_ctr;&#125;;\n\n实现some_member的一个成员变量\n1234void Screen::some_member() const&#123; //在const函数中也可以修改access_ctr    ++access_ctr;&#125;\n\n链式调用当我们通过成员函数内部返回*this，也就是类对象本身，则可以继续链式调用其内部的成员函数，比如我们通过重载实现两个set函数\n1234567891011Screen &amp;Screen::set(char c)&#123;    contents[cursor] = c;    return *this;&#125;Screen &amp;Screen::set(pos r, pos col, char ch)&#123;    //给定位置设置新值    contents[r * width + col] = ch;    return *this;&#125;\n\n链式调用\n1234Screen::pos row = 3;Screen::pos col = 4;Screen screen(3, 4, &#x27;c&#x27;);screen.move(2, 3).set(&#x27;#&#x27;);\n\n从const成员返回的*this是常量指针,如果我们实现一个display的const函数，\n123456const Screen &amp;Screen::display(ostream &amp;os) const&#123;    os &lt;&lt; &quot;width is &quot; &lt;&lt; width &lt;&lt; &quot; &quot;       &lt;&lt; &quot;height is &quot; &lt;&lt; height &lt;&lt; endl;    return *this;&#125;\n\n如果按照如下链式调用编译器将报错,因为display返回const Screen&amp; 类型\n1screen.display(cout).move(2, 3).set(&#x27;#&#x27;);\n\n所以我们可以通过重载实现链式调用，实现一个返回const Screen &amp;类型的display函数和一个Screen &amp;类型的display函数, 这两个display函数内部调用do_display函数，因为const函数只能调用const函数，所以我们先实现display函数，他是一个const函数\n12345void Screen::do_display(ostream &amp;os) const&#123;    os &lt;&lt; &quot;width is &quot; &lt;&lt; width &lt;&lt; &quot; &quot;       &lt;&lt; &quot;height is &quot; &lt;&lt; height &lt;&lt; endl;&#125;\n\n再实现两个重载的display函数\n1234567891011const Screen &amp;Screen::display(ostream &amp;os) const&#123;    do_display(os);    return *this;&#125;Screen &amp;Screen::display(ostream &amp;os)&#123;    do_display(os);    return *this;&#125;\n\n这样编译器就会根据类型动态选择display的版本\n1234Screen screen(3, 4, &#x27;c&#x27;);screen.display(cout).move(2, 3).set(&#x27;#&#x27;);const Screen cscreen(2, 1, &#x27; &#x27;);cscreen.display(cout);\n\n类类型和声明1234567891011class First&#123;    int memi;    int getMem();&#125;;struct Second&#123;    int memi;    int getMem();&#125;;\n\n如上我们定义了两个类型，下面的赋值会报错，因为类内的成员虽然一致，但是不同的类就是不同的类型\n123First obj1;//编译报错，obj1和obj2不是一个类型 Second obj2 = obj1;\n\n我们可以不定义类，先进行类的声明\n1class Bags;\n\n这种声明有时被称作前向声明（forward declaration），它向程序中引入了名字Screen并且指明Bags是一种类类型。对于类型Bags来说，在它声明之后定义之前是一个不完全类型（incomplete type），也就是说，此时我们已知Bags是一个类类型，但是不清楚它到底包含哪些成员。\n不完全类型只能在非常有限的情景下使用： 可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。\n直到类被定义之后数据成员才能被声明成这种类类型。我们必须首先完成类的定义，然后编译器才能知道存储该数据成员需要多少空间。 因为只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。 然而，一旦一个类的名字出现后，它就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针：\n123456class Link_screen&#123;    Screen window;    Link_screen *next;    Link_screen *prev;&#125;;\n\n友元类和成员函数可以将一个类A声明为另一个类B的友元，则A类对象可以访问B类对象的私有成员。\n1234567class Screen&#123;public:    // Window_mgr可以访问Screen类的私有部分    friend class Window_mgr;    //Screen类的其他部分......&#125;;\n\nWindow_mgr类可以访问Screen类的私有成员，通过class前向声明了Window_mgr类。 接下来我们定义Window_mgr类\n12345678910111213141516171819class Window_mgr&#123;public:    //窗口中每个屏幕的编号    using ScreenIndex = std::vector&lt;Screen&gt;::size_type;    //按照编号将指定的Screen重置为空白    void clear(ScreenIndex);private:    std::vector&lt;Screen&gt; screens&#123;Screen(24, 80, &#x27; &#x27;)&#125;;&#125;;void Window_mgr::clear(ScreenIndex i)&#123;    // s是一个Screen的引用，指向我们想清空的屏幕    Screen &amp;s = screens[i];    //清空屏幕    s.contents = string(s.height * s.width, &#x27; &#x27;);&#125;\n\n也可以让成员函数作为友元\n1234567class Screen&#123;public:    // Window_mgr可以访问Screen类的私有部分    friend void Window_mgr::clear(ScreenIndex);    //Screen类的其他部分......&#125;;\n\n· 首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。 · 接下来定义Screen，包括对于clear的友元声明。 · 最后定义clear，此时它才可以使用Screen的成员。\n类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中\n","slug":"类的访问控制","date":"2021-06-17T10:49:36.000Z","categories_index":"类的认识","tags_index":"C++,成员函数,友元","author_index":"kiyose408"},{"id":"f7867369ce6c59c22c6335141c563f0b","title":"类和对象","content":"类\n\n\n\n\n\n提示\n我们要设计一个Sales_data类来反映图书的销售情况，它把书籍的销售数据抽象化。就像“鸟”类可以用来描述鹦鹉或麻雀这类对象，“Sales_data”类则用来表示具体的图书销售记录。通过创建Sales_data对象并输入相关数据，系统能够自动统计该书的销售量和总收入。简而言之，Sales_data类是图书录入系统中用于高效管理销售信息的核心组件。如果我们实现Sales_data类，外部调用是这样的\n\n1234567891011121314151617181920212223242526272829303132333435363738void dealSales()&#123;    // 初始化汇总的Sales_data对象    Sales_data total;        // 读取第一条销售记录    if (read(std::cin, total))    &#123;        // 用于暂存每条新读取的销售记录        Sales_data trans;                // 循环读取后续销售记录        while (read(std::cin, trans))        &#123;            // 检查当前记录与已汇总记录的ISBN是否一致            if (total.isbn() == trans.isbn())            &#123;                // 若一致，则合并当前记录到总记录中                total.combine(trans);            &#125;            else            &#123;                // 若不一致，输出当前累计的销售数据，并开始新的累加周期                print(std::cout, total) &lt;&lt; std::endl;                // 将当前记录设为新的累加起点                total = trans;            &#125;        &#125;                // 输出最后一个或唯一一个汇总周期的销售数据        print(std::cout, total) &lt;&lt; std::endl;    &#125;    else    &#123;        // 若无数据可读，则提示错误        std::cerr &lt;&lt; &quot;No sales data input detected.&quot; &lt;&lt; std::endl;    &#125;&#125;\n\n在我们的图书销售管理系统中，Sales_data类被精心设计以封装与图书销售记录相关的操作，具体包括关键的接口功能：\n\nISBN 查询成员函数 (isbn()): 此成员函数允许用户获取某个Sales_data对象所代表图书的ISBN编号，便于识别和分类不同的图书记录。\n\n合并销售数据成员函数 (combine()): 该功能使得一个Sales_data对象能够累积另一个相同ISBN图书的销售数据，这对于统计特定图书的总体销售情况极为重要。\n\n加法运算函数 (add()): 提供了一个静态方法或友元函数形式的加法操作，能够直接将两个Sales_data对象相加，计算合并后的销售总量和总收入，简化多记录处理流程。\n\n读取数据成员函数 (read()): 该成员负责从输入流（如标准输入std::cin）读取销售记录数据，并根据格式填充到Sales_data对象中，增强了程序的交互性和灵活性。\n\n打印输出成员函数 (print()): 允许将Sales_data对象的内容格式化输出到指定的输出流（如std::cout），方便查看和记录销售统计数据，提高了系统的可审计性和透明度。\n\n\n基于以上设计原则定义的Sales_data类，不仅能够高效地管理单本图书的销售信息，还能轻松整合并分析整个图书目录的销售概况，为图书录入系统提供了强大的数据处理支持。\n1234567891011121314151617181920212223242526272829303132#ifndef __CLASS_H__#define __CLASS_H__class Sales_data&#123;public:    //通过default实现默认构造    // Sales_data() = default;    //显示实现默认构造    Sales_data() : bookNo(&quot;&quot;), units_sold(0), revenue(0.0) &#123;&#125;    // copy构造，根据Sales_data类型对象构造一个新对象    Sales_data(const Sales_data &amp;sa);    //返回图书号    std::string isbn() const &#123; return bookNo; &#125;    //获取平均单价    double avg_price() const;    //将一个Sales_data对象合并到当前类对象    Sales_data &amp;combine(const Sales_data &amp;);private:    //图书编号    std::string bookNo;    //销量    unsigned units_sold = 0;    //收入    double revenue = 0.0;&#125;;// Sales_data的非成员接口extern Sales_data add(const Sales_data &amp;, const Sales_data &amp;);extern std::ostream &amp;print(std::ostream &amp;, const Sales_data &amp;);extern std::istream &amp;read(std::istream &amp;, Sales_data &amp;);extern void dealSales();#endif\n\n接下来我们逐个部分介绍\n成员函数在Sales_data类中，isbn成员函数扮演着至关重要的角色，它直接反映出类实例所关联的图书ISBN号。此函数之所以能访问bookNo成员，得益于C++中成员函数对this指针的隐式使用。当调用如a.isbn()时，this自动指向调用该函数的Sales_data对象a，从而允许间接访问a的bookNo属性。\n关于this指针的特性：\n\n\n\n\n\n\n\n\n\n类型与限制：在非const成员函数中，this是一个指向调用对象的非常量版本的常量指针(Sales_data *const)，确保指针本身不可修改，但可通过解引用来修改对象状态。在const成员函数中，this变为指向常量对象的指针(const Sales_data *const)，意味着既不能改变this指针自身，也不能通过它修改对象的状态，确保了常量成员函数的纯只读性质。\n常量成员函数的意义在于，它们能被常量对象或者通过常量引用&#x2F;指针访问的对象安全调用，保证了数据的不可变性，增加了函数使用的灵活性和安全性。\n至于成员函数的实现细节：\n\n\n\n\n\n\n\n\n\n编译器处理流程：首先，编译器处理类的成员声明，随后才是成员函数的具体定义。这意味着成员函数可以在声明后定义，且能自由引用类内的其他成员，不受定义顺序限制，如isbn访问bookNo。外部定义规则：若成员函数在类外定义，需严格遵循其在类内声明的签名，包括返回类型、参数列表及函数名，并在必要时明确const限定符以匹配const成员函数的声明。函数定义前还需冠以类名，以表明其所属关系，如Sales_data::isbn() const {…}。\n综上所述，通过精确控制成员函数的const属性和合理利用this指针，Sales_data类实现了对图书数据的高效且安全的操作，无论是直接访问属性还是通过复杂的业务逻辑如数据合并与统计。\n1234567double Sales_data::avg_price() const&#123;    if (units_sold)        return revenue / units_sold;    else        return 0;&#125;\n\n定义返回this对象的combine函数\n1234567Sales_data &amp;Sales_data::combine(const Sales_data &amp;sa)&#123;    this-&gt;units_sold += sa.units_sold;    this-&gt;revenue += sa.revenue;    //返回调用该函数的对象    return *this;&#125;\n\n核心亮点在于该函数的返回类型与返回语句，这两个方面尤为值得关注。在设计函数时，若其功能紧密贴近某内置运算符，我们应确保该函数行为与该运算符保持高度一致。具体而言，借鉴内置赋值运算符的逻辑，其特性在于将左侧运算对象作为左值返回。因此，在自定义类似功能时，也应遵循这一机制，以增强代码的自然性和可预测性。\n类相关非成员函数非成员函数的定义方式遵循常规函数的规则，关键在于巧妙地分离声明与定义。当面临这样一个场景：某函数虽在逻辑上隶属某类但未置于类内部实现时，最佳实践是将此函数与类的声明（而非实际定义）置于同一头文件中。如此一来，用户只需包含这单一文件，便能无缝访问类接口的所有组成部分，极大提升了代码的整合性与易用性。\n12345678910111213std::ostream &amp;print(std::ostream &amp;os, const Sales_data &amp;item)&#123;    os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot;       &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_price();    return os;&#125;std::istream &amp;read(std::istream &amp;is, Sales_data &amp;item)&#123;    double price = 0;    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;    return is;&#125;\n\n在此情况下，编译过程将会遇到错误提示，根本原因在于尝试从非成员函数内部直接访问了类对象的私有成员。由于Sales_data类通过private关键字将其成员变量严格设定为私有，这自然而然地限制了外部非成员函数的直接触及。为了解决这一权限冲突，合理的策略是在类的声明部分明智地引入友元函数声明。此举有效授予该函数特殊权限，使其能够越过通常的访问限制，顺畅地与Sales_data类的私有成员进行交互。\n12friend std::ostream &amp;print(std::ostream &amp;, const Sales_data &amp;);friend std::istream &amp;read(std::istream &amp;, Sales_data &amp;);\n\n这样print和read声明为Sales_item类的友元函数，就代表其能访问Sales_item类的私有成员了。 接下来我们同样定义add函数.\n123456Sales_data add(const Sales_data &amp;sa1, const Sales_data &amp;sa2)&#123;    Sales_data total = sa1;    total.combine(sa2);    return total;&#125;\n\n\n鉴于combine函数已被设为public，这意味着它对外部可见并可被直接调用，因此无需将add函数特别指定为Sales_item类的友元函数。\n在此过程中，新创建了一个Sales_data类型的对象total，旨在积累两笔交易信息之和。通过使用sa1的复制构造函数初始化total，实质上是深拷贝了sa1的所有数据成员——包括bookNo、units_sold及revenue至total，实现了两者状态的一致性。\n随后，通过调用total.combine(sa2)方法，将sa2的销售单位数(units_sold)和收入(revenue)累积至total中。此步骤高效合并了两笔交易数据。\n最终，函数返回total的一个副本，确保了原始数据的完整性与函数的无副作用特性。值得注意的是，这一系列操作背后的机制凸显了复制构造函数的重要性——它负责在创建新对象时正确复制原有对象的状态，故实现一个稳健的Sales_data类复制构造函数显得尤为重要。\n123456Sales_data::Sales_data(const Sales_data &amp;sa)&#123;    this-&gt;bookNo = sa.bookNo;    this-&gt;revenue = sa.revenue;    this-&gt;units_sold = sa.units_sold;&#125;\n\n构造函数构造函数，以其与类名相同的命名方式，是类初始化不可或缺的一部分。其特性总结如下：\n\n无返回类型：构造函数独特之处在于不声明返回类型，而其他成员函数则需明确返回类型。\n参数与函数体：构造函数支持参数列表和函数体定义，灵活性与普通函数相似，可为空。\n重载与区分：类可包含多个构造函数，依据参数类型或数量的不同实现重载，与普通函数重载原则一致。\n非const特性：构造函数不能被标记为const，因初始化阶段可能修改对象状态，即使对象最终为const。\nconst对象初始化：构造函数在const对象创建期间可执行写操作，直至初始化完毕对象变为不可变。\n默认构造函数：自动提供无参构造，即默认构造函数，除非类中已有其它构造函数定义。\n合成默认构造：缺少显式定义时，编译器介入生成合成默认构造函数，遵循特定初始化规则：\n利用类内初始值：优先采用成员变量定义时的初始值进行初始化。\n默认值初始化：若无类内初始值，则成员按各自类型的默认规则初始化（如数值型为0，指针为nullptr）。\n\n\n\n综上所述，构造函数的设计直接关系到类实例化时的状态初始化，编译器通过一系列明确的规则保障了这一过程的自动化与一致性，特别是对于未明确指定构造逻辑的情况。\n我的理解：当你没有显式地为类定义任何构造函数时，C++ 编译器会自动生成一个默认构造函数。这个默认构造函数会按照以下规则初始化类的数据成员：\n\n如果有类内初始值: 数据成员会使用在类声明中提供的初始值来初始化。例如，如果你在类声明中为 revenue 成员变量指定了默认值 0.0，为 units_sold 指定 0，这些值就会被用来初始化新创建的对象的相应成员。\n\n如果没有类内初始值: 对于没有明确给出初始值的成员，编译器将执行默认初始化。对于基本数据类型的成员（如 int, double），这通常意味着将其初始化为 0 或 0.0；对于指针类型，初始化为 nullptr；对于类类型成员，则递归应用这些规则。对于像 std::string 这样的类类型（假设 bookNo 是一个 std::string 成员），如果没有提供初始值，它将被默认初始化为空字符串（&quot;&quot;）。\n\n\n如果 Sales_data 类定义中 revenue 和 units_sold 成员有默认值分别为 0.0 和 0，而 bookNo 没有给出初始值，那么创建 Sales_data 的对象时：\n\nrevenue 会被初始化为 0.0\nunits_sold 会被初始化为 0\nbookNo 作为 std::string，会被初始化为空字符串 &quot;&quot;\n\n这是编译器提供的默认行为，确保了即使没有显式构造函数，类的实例也能得到合理的初始化。为何某些类需自定义默认构造函数？针对常规类设计，明确定义默认构造函数显得尤为关键，其背后蕴含三大核心缘由：\n\n编译器行为的明确性：【关键点】默认构造函数仅在无明确声明时由编译器自动合成。当类中不存在任何构造函数定义，编译器会贴心地提供一个默认版本。但一旦类中包含了其他构造函数，这一合成过程即刻终止，除非手动添加默认构造函数，否则类将缺失此功能。这一原则基于深思熟虑的设计考量：若类在特定情境下需控制初始化流程，那么普遍情况下同样需要这种控制权。\n\n避免未定义行为：【注意】含有内置类型或复合类型成员的类，需谨慎处理默认初始化。缺省情况下，内置类型及复合类型成员可能被赋予未定义值。因此，仅当所有此类成员均在类内获得明确初始化值时，采用合成默认构造函数才是安全合理的做法。\n\n编译器限制与依赖问题：【要点】类中含无默认构造函数的其他类类型成员时，需手动介入。编译器在面临此类复杂依赖时，无法自动生成默认构造函数，要求开发者明确实现，以确保所有成员得到恰当初始化。\n\n\nC++11的解决方案：= default指令为了简化流程且保留默认行为，C++11引入= default关键字。此指令允许在构造函数声明或定义处使用，指示编译器生成默认构造函数。无论置于类内（此时默认为内联）还是类外，= default均为确保构造函数存在性提供了简洁途径。\n构造函数初始化列表的重要性特别强调，构造函数初始化列表是高效、准确初始化成员变量的关键实践。通过在列表中逐一指定成员及其初始值，开发人员能直接控制对象构造期间的内存初始化顺序和方式，避免了潜在的资源浪费或逻辑错误。\n我们再为Sales_data添加几个带参数的构造函数\n123Sales_data(const std::string &amp;s) : bookNo(s) &#123;&#125;Sales_data(const std::string &amp;s, unsigned n, double p)    : bookNo(s), units_sold(n), revenue(p * n) &#123;&#125;\n\n我们再实现一个构造函数，其参数为ostream类型\n1234Sales_data::Sales_data(std::istream &amp;is)&#123;    read(is, *this);&#125;","slug":"类和对象","date":"2021-06-07T02:15:58.000Z","categories_index":"类的认识","tags_index":"C++,类和对象,成员函数,构造函数","author_index":"kiyose408"},{"id":"d7ccd0a2fc5b38ef8ee1737116d9945c","title":"函数","content":"函数一个典型的函数（function）定义包括以下部分：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。其中，形参以逗号隔开，形参的列表位于一对圆括号之内，如下就是一个函数的定义\n123void funca()&#123;    cout &lt;&lt; &quot;hello world!!!&quot; &lt;&lt; endl;&#125;\n\n局部变量在C++语言中，名字有作用域，对象有生命周期（lifetime）。理解这两个概念非常重要。 · 名字的作用域是程序文本的一部分，名字在其中可见。 · 对象的生命周期是程序执行过程中该对象存在的一段时间。 如我们所知，函数体是一个语句块。块构成一个新的作用域，我们可以在其中定义变量。形参和函数体内部定义的变量统称为局部变量（local variable）。它们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏（hide）在外层作用域中同名的其他所有声明中。\n自动对象对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为自动对象（automatic object）。函数形参和函数内部定义的普通变量都是自动对象。\n局部静态对象某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型从而获得这样的对象。局部静态对象（local static object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。\n1234567891011size_t count_calls()&#123;    //调用结束后，这个值仍然有效    static size_t ctr = 0;    return ++ctr;&#125;for (size_t i = 0; i != 10; ++i)&#123;    cout &lt;&lt; count_calls() &lt;&lt; endl;&#125;\n\n这段程序将输出从1到10（包括10在内）的数字。在控制流第一次经过ctr的定义之前，ctr被创建并初始化为0。每次调用将ctr加1并返回新值。每次执行count_calls函数时，变量ctr的值都已经存在并且等于函数上一次退出时ctr的值。因此，第二次调用时ctr的值是1，第三次调用时ctr的值是2，以此类推。 局部静态变量赋初值只在第一次执行时赋初值的操作，以后再执行都不会进行赋初值的操作。而且生命周期随着程序结束才结束。\n参数传递值传递函数的形参如果是非引用类型则是值传递,函数内部修改形参不会影响到外部实参的值\n12345678void nochange(int a)&#123;    a--;    cout &lt;&lt; a &lt;&lt; endl;&#125;    int m = 6;    nochange(m);    cout &lt;&lt; m &lt;&lt; endl;\n\n程序输出5和6，在函数内部输出的是5，在函数外部输出的是6，可见值传递不会改变实参的值，如果要改变实参的值可以通过引用或者指针操作。\n指针形参指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值\n12345678void change(int *p)&#123;    (*p)--;    cout &lt;&lt; *p &lt;&lt; endl;&#125;int m = 6;change(&amp;m);cout &lt;&lt; m &lt;&lt; endl;\n\n输出5，5 p指向了m的地址，所以*p取到的是m的空间数据，这样就达到修改m的效果。\n传引用参数函数参数为引用类型可以达到通过函数内部修改外部实参的效果，也可以减少传递参数造成的copy开销，拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。\n12345678void change(int &amp;ra)&#123;    ra--;    cout &lt;&lt; ra &lt;&lt; endl;&#125;int m = 6;change(m);cout &lt;&lt; m &lt;&lt; endl;\n\n输出两个5，参数为引用类型，可以通过函数内部修改外部实参的值。 我们准备编写一个函数比较两个string对象的长度。因为string对象可能会非常长，所以应该尽量避免直接拷贝它们，这时使用引用形参是比较明智的选择。又因为比较长度无须改变string对象的内容，所以把形参定义成对常量的引用\n1234bool isShorter(const string &amp;s1, const string &amp;s2)&#123;    return s1.size() &lt; s2.size();&#125;\n\n使用引用形参返回额外信息一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。举个例子，我们定义一个名为find_char的函数，它返回在string对象中某个指定字符第一次出现的位置。同时，我们也希望函数能返回该字符出现的总次数。\n1234567891011121314151617181920string ::size_type find_char(const string &amp;s, char c, string::size_type &amp;occurs)&#123;    //第一次出现的位置(如果有的话)    auto ret = s.size();    //设置表示出现次数的形参的值    occurs = 0;    for (decltype(ret) i = 0; i != s.size(); ++i)    &#123;        if (s[i] == c)        &#123;            if (ret == s.size())                //记录c第一次出现的位置                ret = i;            //出现的次数+1            ++occurs;        &#125;    &#125;    return ret;&#125;\n\n参数为数组当函数的参数为数组时，一般都显示传递一个数组的大小参数\n123456789// const int ia[]等价于const int * ia// size表示数组的大小，将它显示地传给函数用于控制对ia元素的访问void print_array(const int ia[], size_t size)&#123;    for (size_t i = 0; i != size; ++i)    &#123;        cout &lt;&lt; ia[i] &lt;&lt; endl;    &#125;&#125;\n\n主函数可以这样调用\n12int j[] = &#123;0, 1&#125;; print_array(j, end(j) - begin(j));\n\n数组引用形参12345678// arr是数组的引用，维度是类型的一部分void print_arrayref(int (&amp;arr)[10])&#123;    for (auto elem : arr)    &#123;        cout &lt;&lt; elem &lt;&lt; endl;    &#125;&#125;\n\ninitializer_list形参如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组\n12345678void error_msg(initializer_list&lt;string&gt; il)&#123;    for (auto beg = il.begin(); beg != il.end(); beg++)    &#123;        cout &lt;&lt; *beg &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;\n\n返回值函数可以是void类型不返回数据，也可以是有返回值类型，但是不要返回局部变量的指针或者引用。如前所述，返回局部对象的引用是错误的；同样，返回局部对象的指针也是错误的。一旦函数完成，局部对象被释放，指针将指向一个不存在的对象。 也可以返回引用类型，这样返回值就可以作为左值使用\n12345678char &amp;get_val(string &amp;str, string::size_type ix)&#123;    return str[ix];&#125;  string s(&quot;a value&quot;);    cout &lt;&lt; s &lt;&lt; endl; //输出a value      //将s的第一个字母修改为A    get_val(s, 0) = &#x27;A&#x27;;\n\n返回值为数组的指针或引用因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。\n123456// arrT是一个类型别名，他表示的类型含有10个整数数组typedef int arrT[10];// arrT的等价声明using arrT2 = int[10];// func返回一个指向含有10个整数的数组的指针arrT *func(int);\n\n声明一个返回数组指针的函数如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。因此，返回数组指针的函数形式如下所示：\n1Type (*function(parameter_list))[dimension]\n\n举个具体点的例子，下面这个func函数的声明没有使用类型别名：\n1int (*func(int i))[10];\n\n· func（int i）表示调用func函数时需要一个int类型的实参。 · （＊func（int i））意味着我们可以对函数调用的结果执行解引用操作。 · （＊func（int i））[10]表示解引用func的调用将得到一个大小是10的数组。 · int （＊func（int i））[10]表示数组中的元素是int类型。\n尾置类型在C++11新标准中还有一种可以简化上述func声明的方法，就是使用尾置返回类型（trailing return type）。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto：\n123// func接受一个int类型的实参，返回值为一个指针//该指针指向含有10个整数的数组auto func(int i) -&gt; int (*)[10];\n\n使用decltype如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个：\n12345678int odd[] = &#123;1, 3, 5, 7, 9&#125;;int even[] = &#123;0, 2, 4, 6, 8&#125;;//返回一个指针，该指针指向含有5个整数的数组decltype(odd) *arrPtr(int i)&#123;    return (i % 2) ? &amp;odd : &amp;even;&#125;\n\n函数重载如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载（overloaded）函数。\n123void print(const char *cp);void print(const int *beg, const int *end);void print(const int ia[], size_t size);\n\n利用const_cast实现两个返回最小字符串的函数\n12345678910const string &amp;shorterString(const string &amp;s1, const string &amp;s2)&#123;    return s1.size() &lt;= s2.size() ? s1 : s2;&#125;string &amp;shorterString(string &amp;s1, string &amp;s2)&#123;    auto &amp;r = shorterString(const_cast&lt;const string &amp;&gt;(s1), const_cast&lt;const string &amp;&gt;(s2));    return const_cast&lt;string &amp;&gt;(r);&#125;\n\n默认实参我们可以对函数形参设置默认值，如果不传实参，则用形参默认值\n12typedef string::size_type sz;void screen(sz ht = 24, sz wh = 80, char back = &#x27; &#x27;);\n\n我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。 使用时可以\n123456//函数形参分别为100,200,&#x27;a&#x27;screen(100,200,&#x27;a&#x27;);//函数形参分别为100,200,&#x27; &#x27;screen(100,200);//函数形参分别为24,80,&#x27; &#x27;screen();\n\n内联函数内联函数可避免函数调用的开销将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开 constexpr函数（constexpr function）是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句：\n12constexpr int new_sz() &#123; return 42; &#125;constexpr int foo = new_sz();\n\n执行该初始化任务时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。 我们允许constexpr函数的返回值并非一个常量：\n1constexpr size_t scale(size_t cnt) &#123; return new_sz() * cnt; &#125;\n\n当scale的实参是常量表达式时，它的返回值也是常量表达式；反之则不然：\n123456//正确，scale(2)返回的是常量int arr[scale(2)];//i不是常量，scale返回的不是常量int i = 2;//编译器报错int arr2[scale(i)];\n\n函数指针函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。\n12// pf指向一个函数,该函数的参数是两个const string 的引用，返回bool类型bool (*pf)(const string &amp;, const string &amp;);\n\n从我们声明的名字开始观察，pf前面有个＊，因此pf是指针；右侧是形参列表，表示pf指向的是函数；再观察左侧，发现函数的返回类型是布尔值。因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。 ＊pf两端的括号必不可少。如果不写这对括号，则pf2是一个返回值为bool指针的函数：\n12//声明一个名为pf2的函数返回值类型为bool*bool *pf2(const string &amp;, const string &amp;);\n\n虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要想声明一个返回函数指针的函数，最简单的办法是使用类型别名\n1234// F是函数类型，不是指针using F = int(int *, int);// PF是指针类型using PF = int (*)(int *, int);\n\nf1,f2,f3都是返回函数指针的函数\n123F *f1(int);PF f2(int);int (*f3(int))(int *, int);\n\n对于f3的声明，按照由内向外的顺序阅读这条声明语句：我们看到f3有形参列表，所以f3是个函数；f3前面有*，所以f3返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int。 我们可以使用尾置声明\n1234auto f4(int) -&gt; int (*)(int *, int);string::size_type sumLength(const string &amp;, const string &amp;);//根据形参取值，getFcn函数返回值为指向sumLength的指针decltype(sumLength) *getFcn(const string &amp;);\n\n以下几种调用都是正常的\n123456789using PF = int (*)(int *, int*);using F =  int(int *, int *);PF test1 = &amp;test;PF test2 = test;F* test3 = test;test1(nullptr, nullptr);test2(nullptr, nullptr);(*test2)(nullptr, nullptr);test3(nullptr, nullptr);","slug":"函数","date":"2021-05-28T12:10:53.000Z","categories_index":"C++基础","tags_index":"C++,函数","author_index":"kiyose408"},{"id":"078e2f87da9d852a50ee4a0e04f46d2b","title":"多维数组","content":"数组的数组严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。谨记这一点，对今后理解和使用多维数组大有益处。当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另外一个维度表示其元素（也是数组）大小：\n12345678void multi_array()&#123;    //大小为3的数组，每个元素是含有4个整数的数组    int ia[3][4];    //大小为10的数组,他的每个元素都是大小为20的数组    //这些数组的元素是含有30个整数的数组    int arr[10][20][30] = &#123;0&#125;;&#125;\n\n多维数组初始化允许使用花括号括起来的一组值初始化多维数组，这点和普通的数组一样。下面的初始化形式中，多维数组的每一行分别用花括号括了起来：\n1234567891011121314void multi_init()&#123;    //三个元素，每个元素大小都是4的数组    int ia[3][4] = &#123;        &#123;0, 1, 2, 3&#125;,        &#123;4, 5, 6, 7&#125;,        &#123;8, 9, 10, 11&#125;&#125;;    //可以用一个花括号初始化二维数组    int ib[3][4] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11&#125;;    //显示初始化每行的首元素    int ic[3][4] = &#123;&#123;0&#125;, &#123;4&#125;, &#123;8&#125;&#125;;    //显示初始化第一行,其他元素被初始化为0    int id[3][4] = &#123;0, 3, 4, 6&#125;;&#125;\n\n下标访问可以使用下标运算符来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。\n12345678910int arr[3][3][3] = &#123;      0,      1,      2,  &#125;;  //用arr的首元素为ia最后一行的最后一个元素赋值  int ia[3][4] = &#123;0&#125;;  ia[2][3] = arr[0][0][0];  // row是一个ia第二个元素数组的引用，包含四个元素  int(&amp;row)[4] = ia[1];\n\n程序中经常会用到两层嵌套的for循环来处理多维数组的元素\n123456789101112   int ia[rowCnt][colCnt]=&#123;0&#125;;//遍历   constexpr size_t rowCnt = 3, colCnt = 4;   for (size_t i = 0; i != rowCnt; ++i)   &#123;       //对于行内的每一列       for (size_t j = 0; j != colCnt; ++j)       &#123;           //将元素的位置索引作为他的值           ia[i][j] = i * colCnt + j;       &#125;   &#125;\n\n可以使用范围 for语句处理多维数组,由于在C++11新标准中新增了范围for语句，所以前一个程序可以简化为如下形式：\n12345678size_t cnt = 0;   for (auto &amp;row : ia)   &#123;       for (auto &amp;col : row)       &#123;           col = cnt++;       &#125;   &#125;\n\n因为要改变数组元素的值，所以我们选用引用类型作为循环控制变量，但其实还有一个深层次的原因促使我们这么做。举一个例子，考虑如下的循环\n1234567for (auto &amp;row : ia)  &#123;      for (auto col : row)      &#123;          cout &lt;&lt; col &lt;&lt; endl;      &#125;  &#125;\n\n这个循环中并没有任何写操作，可是我们还是将外层循环的控制变量声明成了引用类型，这是为了避免数组被自动转成指针,假设不用引用类型，则循环如下述形式：\n1234567 for (auto row : ia)&#123;    for (auto col : row)    &#123;        cout &lt;&lt; col &lt;&lt; endl;    &#125;&#125;\n\n程序将无法通过编译。这是因为，像之前一样第一个循环遍历ia的所有元素，注意这些元素实际上是大小为4的数组。因为row不是引用类型，所以编译器初始化row时会自动将这些数组形式的元素（和其他类型的数组一样）转换成指向该数组内首元素的指针。这样得到的row的类型就是int＊，显然内层的循环就不合法了，编译器将试图在一个int＊内遍历，这显然和程序的初衷相去甚远。 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。\n指针和多维数组当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。 定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。 因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针：\n123456789void multi_pointer()&#123;    //大小为3的数组，每个元素是含有4个整数的数组    int ia[3][4];    // p指向含有4个整数的数组    int(*p)[4] = ia;    // p指向ia的尾元素    p = &amp;ia[2];&#125;\n\n我们首先明确（＊p）意味着p是一个指针。接着观察右边发现，指针p所指的是一个维度为4的数组；再观察左边知道，数组中的元素是整数。因此，p就是指向含有4个整数的数组的指针。 在上述声明中，圆括号必不可少：\n1234//整数指针的数组   int *ib[4];   //指向含有4个整数的数组   int(*ib)[4];\n\n随着C++11新标准的提出，通过使用auto或者decltype,就能尽可能地避免在数组前面加上一个指针类型了：\n12345678910// p指向一个含有4个整数的数组   for (auto p = ia; p != ia + 3; ++p)   &#123;       // q指向4个整数数组的首元素，也就是说q指向一个整数       for (auto q = *p; q != *p + 4; q++)       &#123;           cout &lt;&lt; *q &lt;&lt; &#x27; &#x27;;       &#125;       cout &lt;&lt; endl;   &#125;\n\n外层的for循环首先声明一个指针p并令其指向ia的第一个内层数组，然后依次迭代直到ia的全部3行都处理完为止。其中递增运算++p负责将指针p移动到ia的下一行。内层的for循环负责输出内层数组所包含的值。它首先令指针q指向p当前所在行的第一个元素。＊p是一个含有4个整数的数组，像往常一样，数组名被自动地转换成指向该数组首元素的指针。内层for循环不断迭代直到我们处理完了当前内层数组的所有元素为止。为了获取内层for循环的终止条件，再一次解引用p得到指向内层数组首元素的指针，给它加上4就得到了终止条件。 当然，使用标准库函数begin和end也能实现同样的功能，而且看起来更简洁一些：\n123456789101112// p指向ia的第一个数组   for (auto p = begin(ia); p != end(ia); p++)   &#123;       // q指向内层数组的首元素       for (auto q = begin(*p); q != end(*p); q++)       &#123;           //输出q所指的整数           cout &lt;&lt; *q &lt;&lt; &#x27; &#x27;;       &#125;       cout &lt;&lt; endl;   &#125;\n\n循环终止条件由end函数负责判断。虽然我们也能推断出p的类型是指向含有4个整数的数组的指针，q的类型是指向整数的指针，但是使用auto关键字我们就不必再烦心这些类型到底是什么了。\n类型别名简化多维数组的指针可以通过typedef和using等关键字定义类型\n12345678// C11新标准定义类型别名// int_array 是一个包含四个元素的整形数组类型using int_array = int[4];//等价的typedef声明// int_array_same 是一个包含四个元素的整形数组类型typedef int int_array_same[4];//如果不会用typedef定义数组类型，可以先定义一个数组变量int int_array_inst[4];\n\n如果不会用typedef定义数组类型，可以先定义一个数组变量\n1int int_array_inst[4];\n\n然后加上typedef即可\n1typedef int int_array_inst[4];\n\n此时int_array_inst就是一个大小为4的整形数组类型。 通过类型定义，我们重新实现遍历\n12345678910int ia[3][4];//输出ia中每个元素的值，每个内层数组各占一行for (int_array *p = ia; p != ia + 3; p++)&#123;    for (int *q = *p; q != *p + 4; q++)    &#123;        cout &lt;&lt; *q &lt;&lt; &#x27; &#x27;;    &#125;    cout &lt;&lt; endl;&#125;","slug":"多维数组","date":"2021-05-20T14:15:53.000Z","categories_index":"C++基础","tags_index":"C++,多维数组","author_index":"kiyose408"},{"id":"e16187d7a3c490f96b788338bdd79d24","title":"数组","content":"数组数组是一种类似于标准库类型vector的数据结构，但是在性能和灵活性的权衡上又与vector有所不同。与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与vector不同的地方是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。\n数组初始化初始化数组要指定大小，如果不指定维度系统会根据初始化列表自动设置数组大小，但是不要将数组数组的大小小于列表长度，否则编译器会报错。\n123456789101112131415161718192021222324252627282930void arrary_init()&#123;    //不是常量表达式    unsigned cnt = 42;    //常量表达式    constexpr unsigned sz = 42;    //常量表达式    const unsigned usz = 42;    //包含10个整数    int arr[10];    //含有42个整形指针的数组    int *parr[sz];    //含有42个string的数组    string strvec[usz];    //含有42个int的数组    string invec[get_size()];    // 编译报错,因为cnt不是常量表达式    // string bad[cnt];    const unsigned msz = 3;    //含有3个元素的数组，元素值分别为0,1,2    int ia1[msz] = &#123;0, 1, 2&#125;;    //维度是3的数组    int a2[] = &#123;0, 1, 2&#125;;    //等价于a3[] = &#123;0,1,2,0,0&#125;    int a3[5] = &#123;0, 1, 2&#125;;    //等价于a4[] = &#123;&quot;hi&quot;,&quot;bye&quot;,&quot;&quot;&#125;    string a4[3] = &#123;&quot;hi&quot;, &quot;bye&quot;&#125;;    //错误，初始值过多    // string a5[2] = &#123;0, 1, 2&#125;;&#125;\n\n错误操作不允许拷贝和赋值不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：\n123456//含有3个整数的数组 int a[] = &#123;0,1,2&#125;; //不允许用一个数组初始化另一个数组 int a2[] = a; //不能把一个数组直接赋值给另一个数组  a2 = a;\n\n复杂声明和vector一样，数组能存放大多数类型的对象。例如，可以定义一个存放指针的数组。又因为数组本身就是对象，所以允许定义数组的指针及数组的引用。在这几种情况中，定义存放指针的数组比较简单和直接，但是定义数组的指针或数组的引用就稍微复杂一点了：\n123456789101112void dif_array()&#123;    // ptrs是含有10个整形指针的数组    int *ptrs[10];    //不存在引用的数组    // int &amp;refs[10] = /*?*/;    int arr[10] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;    // 数组的引用 arrRef是arr的引用    int(&amp;arrRef)[10] = arr;    // Parray指向一个含有10个整数的数组    int(*Parray)[10] = &amp;arr;&#125;\n\n数组访问和vector一样，数组也支持下标访问和遍历访问\n123456789101112131415161718192021void visit_array()&#123;    //以10分为一个分数段统计成绩，0~9，10~19...，90~99,100    // 11 个分数段，全部初始化为0    unsigned scores[11] = &#123;&#125;;    unsigned grade;    while (cin &gt;&gt; grade)    &#123;        if (grade &lt;= 100)        &#123;            ++scores[grade / 10];        &#125;    &#125;    //通过for range 遍历打印    for (auto i : scores)    &#123;        cout &lt;&lt; i &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;\n\n指针和数组在C++语言中，指针和数组有非常紧密的联系。使用数组的时候编译器一般会把它转换成指针。 通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。 数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。 因此像其他对象一样，对数组的元素使用取地址符就能得到指向该元素的指针：\n1234//数组的元素是string元素 string nums[] = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;; // p指向nums的第一个元素 string *p = &amp;nums[0];\n\n在一些情况下数组的操作实际上是指针的操作，这一结论有很多隐含的意思。其中一层意思是当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组：\n123456// ia是一个含有10个整数的数组int ia[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;// ia2是一个整数型指针，指向ia第一个元素auto ia2(ia);//错误：ia2是一个指针，不能用int值给指针赋值// ia2 = 42;\n\n尽管ia是由10个整数构成的数组，但当使用ia作为初始值时，编译器实际执行的初始化过程类似于下面的形式：\n12ia2是int*类型auto ia2(&amp;ia[0]);\n\n必须指出的是，当使用decltype关键字时上述转换不会发生，decltype（ia）返回的类型是由10个整数构成的数组：\n1234567// ia3是一个含有10个整数的数组    decltype(ia) ia3 = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;    int *pint = nullptr;    //错误，不能用整形指针给数组赋值    // ia3 = pint;    //正确，可以对数组的元素赋值    ia3[4] = 1024;\n\n指针也是迭代器就像使用迭代器遍历vector对象中的元素一样，使用指针也能遍历数组中的元素。当然，这样做的前提是先得获取到指向数组第一个元素的指针和指向数组尾元素的下一位置的指针。之前已经介绍过，通过数组名字或者数组中首元素的地址都能得到指向首元素的指针；不过获取尾后指针就要用到数组的另外一个特殊性质了。\n123int arr[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;int *p = arr; // p指向arr的第一个元素++p;          // p指向arr[1]\n\n我们可以设法获取数组尾元素之后的那个并不存在的元素的地址：\n1int *e = &amp;arr[10]; //指向arr尾元素的下一个位置的指针\n\n这里显然使用下标运算符索引了一个不存在的元素，arr有10个元素，尾元素所在位置的索引是9，接下来那个不存在的元素唯一的用处就是提供其地址用于初始化e。就像尾后迭代器一样，尾后指针也不指向具体的元素。因此，不能对尾后指针执行解引用或递增的操作。 所以我们利用指针的末尾元素可以实现另一种方式的遍历\n12for (int *b = arr; b != e; ++b)       cout &lt;&lt; *b &lt;&lt; endl;\n\n数组也支持sizeof操作sizeof计算的是数组所占用的空间,除以sizeof(int)，得到的就是数组的长度，所以数组的遍历可以这样\n1234for (int i = 0; i &lt; sizeof(arr) / sizeof(int); i++)&#123;    cout &lt;&lt; arr[i] &lt;&lt; endl;&#125;\n\n标准库函数begin尽管能计算得到尾后指针，但这种用法极易出错。为了让指针的使用更简单、更安全，C++11新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数：\n123456789// beg指向arr第一个元素    int *beg = begin(arr);    // last指向arr最后一个元素的下一个位置    int *last = end(arr);    while (beg != last)    &#123;        cout &lt;&lt; *beg &lt;&lt; endl;        beg++;    &#125;\n\n通过begin和end函数获取数组第一个元素地址和最后一个元素的下一个位置，然后实现遍历，非常安全\n指针运算指向数组元素的指针包括解引用、递增、比较、与整数相加、两个指针相减等，用在指针和用在迭代器上意义完全一致。给（从）一个指针加上（减去）某整数值，结果仍是指针。新指针指向的元素与原来的指针相比前进了（后退了）该整数值个位置：\n12345int arr[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;//等价于int *p = &amp;arr[0]int *ip = arr;//等价于ip2指向arr的第四个元素int *ip2 = ip + 4;\n\n另外一种计算数组元素个数的方式\n123456   int arr[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;// beg指向arr第一个元素   int *beg = begin(arr);   // last指向arr最后一个元素的下一个位置   int *last = end(arr);   int length = last - beg;\n\nC风格字符串C风格字符串被C++包含在cstring头文件里,包括strcmp字符串比较，strcpy字符串copy，strcat字符串连接 比较字符串\n12345678910const char cal1[] = &quot;A string example&quot;;const char cal2[] = &quot;A different string&quot;;if (strcmp(cal1, cal2) &lt; 0)&#123;    cout &lt;&lt; &quot;cal1 is less than cal2&quot; &lt;&lt; endl;&#125;else&#123;    cout &lt;&lt; &quot;cal2 is less than cal1&quot; &lt;&lt; endl;&#125;\n\n字符串连接 字符串的连接用到了memset清空操作，以及strcpy, strcat等操作，大家看看就好不用深入理解，这是C语言的方式\n12345678910111213141516171819202122232425262728293031void c_string()&#123;    const char cal1[] = &quot;A string example&quot;;    const char cal2[] = &quot;A different string&quot;;    if (strcmp(cal1, cal2) &lt; 0)    &#123;        cout &lt;&lt; &quot;cal1 is less than cal2&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;cal2 is less than cal1&quot; &lt;&lt; endl;    &#125;    const int total_len = strlen(cal1) + strlen(cal2) + 1;    //开辟total_len字节的空间    char *total_str = new char(total_len);    //将空间清空为0    memset(total_str, 0, total_len);    //将cal1 copy 到 total_str    strcpy(total_str, cal1);    //将total_str和cal2连接    strcat(total_str, cal2);    //输出total_str 的值    cout &lt;&lt; &quot;total_str is &quot; &lt;&lt; total_str &lt;&lt; endl;    //最后释放内存    if (total_str != nullptr)    &#123;        delete total_str;        total_str = nullptr;    &#125;&#125;\n\n习惯使用C语言的同学可以通过c_str()函数将string转化为const char*类型的字符串\n12string strcpp = &quot;CPP&quot;;const char *strc = strcpp.c_str();\n\n使用数组初始化vector对象vector除了可以通过初始化列表，指定初始值和大小等方式外，还可以通过数组和vector初始化 通过vector初始化\n123456vector&lt;int&gt; v1 = &#123;1, 3, 5, 7, 9&#125;;vector&lt;int&gt; v2(v1);for (auto v : v2)&#123;    cout &lt;&lt; v &lt;&lt; endl;&#125;\n\n通过数组初始化\n12345678910void vector_init2()&#123;    int a[] = &#123;2, 4, 6, 8, 10&#125;;    vector&lt;int&gt; v3(begin(a), end(a));    for (auto v : v3)    &#123;        cout &lt;&lt; v &lt;&lt; endl;    &#125;&#125;","slug":"数组","date":"2021-05-12T04:00:58.000Z","categories_index":"C++基础","tags_index":"C++,数组","author_index":"kiyose408"},{"id":"bfb8c7eb75a20258cca7b53c5617a35a","title":"Vector","content":"简介本文介绍vector的使用方法，vector是一种高效访问和修改的容器，支持遍历，索引访问。\n初始化1 用花括号进行列表初始化 2 可以用()指定初始值和个数初始化\n123456789101112131415void vector_init()&#123;    //列表初始化    vector&lt;string&gt; v1&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;    //错误用法    // vector&lt;string&gt; v2(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);    //初始化vector大小为10，每个元素为-1    vector&lt;int&gt; ivec(10, -1);    // 10个string类型的元素,每个都是hi    vector&lt;string&gt; svec(10, &quot;hi!&quot;);    // 10个元素，每个都初始化为0    vector&lt;int&gt; ivec2(10);    // 10个元素，每个都初始化为空string    vector&lt;string&gt; svec2(10);&#125;\n\n添加元素123456//利用push_back将元素添加到vector末尾vector&lt;int&gt; v2;for (int i = 0; i != 100; ++i)&#123;    v2.push_back(i);&#125;\n\n遍历访问1234567891011 // 求vector 每个元素平方值vector&lt;int&gt; v3&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;for (auto &amp;i : v3)&#123;    i *= i;&#125;for (auto i : v3)&#123;    cout &lt;&lt; i &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;\n\n下标访问123456789101112//索引访问// 11个分数段，全部初始化为0vector&lt;unsigned&gt; scores(11, 0);unsigned grade;//读取成绩while (cin &gt;&gt; grade)&#123;    //只处理有效成绩，小于等于100的成绩    if (grade &lt;= 100)    //对应的分数段+1，修改索引对应的元素值        ++scores[grade / 10];&#125;","slug":"vector类","date":"2021-05-12T02:15:20.000Z","categories_index":"C++基础","tags_index":"C++,Vector","author_index":"kiyose408"},{"id":"5391af7718199d3c4ba5b2fd9250437c","title":"迭代器","content":"迭代器当我们要遍历容器如vector,map等复杂结构时，可以通过迭代器进行遍历，依次取出容器中的值。通过容器类的begin()和end()函数获取指向第一个元素位置的迭代器和指向最后一个元素下一个位置的迭代器。 迭代器初步使用\n123456789void iterator_func()&#123;    string s(&quot;some string&quot;);    if (s.begin() != s.end())    &#123;        auto it = s.begin();        *it = toupper(*it);    &#125;&#125;\n\n上面代码修改了字符串第一个字母为大写。只有当字符串为空时s.begin()==s.end()\n迭代器运算迭代器支持加减运算，支持比较运算\n123456789*iter 返回iter所指对象得引用iter-&gt;mem 解引用返回iter所指对象得mem成员++iter 迭代器位置后移，指向下一个元素--iter 迭代器位置前移，指向上一个元素iter1 == iter2 判断iter1和iter2是否相等iter1 != iter2 判断iter1和iter2不相等iter = iter + n 迭代器iter向后偏移n个元素iter = iter -n 迭代器iter 向前偏移n个元素iter1 &gt;= iter2 迭代器iter1指向的元素是否在iter2之后\n\n迭代器遍历通过迭代器修改第一个单词为大写，遇到空格或者字符串末尾结束\n1234567string s(&quot;some string&quot;);for (auto iter = s.begin(); iter != s.end() &amp;&amp; !isspace(*iter); iter++)&#123;    *iter = toupper(*iter);&#125;cout &lt;&lt; &quot;str is &quot; &lt;&lt; s &lt;&lt; endl;\n\n通过iter++依次访问s中得每个字符，*iter返回的是每个字符的引用\n泛型编程关键概念：泛型编程原来使用C或Java的程序员在转而使用C++语言之后，会对for循环中使用！&#x3D;而非&lt;进行判断有点儿奇怪，。C++程序员习惯性地使用！&#x3D;，其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标准库提供的所有容器上都有效。之前已经说过，只有string和vector等一些标准库类型有下标运算符，而并非全都如此。与之类似，所有标准库容器的迭代器都定义了==和！&#x3D;，但是它们中的大多数都没有定义&lt;运算符。因此，只要我们养成使用迭代器和！&#x3D;的习惯，就不用太在意用的到底是哪种容器类型。\n迭代器类型那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型：const_iterator和常量指针差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。如果vector对象或string对象是一个常量，只能使用const_iterator；如果vector对象或string对象不是常量，那么既能使用iterator也能使用const_iterator。\n123456789101112131415161718// it能读写vector&lt;int&gt;的元素  vector&lt;int&gt;::iterator it;  // it2能读写string对象中的字符  vector&lt;string&gt;::iterator it2;  // it3 只能读元素,不能写元素  vector&lt;int&gt;::const_iterator it3;  // it4 只能读字符，不能写字符  vector&lt;string&gt;::const_iterator it4;  vector&lt;int&gt; v;  const vector&lt;int&gt; cv;  // vit1的类型是vector&lt;int&gt;::iterator  auto vit1 = v.begin();  // vit2的类型是vector&lt;int&gt;::const_iterator  auto vit2 = cv.begin();  //通过cbegin和cend可以获取常量迭代器  // cvit 类型为vector&lt;int&gt;::const_iterator  auto cvit = v.cbegin();\n\n解引用迭代器解引用要注意将*和迭代器括起来，因为*的优先级比.低，假设iter是vector&lt;string&gt;::iterator类型 判断迭代器所指向的字符串是否为空应该用(*iter).empty() 如果用*iter.empty()会被编译器理解为对迭代器先进行empty()函数运算再解引用，会报错，因为迭代器没有empty()操作 为了方便可以通过-&gt;解引用取出元素的成员或者成员函数，如下我们通过遍历，直到遇到空字符串就退出遍历\n12345678vector&lt;string&gt; text = &#123;&quot;zack&quot;,                       &quot;vivo&quot;,                       &quot;&quot;,                       &quot;lisus&quot;&#125;;for (auto it = text.begin(); it != text.end() &amp;&amp; !it-&gt;empty(); ++it)&#123;    cout &lt;&lt; *it &lt;&lt; endl;&#125;\n\n迭代器失效在通过迭代器遍历vector,string ,map等容器时，如果遍历的循环中添加元素或者删除元素会导致迭代器失效，因为添加元素或者删除元素会影响迭代器的值，可以通过如下方式在遍历的同时删除元素\n12345678910auto itdel = text.begin();while (itdel != text.end())&#123;    if (itdel-&gt;empty())    &#123;        itdel = text.erase(itdel);        continue;    &#125;    itdel++;&#125;\n\ntext.erase(itdel)返回的时下一个元素的迭代器，所以直接跳出本次循环继续遍历即可。\n二分查找迭代器可以做加减操作，所以我们用迭代器实现一个二分查找, orderv是一个vector,里面的数字是有序的，我们查找9\n1234567891011121314151617181920212223242526272829303132333435363738vector&lt;int&gt; orderv = &#123;1,                      2,                      3,                      5,                      6,                      8,                      9,                      10&#125;;bool bfind = false;auto findit = orderv.begin();auto beginit = orderv.begin();auto endit = orderv.end();while (beginit != endit)&#123;    auto midit = beginit + (endit - beginit) / 2;    if (*midit == 9)    &#123;        findit = midit;        bfind = true;        break;    &#125;    if (*midit &gt; 9)    &#123;        endit = midit - 1;    &#125;    if (*midit &lt; 9)    &#123;        beginit = midit + 1;    &#125;&#125;if (bfind)&#123;    cout &lt;&lt; &quot;find success, iter val is &quot; &lt;&lt; *findit &lt;&lt; endl;&#125;","slug":"迭代器","date":"2021-05-08T18:15:50.000Z","categories_index":"C++基础","tags_index":"C++,迭代器","author_index":"kiyose408"},{"id":"d7215eab570338175fadc0dc91188274","title":"String类","content":"简介今天介绍string类的使用\n初始化和定义123456789//默认初始化,s1是一个空字符串string s1;//赋值初始化,s2是s1的副本string s2 = s1;//直接初始化 字面值初始化string s3 = &quot;hiya&quot;;//直接初始化 构造函数初始化string s4(10, &#x27;c&#x27;);string s5(&quot;hello zack&quot;);\n\nstring操作12345678910111213141516171819202122232425262728293031323334353637383940414243void opstr_func()&#123;    //定义空字符串    string s;    //从输入流写入s    cin &gt;&gt; s;    //将s写入输出流    cout &lt;&lt; s &lt;&lt; endl;    //循环读取，直到遇到换行符或者非法输入    string world;    while (cin &gt;&gt; world)        cout &lt;&lt; world &lt;&lt; endl;    //读取一整行    string linestr;    while (getline(cin, linestr))    &#123;        cout &lt;&lt; linestr &lt;&lt; endl;    &#125;    //每次读入一整行，遇到空行跳过    while (getline(cin, linestr))    &#123;        if (!linestr.empty())        &#123;            cout &lt;&lt; linestr &lt;&lt; endl;            //打印字符串长度            cout &lt;&lt; linestr.size() &lt;&lt; endl;            // size()返回string::size_type类型的数据            string::size_type size = linestr.size();        &#125;    &#125;    // 比较    string str1 = &quot;Hello&quot;;    string str2 = &quot;Hello W&quot;;    string str3 = &quot;Za&quot;;    //依次比较每个字符，字符大的字符串就大    auto b2 = str3 &gt; str1;    cout &lt;&lt; b2 &lt;&lt; endl;    //前面字符相同，长度长的字符串大    auto b = str2 &gt; str1;    cout &lt;&lt; b &lt;&lt; endl;&#125;\n\nstring 类重载了 比较运算符，也重载了+运算符等,所以string支持+运算\n123456// string类对象相加string s1 = &quot;Hello&quot;, s2 = &quot;Zack&quot;;string s3 = s1 + &quot;,&quot; + s2 + &#x27;\\n&#x27;;cout &lt;&lt; s3 &lt;&lt; endl;//加号两侧至少有一个是string类型，否则报错// string s4 = &quot;Hello&quot; + &quot;Zack&quot;;\n\n对C语言的兼容建议：使用C++版本的C标准库头文件 C++标准库中除了定义C++语言特有的功能外，也兼容了C语言的标准库。C语言的头文件形如name.h，C++则将这些文件命名为cname。也就是去掉了.h后缀，而在文件名name之前添加了字母c，这里的c表示这是一个属于C语言标准库的头文件。因此，cctype头文件和ctype.h头文件的内容是一样的，只不过从命名规范上来讲更符合C++语言的要求。特别的，在名为cname的头文件中定义的名字从属于命名空间std，而定义在名为.h的头文件中的则不然。一般来说，C++程序应该使用名为cname的头文件而不使用name.h的形式，标准库中的名字总能在命名空间std中找到。如果使用.h形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些又是C++语言所独有的。\nC11用法如果想对string对象中的每个字符做点儿什么操作，目前最好的办法是使用C++11新标准提供的一种语句：范围for（rangefor）语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作，其语法形式是：\n12for(declaration:expression)    statement\n\n其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。一个string对象表示一个字符的序列，因此string对象可以作为范围for语句中的expression部分。举一个简单的例子，我们可以使用范围for语句把string对象中的字符每行一个输出出来：\n123456string str(&quot;hello zack&quot;);    //遍历输出str中的每个字符for (auto c : str)&#123;    cout &lt;&lt; c &lt;&lt; endl;&#125;\n\n统计字符串中标点符号的数量\n1234567891011string s(&quot;Hello World!!!&quot;);decltype(s.size()) punct_cnt = 0;//统计s中标点符号的数量for (auto c : s)&#123;    if (ispunct(c))        punct_cnt++;&#125;cout &lt;&lt; punct_cnt     &lt;&lt; &quot; punctuation characters in &quot;    &lt;&lt; s &lt;&lt; endl;\n\n将字符串变为大写\n12345678//将字符串变为大写string s3(&quot;Hello Vivo&quot;);for (auto &amp;c : s3)&#123;    //通过引用string中的字符，然后修改字符    c = toupper(c);&#125;cout &lt;&lt; s &lt;&lt; endl;\n\n将第一个单词变为大写\n1234567//通过下标索引修改字符串//把第一个单词变为大写string sind(&quot;some string&quot;);for (decltype(sind.size()) index = 0; index != sind.size() &amp;&amp; isspace(sind[index]); ++index)&#123;    sind[index] = toupper(sind[index]);&#125;","slug":"C++的string类","date":"2021-05-05T04:15:58.000Z","categories_index":"C++基础","tags_index":"C++,String类","author_index":"kiyose408"},{"id":"9a1c9eab819449bb12fa84a4154b8457","title":"C++的输入和输出.","content":"iostreamC++提供了标准的输入输出流功能，需要包含iostream头文件，之后就可以使用cin进行输入，cout进行输出。\n1234567891011#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void cin_func()&#123;    string input;    cout &lt;&lt; &quot;input your words &quot; &lt;&lt; endl;    cin &gt;&gt; input;    cout &lt;&lt; &quot;your input is &quot; &lt;&lt; endl;    cout &lt;&lt; input &lt;&lt; endl;&#125;\n程序输出：\n1234input your wordszackyour input iszack\n&gt;&gt;  会获取输入来写入缓存，并返回cin对象，&lt;&lt;  会从缓存中读取数据，写入cout并返回cout，最后endl会将cout缓存中的数据输出到终端。\n变量12345678910111213141516171819void var_func()&#123;    //整形，4字节    int a = 100;    //ll整形, 8字节    long long lla = 1000;    //长整型， 4 字节    long la = 1024;    //短整型,2 字节    short sa = 200;    //带符号字符型,    //字符型使用时最好指示带符号还是不带符号    //因为在不同的机器上不指明char符号可能会有问题    signed char sc = &#x27;a&#x27;;    //无符号字符型    unsigned char uc = &#x27;m&#x27;;    //bool类型    bool bt = true;&#125;\n\n类型转换当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true。 当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。 当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。 当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8比特大小的unsigned char所得的结果是255。 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。\n12345bool b = 42; //b为trueint i = b; //i 为1i = 3.14; //i 为3double pi = i; //pi为3.0unsigned char c = -1; //\n\n变量的声明和定义用extern在头文件声明，在CPP源文件中定义，可以保证变量不会被重复包含。\n12//只声明aextern int a;\n如果extern后面做了赋值操作，则不是声明而是定义。\n12extern int a= 100;\n不带extern直接类型+变量名就是定义。\n123//如下都是定义int age = 100;int num ;\n\n引用引用就是变量的别名，通过修改引用达到修改变量的值的目的。\n12345int j = 20;// i 是j的引用int &amp;i = j;j = 200;cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;\n\n指针指针值指针的值（即地址）应属下列4种状态之一： 1.指向一个对象。 2.指向紧邻对象所占空间的下一个位置。 3.空指针，意味着指针没有指向任何对象。 4.无效指针，也就是上述情况之外的其他值。\n12345678//通过对指针的值做解引用(*)，拿到其指向的值，再修改这个值，达到修改指向对象数据的目的void piont_func()&#123;    int age = 18;    int *page = &amp;age;    *page += 2;    cout &lt;&lt; age &lt;&lt; &quot; &quot; &lt;&lt; page &lt;&lt; endl;&#125;\n\n指向指针的引用12345678910111213void poinref_func()&#123;    int i = 42;    // p是一个指针    int *p;    // r 是一个对p的引用    int *&amp;r = p;    // 令r指向了一个指针p    //给r赋值为&amp;i,就是p指向了i    r = &amp;i;    //解引用r得到i,也就是p指向的对象，将i的值修改为0    *r = 0;&#125;\n\n常量12345678910111213141516171819202122232425262728293031void const_func()&#123;    // 常量定义一定要初始化赋值，否则编译报错    const int bufSize = 512;    //修改bufSize的值会报错    //编译器提示表达式必须是可修改的左值    // bufSize = 222;    //运行时初始化    const int i = get_size();    //编译时初始化    const int j = 43;    //如果定义const变量不初始化也会报错    // const int k;    //利用一个常量初始化另一个常量    const int cj = j;    // const引用,引用及其对应的对象都是const    const int &amp;r1 = cj;    //不可以修改r1的值    // r1 = 42;    //不可以用非常量引用指向一个常量对象    // int &amp;r2 = ci;    int iv = 42;    //允许将const int&amp;绑定到一个普通int对象上    const int &amp;r1 = iv;    //正确, r2是一个常量引用    const int &amp;r2 = 42;    //正确, r3是一个常量引用    const int &amp;r3 = r1 * 2;    //错误, r4 是一个普通非常量的引用    // int &amp;r4 = r1 * 2;&#125;\n\n指向常量的指针指向常量的指针不可以通过指针修改指向内容的数据\n1234567891011121314void pconst_func()&#123;    //指向常量的指针    const double pi = 3.14;    //不可以用普通指针指向常量    // double *ptr = &amp;pi;    //用常量指针指向常量    const double *cptr = &amp;pi;    //不能给*cptr赋值因为cptr指向的是常量    // *cptr = 42;    //指向常量的指针指向非常量    double dval = 3.14;    cptr = &amp;dval;&#125;\n\n常量指针指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。 常量指针（const pointer）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。 把＊放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值\n123456789101112//常量指针//常量指针的值初始化后就不允许修改int errNumb = 0;// curErr将一直指向errNumbint *const curErr = &amp;errNumb;//不允许修改curErr的指向int rightNumb = 1;//编译报错，提示=左侧必须为可修改的左值// curErr = &amp;rightNumb;const double pi = 3.14159;// pip是一个指向常量对象的常量指针const double *const pip = &amp;pi;\n\n顶层const指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词顶层const（top-levelconst）表示指针本身是个常量，而用名词底层const（low-level const）表示指针所指的对象是一个常量。顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const。\nconstexper变量在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。当然可以定义一个const变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。可以这么说，在此种情况下，对象的定义和使用根本就是两回事儿\nC++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：\n123456789void constexpr_func()&#123;    // 20是一个常量表达式    constexpr int mf = 20;    // mf + 1是一个常量表达式    constexpr int limit = mf + 1;    // size是一个constexpr函数    constexpr int sizen = size();&#125;\n\n尽管不能使用普通函数作为constexpr变量的初始值，新标准允许定义一种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。\n常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”（literal type）。到目前为止接触过的数据类型中，算术类型、引用和指针都属于字面值类型。 尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。\n指针和constexpr在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。\n1234567void pointer_constexpr()&#123;    // p是一个指向整形常量的指针,p可以修改，但是*P不可修改    const int *p = nullptr;    // q是一个指向整形变量的常量指针,q不可修改,但是*q可以修改    constexpr int *q = nullptr;&#125;\np和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在于constexpr把它所定义的对象置为顶层const。与其他常量指针类似，constexpr 指针既可以指向常量也可以指向一个非常量：\n12345678910111213141516171819int j = 0;// i 的类型是整型常量constexpr int i = 42;void pointer_constexpr()&#123;    // p是一个指向整形常量的指针,p可以修改，但是*P不可修改    const int *p = nullptr;    // q是一个指向整形变量的常量指针,q不可修改,但是*q可以修改    constexpr int *q = nullptr;    // np是一个指向整数的常量指针，其中为空    constexpr int *np = nullptr;    // i和j必须定义在函数体之外，否则报错，提示p访问运行时存储    //因为constexpr要求表达式为常量，在编译时展开    //  p是常量指针，指向整形常量i    constexpr const int *p2 = &amp;i;    // p1是常量指针，指向整数j    constexpr int *p1 = &amp;j;&#125;\n\n类型别名类型别名(type alias)是一个名字，他是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚的知道使用该类型的真实目的。有两种方法可用于定义类型别名。传统的方法是使用关键字typedef: 1 typedef\n12345678910void typedef_func()&#123;    // wages是double的同义词    typedef double wages;    // base是double的同义词， p 是double*的同义词    typedef wages base, *p;    // C11用法    using newd = double;    newd dd = 3.14;&#125;\n新标准规定了一种新的方法，使用别名声明（aliasdeclaration）来定义类型的别名，using newd &#x3D; 都变了就是通过using定义new类型和double是相同的。\n如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型pstring，它实际上是char *的别名。\n12345678910111213141516void typedef_func()&#123;    typedef char *pstring;    // pstring是一个指向char的常量指针    const pstring cstr = 0;    // ps 是一个指针，其对象是指向char的常量指针    const pstring *ps;    char b = &#x27;H&#x27;;    //不可修改    // cstr = &amp;b;    ps = &amp;cstr;    const pstring cstr2 = &amp;b;    ps = &amp;cstr2;    //不可修改*ps的值    // *ps = cstr;&#125;\n\nauto 推导编程时常常需要把表达式的值付给变量，这就要求在声明变量的时候清楚地知道表达式的类型。为了做到这一点在C++11新标准中引入了auto类型说明符，用它就能让编译器去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如double）不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值，使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样。\n123456789101112131415161718192021void auto_func()&#123;    int a = 100;    int b = 1024;    // c被推导为int类型    auto c = a + b;    auto i = 0, *p = &amp;i;    //一条声明语句只能有一个基本数据类型    //不同类型编译器会报错    // auto sz = 0, pi = 3.14;    const int ma = 1;    // auto会忽略顶层const    //可以通过const明确指出，此时f为const int类型    const auto f = ma;    // auto配合引用类型    auto &amp;g = a;    // 不能为非常量引用绑定字面值    // auto &amp;h = 42;    //指明const 引用绑定字面值    const auto &amp;j = 42;&#125;\n\nauto一般会忽略掉顶层const，同时底层const则会保留下来 要在一条语句中定义多个变量，切记，符号&amp;和＊只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型：\n12345678// k是int类型，l是int的引用// auto 忽略了顶层constauto k = ci, &amp;l = i;// m是int常量的引用，p是指向int常量的指针// auto保留了底层constauto &amp;m = ci, *p = &amp;ci;// 错误 i的类型是int， ci的类型是 const int// auto &amp;n = i, *p2 = &amp;ci;\n\ndecltype类型指示符有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：\n1decltype(size()) sum;\n\n编译器并不实际调用函数size，而是使用当调用发生时size的返回值类型作为sum的类型。换句话说，编译器为sum指定的类型是什么呢？就是假如size被调用的话将会返回的那个类型。decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：\n1234567891011void decltype_func()&#123;    decltype(size()) sum;    const int ci = 0, &amp;cj = ci;    // x的类型是const int    decltype(ci) x = 0;    // y的类型是 const int&amp; , y绑定到变量x    decltype(cj) y = x;    //错误，z是一个引用，必须初始化    // decltype(cj) z;&#125;\n\n因为cj是一个引用，decltype（cj）的结果就是引用类型，因此作为引用的z必须被初始化。需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型.\n1234567int i = 42, *p = &amp;i, &amp;r = i;// b1 是一个int类型的引用decltype(r) b1 = i;// r+0 通过decltype返回int类型decltype(r + 0) b2;//错误，必须初始化,c是int&amp;类型// decltype(*p) c;","slug":"C++的输入和输出","date":"2021-05-01T18:15:58.000Z","categories_index":"C++基础","tags_index":"C++,iostream,变量和常量","author_index":"kiyose408"},{"id":"8f8db2152464e78ca34ca60a3d6e1e07","title":"HBuilderX快捷编写Markdown","content":"在HBuilderX中编写Markdown文件时，可以利用以下快捷键来提高效率：\n\nEmmet快速输入：\n\n敲击h2+Tab可生成二级标题，同理适用于其他级别的标题，如h3+Tab生成三级标题等。\n\n\n智能双击：\n\n双击#号可选中整个标题段落。\n\n\n智能回车：\n\n行尾回车或行中Ctrl+Enter强制换行后会自动补全相应的#符号。\n连续两次回车后自动移除补全的#。\n\n\n递进标题层级与切换列表符：\n\n回车后再次按Tab键可递进一层标题。\n再次按Tab切换列表符类型。\n\n\n插入元素：\n\n加粗：Ctrl/Cmd + B\n标题：Ctrl/Cmd + H\n插入链接：Ctrl/Cmd + K\n插入代码块：Ctrl/Cmd + Shift + C\n行内代码：Ctrl/Cmd + Shift + K\n插入图片：Ctrl/Cmd + Shift + I\n无序列表：Ctrl/Cmd + Shift + L\n\n\n文档操作：\n\n折叠标题段落：在标题前的-号上点击或使用Alt+-（展开使用Alt+=）。\n全文折叠&#x2F;展开：Ctrl+Alt+Shift+- 或 =。\n折叠其他区域：Alt+Shift+O。\n\n\n导航与视图：\n\n打开或隐藏视图栏目：Alt+N聚焦编辑区。\n切换标签页：Alt+数字键，如Alt+1切换到第一个标签页。\n\n\n其他常用快捷键：\n\n中途换行：Ctrl+Enter\n向上插入空行：Ctrl+Shift+Enter\n注释代码：Ctrl+/\n\n\n\n这些快捷键可以帮助您更高效地在HBuilderX中编写和编辑Markdown文档。请注意，具体快捷键可能依据软件版本和个人设置有所不同，请根据实际情况调整。\n","slug":"HbuildX中编写Markdown文件的快捷办法","date":"2021-04-15T10:50:36.000Z","categories_index":"实用教程","tags_index":"快捷操作,markdown,HBuildX","author_index":"kiyose408"},{"id":"27df1577effc995bf43c96a8e5eccf53","title":"C++学习路线推荐","content":"学习C++作为一门强大且广泛应用的编程语言，适合从基础逐步过渡到高级特性及实际应用。以下是一个分阶段的C++学习路线建议：\n1. C++基础\n学习C++基础语法：开始之前，确保你对编程有基本的理解。学习变量、数据类型（如int, float, char等）、控制结构（if-else, for, while等）、函数、数组等基础概念。\n指针与内存管理：C++中的指针是其核心特性之一，理解指针的概念、指针运算、动态内存分配（new&#x2F;delete）至关重要。\n结构体与类：学习如何定义结构体和类，理解面向对象编程的基本概念，如封装、继承、多态。\n\n2. C++标准库与STL\n**标准模板库(STL)**：深入学习STL，包括容器（vector, list, map等）、迭代器、算法（sort, find等）和算法。\n字符串与IO流：掌握std::string的使用，以及iostream库进行文件和控制台的输入输出操作。\n\n3. 高级C++特性\n模板：理解模板的基本使用和模板元编程的概念。\n异常处理：学习try-catch机制，理解如何在程序中正确处理异常。\n命名空间与模块：组织代码，避免命名冲突，了解C++20引入的模块特性。\n\n4. C++11及以后的新特性\n智能指针：auto_ptr到unique_ptr, shared_ptr的转变，自动资源管理RAII原则。\nLambda表达式：匿名函数的使用，提高代码的灵活性和可读性。\n类型推导、范围for循环、nullptr：这些新特性让代码更加简洁安全。\n\n5. 性能优化与低级编程\n内存模型与线程：理解C++内存模型，学习多线程编程，包括互斥锁、条件变量等。\n性能分析与优化：使用工具进行性能测试，学习如何优化代码以提高运行效率。\n底层编程：了解C++如何与操作系统交互，包括理解栈与堆、内联汇编等。\n\n6. 实战项目\n参与开源项目：在GitHub上找到感兴趣的C++项目参与，实践中学以致用。\n综合项目：设计并实现自己的项目，比如简单的游戏、图形界面应用、网络程序等，这有助于巩固所学知识。\n\n7. 进阶与持续学习\n深入学习特定领域：根据兴趣或职业规划，深入学习图形编程（OpenGL, DirectX）、游戏开发、机器学习库（TensorFlow, OpenCV）等。\n阅读高质量书籍和文献：《C++ Primer》、《Effective C++》系列、《Modern C++ Design》等书籍是很好的参考资料。\n持续关注C++标准更新：C++标准每隔几年会有更新，保持对新特性的学习和理解，如C++20、C++23的新特性。\n\n学习过程中，动手实践是关键。通过编写代码、调试错误、阅读他人代码，不断积累经验，逐步提升编程技能。\n","slug":"C++学习路线","date":"2021-04-15T10:49:00.000Z","categories_index":"C++基础","tags_index":"C++,学习路线","author_index":"kiyose408"},{"id":"c847bfd470a979bb27b4c7fa12ad9905","title":"Hexo文章模版","content":"头部信息Hexo 的 Aurora 主题是一个流行的开源博客主题，提供了丰富的自定义选项来帮助用户个性化他们的博客。在编写文章时，可以通过在文章的 Front-matter（头部信息）中添加特定的配置项来控制文章的显示方式和其他特性。Aurora 主题支持 Hexo 默认的 Front-matter 配置项，同时也可能包含一些特定于该主题的配置。以下是一些你可以在 Aurora 主题文章头部配置的常见选项：\n\ntitle: 文章标题。\n\ndate: 文章发布日期。\n\nupdated: 文章最后更新日期（可选）。\n\ncategories: 文章分类，可以是单个字符串或字符串数组。\n\ntags: 文章标签，通常是字符串数组。\n\nlayout: 布局类型，默认通常是 post。\n\npermalink: 自定义文章的永久链接。\n\ncomments: 是否开启评论功能，通常接受 true 或 false。\n\n\nAurora 特定的 Front-matter 配置可能包括但不限于：\n\nthumbnail: 文章缩略图的路径，用于摘要卡片或列表视图中。\n\nbanner: 文章顶部的大图 banner，适用于某些文章详情页面。\n\nexcerpt: 文章摘要，如果未设置，主题可能会自动从正文摘取一部分作为摘要。\n\nmathjax: 如果文章中包含数学公式，可以设置为 true 来启用 MathJax 支持。\n\ntoc: 是否在文章中显示目录（Table of Contents），通常接受 true 或 false。\n\ncopyright: 版权信息或原文链接，适用于转载文章。\n\nreward: 打赏信息，如果开启了打赏功能，可以在这里设置相关信息。\n\nsticky: 是否置顶文章，通常在首页列表中将文章置顶显示，可能接受 true 或 false。\n\nseries: 如果文章属于某个系列，可以在这里指定系列名称。\n\npassword: 为文章设置阅读密码。\n\n\n请注意，随着Aurora主题的更新，可用的配置项可能会有所变化，因此建议查阅Aurora主题的官方文档或GitHub仓库的最新说明，以获取最准确和最新的配置信息。同时，自定义配置时，遵循Markdown文件的YAML格式规范是很重要的。\n1234567891011121314151617181920212223---title: Autora文章模版date: 2020-05-30 2:15:58update: 2020-05-30 10:29:43categories: \t- 实用教学tags:\t- hexo\t- auroralayout: postpermalink:comments: falsethumbnail:banner:excerpt: mathjax:toc:copyright:reward: sticky: series: password: ---\n\nmarkdown的基础使用方法Markdown 是一种轻量级的文本格式语言，设计初衷是为了让人们使用易读易写的纯文本格式编写文档，然后转换成结构化的HTML（超文本标记语言）。下面是一些基本的Markdown语法示例，涵盖了日常写作中最常用的功能：\n标题\n一级标题：# 我是一级标题\n二级标题：## 我是二级标题\n三级标题：### 我是三级标题\n…以此类推，最多到六级标题。\n\n段落与换行\n直接输入文本就是一段落，段落之间空一行表示分隔。\n换行：在行尾加上两个空格然后回车。\n\n强调\n斜体：*斜体文本* 或 _斜体文本_斜体文本\n粗体：**粗体文本** 或 __粗体文本__粗体文本\n删除线：~~删除线文本~~删除线文本\n\n列表\n无序列表：\n- 列表项1\n- 列表项2\n\n\n有序列表：\n列表项1\n列表项2\n\n\n\n链接\n[链接文字](链接地址)，如：百度\n\n图片\n![图片描述](图片地址)，如：![我的图片](https://example.com/image.jpg)\n\n代码\n行内代码：代码片段，如：print(&quot;Hello World&quot;)\n代码块：  12这里是代码块多行代码\n\n引用\n\n\n\n\n\n\n\n\n\n引用文本\n\n\n分割线\n--- 或 *** 或 ___，用于创建水平分割线。\n\n任务列表\n- [ ] 未完成任务\n\n- [x] 已完成任务\n\n \n未完成任务\n\n \n已完成任务\n\n\n以上是Markdown的基本使用方法，掌握这些就能满足大部分写作需求。Markdown的强大之处在于它的简洁与易学性，随着使用你会逐渐发现更多进阶功能和技巧。\n","slug":"Hexo文章模版","date":"2020-05-29T18:15:58.000Z","categories_index":"实用教程","tags_index":"hexo,aurora","author_index":"kiyose408"},{"id":"8412bcb71a16d5331194e0e41f73e27d","title":"Hexo搭建博客网站","content":"使用Hexo快速搭建个人笔记网站的步骤相对直接，下面是简化的流程指导：\n准备工作\n安装Node.js: Hexo是基于Node.js的，首先确保你的计算机上安装了Node.js。访问 Node.js官方网站 下载并安装最新稳定版。\n\n安装Git: 如果你还没有Git，也需要安装它，因为后续会用到Git来部署网站到GitHub等平台。访问 Git官方网站 下载安装。\n\n\n安装Hexo\n打开命令行工具（Windows下是CMD或PowerShell，Mac&#x2F;Linux下是Terminal）。\n\n运行以下命令安装Hexo：\n1Normal Tips Container\n\n创建Hexo项目\n在你想要存放博客文件的目录下，打开命令行工具，运行以下命令初始化Hexo项目：\n1hexo init your-blog-name\nyour-blog-name 是你给博客起的名字，这个命令会在这个目录下创建一个基本的Hexo项目结构。\n\n初始化完成后，进入项目目录：\n1cd your-blog-name\n\n安装项目依赖：\n1npm install\n\n启动本地服务器预览\n运行以下命令启动本地服务器：1hexo server\n访问 http://localhost:4000 查看你的博客。\n\n编写笔记（博客文章）\n使用Markdown编写笔记，文件通常放在source/_posts目录下。可以通过命令创建新文章：1hexo new &quot;我的第一篇笔记&quot;\n\n部署到GitHub Pages\n登录GitHub，创建一个新的仓库，比如命名为your-github-username.github.io。\n\n回到本地Hexo项目，编辑 _config.yml 文件，配置部署部分，添加如下内容：\n1234deploy:  type: git  repo: https://github.com/your-github-username/your-github-username.github.io.git  branch: main # 或者 master，取决于你的GitHub Pages设置\n\n安装部署工具（如果你还没有安装的话）：\n1npm install hexo-deployer-git --save\n\n最后，运行命令部署到GitHub：\n1hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy\n\n完成上述步骤后，你的笔记网站就会被部署到GitHub Pages，可以通过 https://your-github-username.github.io 访问。\n记得替换上述命令中的your-blog-name、your-github-username等占位符为实际的名称。此外，你可以通过更换Hexo主题来个性化你的网站外观，主题可以从Hexo的官方主题库或GitHub上找到。\n博客的更新在Hexo中，当你对博客的文件进行了更新或修改后，需要经过以下几个步骤来更新部署你的博客：\n\n生成静态文件：打开终端（Command Prompt、PowerShell、Terminal或Git Bash等），导航到你的Hexo项目根目录，然后运行以下命令来生成新的静态文件：\n1hexo clean &amp;&amp; hexo generate\n或简写为：\n1hexo g\nhexo clean 命令会先清除之前生成的静态文件，确保部署的是最新的内容。hexo generate 或 hexo g 则会根据你的Markdown文件和配置生成新的静态文件。\n\n部署到远程服务器：接下来，你需要将生成的静态文件部署到你的远程服务器或GitHub Pages、GitLab Pages等托管服务上。执行以下命令进行部署：\n1hexo deploy\n或简写为：\n1hexo d\n首次使用hexo deploy前，你可能需要在 _config.yml 文件中配置部署信息，例如如果你使用GitHub Pages，可能需要如下配置：\n1234deploy:  type: git  repo: https://github.com/your_username/your_repo.git  branch: main # 或者 gh-pages，取决于你的设置\n确保你已经正确设置了SSH密钥，并且你的GitHub或其他托管服务账户已授权。\n\n\n如果你之前已经配置了自动部署或者有特定的部署脚本（比如通过deploy.sh），则只需执行部署命令，Hexo会自动处理文件的生成和推送。\n完成以上步骤后，你的博客就应该更新为最新的内容了。记得检查你的部署日志输出，确认部署过程中没有错误发生。\nmarkdown文章前置模版1234567891011121314---layout:title: abstracts: date: tags:  -   - categories:  - cover: feature: truetop: false---","slug":"Hexo搭建博客","date":"2020-05-16T15:15:58.000Z","categories_index":"实用教程","tags_index":"Hexo,网站搭建","author_index":"kiyose408"}]