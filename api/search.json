[{"id":"59f4fe88c44206beeb3d56cc24c7cea8","title":"C++模版","content":"1 模板的概念模板就是建立通用的模具，大大提高复用性\n模板的特点：\n\n模板不可以直接使用，它只是一个框架\n模板的通用并不是万能的\n\n2 函数模板\nC++另一种编程思想称为 &#x3D;&#x3D;泛型编程&#x3D;&#x3D; ，主要利用的技术就是模板\n\nC++提供两种模板机制:函数模板和类模板 \n 2.1 函数模板语法\n\n\n函数模板作用：\n建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。\n语法： \n12template&lt;typename T&gt;函数声明或定义\n\n解释：\ntemplate  —  声明创建模板\ntypename  — 表面其后面的符号是一种数据类型，可以用class代替\nT    —   通用的数据类型，名称可以替换，通常为大写字母\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//交换整型函数void swapInt(int&amp; a, int&amp; b) &#123;\tint temp = a;\ta = b;\tb = temp;&#125;//交换浮点型函数void swapDouble(double&amp; a, double&amp; b) &#123;\tdouble temp = a;\ta = b;\tb = temp;&#125;//利用模板提供通用的交换函数template&lt;typename T&gt;void mySwap(T&amp; a, T&amp; b)&#123;\tT temp = a;\ta = b;\tb = temp;&#125;void test01()&#123;\tint a = 10;\tint b = 20;\t\t//swapInt(a, b);\t//利用模板实现交换\t//1、自动类型推导\tmySwap(a, b);\t//2、显示指定类型\tmySwap&lt;int&gt;(a, b);\tcout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n函数模板利用关键字 template\n\n使用函数模板有两种方式：自动类型推导、显示指定类型\n\n模板的目的是为了提高复用性，将类型参数化\n 2.2 函数模板注意事项\n\n\n注意事项：\n\n自动类型推导，必须推导出一致的数据类型T,才可以使用\n\n模板必须要确定出T的数据类型，才可以使用\n\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344//利用模板提供通用的交换函数template&lt;class T&gt;void mySwap(T&amp; a, T&amp; b)&#123;\tT temp = a;\ta = b;\tb = temp;&#125;// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用void test01()&#123;\tint a = 10;\tint b = 20;\tchar c = &#x27;c&#x27;;\tmySwap(a, b); // 正确，可以推导出一致的T\t//mySwap(a, c); // 错误，推导不出一致的T类型&#125;// 2、模板必须要确定出T的数据类型，才可以使用template&lt;class T&gt;void func()&#123;\tcout &lt;&lt; &quot;func 调用&quot; &lt;&lt; endl;&#125;void test02()&#123;\t//func(); //错误，模板不能独立使用，必须确定出T的类型\tfunc&lt;int&gt;(); //利用显示指定类型的方式，给T一个类型，才可以使用该模板&#125;int main() &#123;\ttest01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型\n 2.3 函数模板案例\n\n\n案例描述：\n\n利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序\n排序规则从大到小，排序算法为选择排序\n分别利用char数组和int数组进行测试\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//交换的函数模板template&lt;typename T&gt;void mySwap(T &amp;a, T&amp;b)&#123;\tT temp = a;\ta = b;\tb = temp;&#125;template&lt;class T&gt; // 也可以替换成typename//利用选择排序，进行对数组从大到小的排序void mySort(T arr[], int len)&#123;\tfor (int i = 0; i &lt; len; i++)\t&#123;\t\tint max = i; //最大数的下标\t\tfor (int j = i + 1; j &lt; len; j++)\t\t&#123;\t\t\tif (arr[max] &lt; arr[j])\t\t\t&#123;\t\t\t\tmax = j;\t\t\t&#125;\t\t&#125;\t\tif (max != i) //如果最大数的下标不是i，交换两者\t\t&#123;\t\t\tmySwap(arr[max], arr[i]);\t\t&#125;\t&#125;&#125;template&lt;typename T&gt;void printArray(T arr[], int len) &#123;\tfor (int i = 0; i &lt; len; i++) &#123;\t\tcout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;void test01()&#123;\t//测试char数组\tchar charArr[] = &quot;bdcfeagh&quot;;\tint num = sizeof(charArr) / sizeof(char);\tmySort(charArr, num);\tprintArray(charArr, num);&#125;void test02()&#123;\t//测试int数组\tint intArr[] = &#123; 7, 5, 8, 1, 3, 9, 2, 4, 6 &#125;;\tint num = sizeof(intArr) / sizeof(int);\tmySort(intArr, num);\tprintArray(intArr, num);&#125;int main() &#123;\ttest01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：模板可以提高代码复用，需要熟练掌握\n   2.4 普通函数与函数模板的区别\n普通函数与函数模板区别：\n\n普通函数调用时可以发生自动类型转换（隐式类型转换）\n函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换\n如果利用显示指定类型的方式，可以发生隐式类型转换\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435//普通函数int myAdd01(int a, int b)&#123;\treturn a + b;&#125;//函数模板template&lt;class T&gt;T myAdd02(T a, T b)  &#123;\treturn a + b;&#125;//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换void test01()&#123;\tint a = 10;\tint b = 20;\tchar c = &#x27;c&#x27;;\t\tcout &lt;&lt; myAdd01(a, c) &lt;&lt; endl; //正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99\t//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换\tmyAdd02&lt;int&gt;(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T\n   2.5 普通函数与函数模板的调用规则\n调用规则如下：\n\n如果函数模板和普通函数都可以实现，优先调用普通函数\n可以通过空模板参数列表来强制调用函数模板\n函数模板也可以发生重载\n如果函数模板可以产生更好的匹配,优先调用函数模板\n\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//普通函数与函数模板调用规则void myPrint(int a, int b)&#123;\tcout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;&#125;template&lt;typename T&gt;void myPrint(T a, T b) &#123; \tcout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;&#125;template&lt;typename T&gt;void myPrint(T a, T b, T c) &#123; \tcout &lt;&lt; &quot;调用重载的模板&quot; &lt;&lt; endl; &#125;void test01()&#123;\t//1、如果函数模板和普通函数都可以实现，优先调用普通函数\t// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到\tint a = 10;\tint b = 20;\tmyPrint(a, b); //调用普通函数\t//2、可以通过空模板参数列表来强制调用函数模板\tmyPrint&lt;&gt;(a, b); //调用函数模板\t//3、函数模板也可以发生重载\tint c = 30;\tmyPrint(a, b, c); //调用重载的函数模板\t//4、 如果函数模板可以产生更好的匹配,优先调用函数模板\tchar c1 = &#x27;a&#x27;;\tchar c2 = &#x27;b&#x27;;\tmyPrint(c1, c2); //调用函数模板&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性\n   2.6 模板的局限性\n局限性：\n\n模板的通用性并不是万能的\n\n例如：\n12345template&lt;class T&gt;void f(T a, T b)&#123;    \ta = b;   &#125;\n\n在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了\n再例如：\n12345template&lt;class T&gt;void f(T a, T b)&#123;    \tif(a &gt; b) &#123; ... &#125;   &#125;\n\n在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行\n因此C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板\n示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;using namespace std;#include &lt;string&gt;class Person&#123;public:\tPerson(string name, int age)\t&#123;\t\tthis-&gt;m_Name = name;\t\tthis-&gt;m_Age = age;\t&#125;\tstring m_Name;\tint m_Age;&#125;;//普通函数模板template&lt;class T&gt;bool myCompare(T&amp; a, T&amp; b)&#123;\tif (a == b)\t&#123;\t\treturn true;\t&#125;\telse\t&#123;\t\treturn false;\t&#125;&#125;//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型//具体化优先于常规模板template&lt;&gt; bool myCompare(Person &amp;p1, Person &amp;p2)&#123;\tif ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)\t&#123;\t\treturn true;\t&#125;\telse\t&#123;\t\treturn false;\t&#125;&#125;void test01()&#123;\tint a = 10;\tint b = 20;\t//内置数据类型可以直接使用通用的函数模板\tbool ret = myCompare(a, b);\tif (ret)\t&#123;\t\tcout &lt;&lt; &quot;a == b &quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;a != b &quot; &lt;&lt; endl;\t&#125;&#125;void test02()&#123;\tPerson p1(&quot;Tom&quot;, 10);\tPerson p2(&quot;Tom&quot;, 10);\t//自定义数据类型，不会调用普通的函数模板\t//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型\tbool ret = myCompare(p1, p2);\tif (ret)\t&#123;\t\tcout &lt;&lt; &quot;p1 == p2 &quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;p1 != p2 &quot; &lt;&lt; endl;\t&#125;&#125;int main() &#123;\ttest01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n利用具体化的模板，可以解决自定义类型的通用化\n学习模板并不是为了写模板，而是在STL能够运用系统提供的模板\n\n3 类模板   3.1 类模板语法\n类模板作用：\n\n建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。\n\n语法： \n12template&lt;typename T&gt;类\n\n解释：\ntemplate  —  声明创建模板\ntypename  — 表面其后面的符号是一种数据类型，可以用class代替\nT    —   通用的数据类型，名称可以替换，通常为大写字母\n示例：\n1234567891011121314151617181920212223242526272829303132333435#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType&gt; class Person&#123;public:\tPerson(NameType name, AgeType age)\t&#123;\t\tthis-&gt;mName = name;\t\tthis-&gt;mAge = age;\t&#125;\tvoid showPerson()\t&#123;\t\tcout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;\t&#125;public:\tNameType mName;\tAgeType mAge;&#125;;void test01()&#123;\t// 指定NameType 为string类型，AgeType 为 int类型\tPerson&lt;string, int&gt;P1(&quot;孙悟空&quot;, 999);\tP1.showPerson();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板\n   3.2 类模板与函数模板区别\n类模板与函数模板区别主要有两点：\n\n类模板没有自动类型推导的使用方式\n类模板在模板参数列表中可以有默认参数\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType = int&gt; class Person&#123;public:\tPerson(NameType name, AgeType age)\t&#123;\t\tthis-&gt;mName = name;\t\tthis-&gt;mAge = age;\t&#125;\tvoid showPerson()\t&#123;\t\tcout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;\t&#125;public:\tNameType mName;\tAgeType mAge;&#125;;//1、类模板没有自动类型推导的使用方式void test01()&#123;\t// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导\tPerson &lt;string ,int&gt;p(&quot;孙悟空&quot;, 1000); //必须使用显示指定类型的方式，使用类模板\tp.showPerson();&#125;//2、类模板在模板参数列表中可以有默认参数void test02()&#123;\tPerson &lt;string&gt; p(&quot;猪八戒&quot;, 999); //类模板中的模板参数列表 可以指定默认参数\tp.showPerson();&#125;int main() &#123;\ttest01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n类模板使用只能用显示指定类型方式\n\n类模板中的模板参数列表可以有默认参数\n 3.3 类模板中成员函数创建时机\n\n\n类模板中成员函数和普通类中成员函数创建时机是有区别的：\n\n普通类中的成员函数一开始就可以创建\n类模板中的成员函数在调用时才创建\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Person1&#123;public:\tvoid showPerson1()\t&#123;\t\tcout &lt;&lt; &quot;Person1 show&quot; &lt;&lt; endl;\t&#125;&#125;;class Person2&#123;public:\tvoid showPerson2()\t&#123;\t\tcout &lt;&lt; &quot;Person2 show&quot; &lt;&lt; endl;\t&#125;&#125;;template&lt;class T&gt;class MyClass&#123;public:\tT obj;\t//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成\tvoid fun1() &#123; obj.showPerson1(); &#125;\tvoid fun2() &#123; obj.showPerson2(); &#125;&#125;;void test01()&#123;\tMyClass&lt;Person1&gt; m;\t\tm.fun1();\t//m.fun2();//编译会出错，说明函数调用才会去创建成员函数&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建\n   3.4 类模板对象做函数参数\n学习目标：\n\n类模板实例化出的对象，向函数传参的方式\n\n一共有三种传入方式：\n\n指定传入的类型   — 直接显示对象的数据类型\n参数模板化           — 将对象中的参数变为模板进行传递\n整个类模板化       — 将这个对象类型 模板化进行传递\n\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType = int&gt; class Person&#123;public:\tPerson(NameType name, AgeType age)\t&#123;\t\tthis-&gt;mName = name;\t\tthis-&gt;mAge = age;\t&#125;\tvoid showPerson()\t&#123;\t\tcout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;\t&#125;public:\tNameType mName;\tAgeType mAge;&#125;;//1、指定传入的类型void printPerson1(Person&lt;string, int&gt; &amp;p) &#123;\tp.showPerson();&#125;void test01()&#123;\tPerson &lt;string, int &gt;p(&quot;孙悟空&quot;, 100);\tprintPerson1(p);&#125;//2、参数模板化template &lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt;&amp;p)&#123;\tp.showPerson();\tcout &lt;&lt; &quot;T1的类型为： &quot; &lt;&lt; typeid(T1).name() &lt;&lt; endl;\tcout &lt;&lt; &quot;T2的类型为： &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl;&#125;void test02()&#123;\tPerson &lt;string, int &gt;p(&quot;猪八戒&quot;, 90);\tprintPerson2(p);&#125;//3、整个类模板化template&lt;class T&gt;void printPerson3(T &amp; p)&#123;\tcout &lt;&lt; &quot;T的类型为： &quot; &lt;&lt; typeid(T).name() &lt;&lt; endl;\tp.showPerson();&#125;void test03()&#123;\tPerson &lt;string, int &gt;p(&quot;唐僧&quot;, 30);\tprintPerson3(p);&#125;int main() &#123;\ttest01();\ttest02();\ttest03();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n\n通过类模板创建的对象，可以有三种方式向函数中进行传参\n\n使用比较广泛是第一种：指定传入的类型\n 3.5 类模板与继承\n\n\n当类模板碰到继承时，需要注意一下几点：\n\n当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型\n如果不指定，编译器无法给子类分配内存\n如果想灵活指定出父类中T的类型，子类也需变为类模板\n\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243template&lt;class T&gt;class Base&#123;\tT m;&#125;;//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承class Son :public Base&lt;int&gt; //必须指定一个类型&#123;&#125;;void test01()&#123;\tSon c;&#125;//类模板继承类模板 ,可以用T2指定父类中的T类型template&lt;class T1, class T2&gt;class Son2 :public Base&lt;T2&gt;&#123;public:\tSon2()\t&#123;\t\tcout &lt;&lt; typeid(T1).name() &lt;&lt; endl;\t\tcout &lt;&lt; typeid(T2).name() &lt;&lt; endl;\t&#125;&#125;;void test02()&#123;\tSon2&lt;int, char&gt; child1;&#125;int main() &#123;\ttest01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：如果父类是类模板，子类需要指定出父类中T的数据类型\n   3.6 类模板成员函数类外实现\n学习目标：能够掌握类模板中的成员函数类外实现\n示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;string&gt;//类模板中成员函数类外实现template&lt;class T1, class T2&gt;class Person &#123;public:\t//成员函数类内声明\tPerson(T1 name, T2 age);\tvoid showPerson();public:\tT1 m_Name;\tT2 m_Age;&#125;;//构造函数 类外实现template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;\tthis-&gt;m_Name = name;\tthis-&gt;m_Age = age;&#125;//成员函数 类外实现template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson() &#123;\tcout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;void test01()&#123;\tPerson&lt;string, int&gt; p(&quot;Tom&quot;, 20);\tp.showPerson();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：类模板中成员函数类外实现时，需要加上模板参数列表\n   3.7 类模板分文件编写\n学习目标：\n\n掌握类模板成员函数分文件编写产生的问题以及解决方式\n\n问题：\n\n类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到\n\n解决：\n\n解决方式1：直接包含.cpp源文件\n解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制\n\n示例：\nperson.hpp中代码：\n123456789101112131415161718192021222324252627#pragma once#include &lt;iostream&gt;using namespace std;#include &lt;string&gt;template&lt;class T1, class T2&gt;class Person &#123;public:\tPerson(T1 name, T2 age);\tvoid showPerson();public:\tT1 m_Name;\tT2 m_Age;&#125;;//构造函数 类外实现template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;\tthis-&gt;m_Name = name;\tthis-&gt;m_Age = age;&#125;//成员函数 类外实现template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson() &#123;\tcout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;\n\n\n\n类模板分文件编写.cpp中代码\n12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;//#include &quot;person.h&quot;#include &quot;person.cpp&quot; //解决方式1，包含cpp源文件//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp#include &quot;person.hpp&quot;void test01()&#123;\tPerson&lt;string, int&gt; p(&quot;Tom&quot;, 10);\tp.showPerson();&#125;int main() &#123;\ttest01();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp\n   3.8 类模板与友元\n学习目标：\n\n掌握类模板配合友元函数的类内和类外实现\n\n全局函数类内实现 - 直接在类内声明友元即可\n全局函数类外实现 - 需要提前让编译器知道全局函数的存在\n示例：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;string&gt;//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元template&lt;class T1, class T2&gt; class Person;//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); template&lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt; &amp; p)&#123;\tcout &lt;&lt; &quot;类外实现 ---- 姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;template&lt;class T1, class T2&gt;class Person&#123;\t//1、全局函数配合友元   类内实现\tfriend void printPerson(Person&lt;T1, T2&gt; &amp; p)\t&#123;\t\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;\t&#125;\t//全局函数配合友元  类外实现\tfriend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);public:\tPerson(T1 name, T2 age)\t&#123;\t\tthis-&gt;m_Name = name;\t\tthis-&gt;m_Age = age;\t&#125;private:\tT1 m_Name;\tT2 m_Age;&#125;;//1、全局函数在类内实现void test01()&#123;\tPerson &lt;string, int &gt;p(&quot;Tom&quot;, 20);\tprintPerson(p);&#125;//2、全局函数在类外实现void test02()&#123;\tPerson &lt;string, int &gt;p(&quot;Jerry&quot;, 30);\tprintPerson2(p);&#125;int main() &#123;\t//test01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别\n   3.9 类模板案例   案例描述:  实现一个通用的数组类，要求如下：\n\n可以对内置数据类型以及自定义数据类型的数据进行存储\n将数组中的数据存储到堆区\n构造函数中可以传入数组的容量\n提供对应的拷贝构造函数以及operator&#x3D;防止浅拷贝问题\n提供尾插法和尾删法对数组中的数据进行增加和删除\n可以通过下标的方式访问数组中的元素\n可以获取数组中当前元素个数和数组的容量\n\n示例：\nmyArray.hpp中代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#pragma once#include &lt;iostream&gt;using namespace std;template&lt;class T&gt;class MyArray&#123;public:    \t//构造函数\tMyArray(int capacity)\t&#123;\t\tthis-&gt;m_Capacity = capacity;\t\tthis-&gt;m_Size = 0;\t\tpAddress = new T[this-&gt;m_Capacity];\t&#125;\t//拷贝构造\tMyArray(const MyArray &amp; arr)\t&#123;\t\tthis-&gt;m_Capacity = arr.m_Capacity;\t\tthis-&gt;m_Size = arr.m_Size;\t\tthis-&gt;pAddress = new T[this-&gt;m_Capacity];\t\tfor (int i = 0; i &lt; this-&gt;m_Size; i++)\t\t&#123;\t\t\t//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，\t\t\t// 普通类型可以直接= 但是指针类型需要深拷贝\t\t\tthis-&gt;pAddress[i] = arr.pAddress[i];\t\t&#125;\t&#125;\t//重载= 操作符  防止浅拷贝问题\tMyArray&amp; operator=(const MyArray&amp; myarray) &#123;\t\tif (this-&gt;pAddress != NULL) &#123;\t\t\tdelete[] this-&gt;pAddress;\t\t\tthis-&gt;m_Capacity = 0;\t\t\tthis-&gt;m_Size = 0;\t\t&#125;\t\tthis-&gt;m_Capacity = myarray.m_Capacity;\t\tthis-&gt;m_Size = myarray.m_Size;\t\tthis-&gt;pAddress = new T[this-&gt;m_Capacity];\t\tfor (int i = 0; i &lt; this-&gt;m_Size; i++) &#123;\t\t\tthis-&gt;pAddress[i] = myarray[i];\t\t&#125;\t\treturn *this;\t&#125;\t//重载[] 操作符  arr[0]\tT&amp; operator [](int index)\t&#123;\t\treturn this-&gt;pAddress[index]; //不考虑越界，用户自己去处理\t&#125;\t//尾插法\tvoid Push_back(const T &amp; val)\t&#123;\t\tif (this-&gt;m_Capacity == this-&gt;m_Size)\t\t&#123;\t\t\treturn;\t\t&#125;\t\tthis-&gt;pAddress[this-&gt;m_Size] = val;\t\tthis-&gt;m_Size++;\t&#125;\t//尾删法\tvoid Pop_back()\t&#123;\t\tif (this-&gt;m_Size == 0)\t\t&#123;\t\t\treturn;\t\t&#125;\t\tthis-&gt;m_Size--;\t&#125;\t//获取数组容量\tint getCapacity()\t&#123;\t\treturn this-&gt;m_Capacity;\t&#125;\t//获取数组大小\tint\tgetSize()\t&#123;\t\treturn this-&gt;m_Size;\t&#125;\t//析构\t~MyArray()\t&#123;\t\tif (this-&gt;pAddress != NULL)\t\t&#123;\t\t\tdelete[] this-&gt;pAddress;\t\t\tthis-&gt;pAddress = NULL;\t\t\tthis-&gt;m_Capacity = 0;\t\t\tthis-&gt;m_Size = 0;\t\t&#125;\t&#125;private:\tT * pAddress;  //指向一个堆空间，这个空间存储真正的数据\tint m_Capacity; //容量\tint m_Size;   // 大小&#125;;\n\n\n\n类模板案例—数组类封装.cpp中\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &quot;myArray.hpp&quot;#include &lt;string&gt;void printIntArray(MyArray&lt;int&gt;&amp; arr) &#123;\tfor (int i = 0; i &lt; arr.getSize(); i++) &#123;\t\tcout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\t&#125;\tcout &lt;&lt; endl;&#125;//测试内置数据类型void test01()&#123;\tMyArray&lt;int&gt; array1(10);\tfor (int i = 0; i &lt; 10; i++)\t&#123;\t\tarray1.Push_back(i);\t&#125;\tcout &lt;&lt; &quot;array1打印输出：&quot; &lt;&lt; endl;\tprintIntArray(array1);\tcout &lt;&lt; &quot;array1的大小：&quot; &lt;&lt; array1.getSize() &lt;&lt; endl;\tcout &lt;&lt; &quot;array1的容量：&quot; &lt;&lt; array1.getCapacity() &lt;&lt; endl;\tcout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl;\tMyArray&lt;int&gt; array2(array1);\tarray2.Pop_back();\tcout &lt;&lt; &quot;array2打印输出：&quot; &lt;&lt; endl;\tprintIntArray(array2);\tcout &lt;&lt; &quot;array2的大小：&quot; &lt;&lt; array2.getSize() &lt;&lt; endl;\tcout &lt;&lt; &quot;array2的容量：&quot; &lt;&lt; array2.getCapacity() &lt;&lt; endl;&#125;//测试自定义数据类型class Person &#123;public:\tPerson() &#123;&#125; \t\tPerson(string name, int age) &#123;\t\tthis-&gt;m_Name = name;\t\tthis-&gt;m_Age = age;\t&#125;public:\tstring m_Name;\tint m_Age;&#125;;void printPersonArray(MyArray&lt;Person&gt;&amp; personArr)&#123;\tfor (int i = 0; i &lt; personArr.getSize(); i++) &#123;\t\tcout &lt;&lt; &quot;姓名：&quot; &lt;&lt; personArr[i].m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; personArr[i].m_Age &lt;&lt; endl;\t&#125;&#125;void test02()&#123;\t//创建数组\tMyArray&lt;Person&gt; pArray(10);\tPerson p1(&quot;孙悟空&quot;, 30);\tPerson p2(&quot;韩信&quot;, 20);\tPerson p3(&quot;妲己&quot;, 18);\tPerson p4(&quot;王昭君&quot;, 15);\tPerson p5(&quot;赵云&quot;, 24);\t//插入数据\tpArray.Push_back(p1);\tpArray.Push_back(p2);\tpArray.Push_back(p3);\tpArray.Push_back(p4);\tpArray.Push_back(p5);\tprintPersonArray(pArray);\tcout &lt;&lt; &quot;pArray的大小：&quot; &lt;&lt; pArray.getSize() &lt;&lt; endl;\tcout &lt;&lt; &quot;pArray的容量：&quot; &lt;&lt; pArray.getCapacity() &lt;&lt; endl;&#125;int main() &#123;\t//test01();\ttest02();\tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n总结：\n能够利用所学知识点实现通用的数组\n","slug":"C++模板","date":"2021-07-10T10:50:36.000Z","categories_index":"C++高级","tags_index":"C++,函数模版,类模版","author_index":"kiyose408"},{"id":"aa58dd8d3b218c61e8320d0bbec359ae","title":"类的访问控制","content":"私有和公有一个类里有方法和成员变量，public关键字标识后，public下的方法和变量都变为公有函数。private关键字标识后，private关键字下的方法和成员变量都变为私有。默认情况下，如果不声明public，class中所有的方法和成员都是私有的。如果不声明private, struct中所有的方法和成员都是公有的。\n友元上一篇，我们将print，read等非Sales_data类的全局函数声明为Sales_data类的友元函数，所以print，read可以访问Sales_data类的私有成员。这里再次回忆一下Sales_data类。\n123456789101112131415161718192021222324252627282930class Sales_data&#123;public:    //通过default实现默认构造    // Sales_data() = default;    //显示实现默认构造    Sales_data() : bookNo(&quot;&quot;), units_sold(0), revenue(0.0) &#123;&#125;    // copy构造，根据Sales_data类型对象构造一个新对象    Sales_data(const Sales_data &amp;sa);    Sales_data(const std::string &amp;s) : bookNo(s) &#123;&#125;    Sales_data(const std::string &amp;s, unsigned n, double p)        : bookNo(s), units_sold(n), revenue(p * n) &#123;&#125;    Sales_data(std::istream &amp;is);    //返回图书号    std::string isbn() const &#123; return bookNo; &#125;    //获取平均单价    double avg_price() const;    //将一个Sales_data对象合并到当前类对象    Sales_data &amp;combine(const Sales_data &amp;);    friend std::ostream &amp;print(std::ostream &amp;, const Sales_data &amp;);    friend std::istream &amp;read(std::istream &amp;, Sales_data &amp;);private:    //图书编号    std::string bookNo;    //销量    unsigned units_sold = 0;    //收入    double revenue = 0.0;&#125;;\n\n封装有两个重要的优点： \n\n确保用户代码不会无意间破坏封装对象的状态。 \n被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。\n\n友元的声明友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）。因此，我们的Sales_data头文件应该为read、print和add提供独立的声明（除了类内部的友元声明之外）。所以我在Sales_data类的头文件里声明了这些函数\n1234// Sales_data的非成员接口extern Sales_data add(const Sales_data &amp;, const Sales_data &amp;);extern std::ostream &amp;print(std::ostream &amp;, const Sales_data &amp;);extern std::istream &amp;read(std::istream &amp;, Sales_data &amp;);\n\n隐藏类型定义我们可以在类中定义一种新的类型，这种类型对于外部是隐藏内部实现的，外部不知道该类型是什么。\n12345678910class Screen&#123;public:    typedef std::string::size_type pos;private:    pos cursor = 0;    pos height = 0, width = 0;    std::string contents;&#125;;\n\n用来定义类型的成员必须先定义后使用，这一点与普通成员有所区别，具体原因将在7.4.1节（C++PrimerPlus第254页）解释。因此，类型成员通常出现在类开始的地方。\ninline成员函数所谓内联函数就是在编译时展开，减少运行时开销的一种手段，可以通过inline关键字声明，也可以在类的cpp文件里定义函数时前面指明inline，当然一个类的成员函数在类的头文件实现了，那它也是内联函数，我们完善Screen类，用以下三种方式实现内联函数\n1234567891011121314151617181920212223242526class Screen&#123;public:    typedef std::string::size_type pos;    //因为Screen有另一个构造函数    //所以要实现一个默认构造函数    Screen() = default;    // cursor被初始化为0    Screen(pos ht, pos wd, char c) : height(ht), width(wd), contents(ht * wd, c) &#123;&#125;    //读取光标处字符    char get() const    &#123;        //隐式内联        return contents[cursor];    &#125;    //显示内联    inline char get(pos ht, pos wd) const;    //能在之后被设为内联    Screen &amp;move(pos r, pos c);private:    pos cursor = 0;    pos height = 0, width = 0;    std::string contents;&#125;;\n\n我们可以在类的内部把inline作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义：虽然我们无须在声明和定义的地方同时说明inline，但这么做其实是合法的。不过，最好只在类外部定义的地方说明inline，这样可以使类更容易理解。\n重载成员函数类的成员函数同样支持重载。只要函数名相同，参数列表不同即可。\nmutable属性如果一个成员变量被指明mutable属性，则无论对象是否为const，无论成员函数是否为const，该成员变量都可以被修改。 我们给Screen定义一个mutable成员变量access_ctr，以及一个const成员函数some_member，并在该函数中修改access_ctr变量。\n1234567891011121314151617181920212223242526272829class Screen&#123;public:    typedef std::string::size_type pos;    //因为Screen有另一个构造函数    //所以要实现一个默认构造函数    Screen() = default;    // cursor被初始化为0    Screen(pos ht, pos wd, char c) : height(ht), width(wd), contents(ht * wd, c) &#123;&#125;    //读取光标处字符    char get() const    &#123;        //隐式内联        return contents[cursor];    &#125;    //显示内联    inline char get(pos ht, pos wd) const;    //能在之后被设为内联    Screen &amp;move(pos r, pos c);    void some_member() const;private:    pos cursor = 0;    pos height = 0, width = 0;    std::string contents;    //即使在一个const对象里access_ctr也可被修改    mutable size_t access_ctr;&#125;;\n\n实现some_member的一个成员变量\n1234void Screen::some_member() const&#123; //在const函数中也可以修改access_ctr    ++access_ctr;&#125;\n\n链式调用当我们通过成员函数内部返回*this，也就是类对象本身，则可以继续链式调用其内部的成员函数，比如我们通过重载实现两个set函数\n1234567891011Screen &amp;Screen::set(char c)&#123;    contents[cursor] = c;    return *this;&#125;Screen &amp;Screen::set(pos r, pos col, char ch)&#123;    //给定位置设置新值    contents[r * width + col] = ch;    return *this;&#125;\n\n链式调用\n1234Screen::pos row = 3;Screen::pos col = 4;Screen screen(3, 4, &#x27;c&#x27;);screen.move(2, 3).set(&#x27;#&#x27;);\n\n从const成员返回的*this是常量指针,如果我们实现一个display的const函数，\n123456const Screen &amp;Screen::display(ostream &amp;os) const&#123;    os &lt;&lt; &quot;width is &quot; &lt;&lt; width &lt;&lt; &quot; &quot;       &lt;&lt; &quot;height is &quot; &lt;&lt; height &lt;&lt; endl;    return *this;&#125;\n\n如果按照如下链式调用编译器将报错,因为display返回const Screen&amp; 类型\n1screen.display(cout).move(2, 3).set(&#x27;#&#x27;);\n\n所以我们可以通过重载实现链式调用，实现一个返回const Screen &amp;类型的display函数和一个Screen &amp;类型的display函数, 这两个display函数内部调用do_display函数，因为const函数只能调用const函数，所以我们先实现display函数，他是一个const函数\n12345void Screen::do_display(ostream &amp;os) const&#123;    os &lt;&lt; &quot;width is &quot; &lt;&lt; width &lt;&lt; &quot; &quot;       &lt;&lt; &quot;height is &quot; &lt;&lt; height &lt;&lt; endl;&#125;\n\n再实现两个重载的display函数\n1234567891011const Screen &amp;Screen::display(ostream &amp;os) const&#123;    do_display(os);    return *this;&#125;Screen &amp;Screen::display(ostream &amp;os)&#123;    do_display(os);    return *this;&#125;\n\n这样编译器就会根据类型动态选择display的版本\n1234Screen screen(3, 4, &#x27;c&#x27;);screen.display(cout).move(2, 3).set(&#x27;#&#x27;);const Screen cscreen(2, 1, &#x27; &#x27;);cscreen.display(cout);\n\n类类型和声明1234567891011class First&#123;    int memi;    int getMem();&#125;;struct Second&#123;    int memi;    int getMem();&#125;;\n\n如上我们定义了两个类型，下面的赋值会报错，因为类内的成员虽然一致，但是不同的类就是不同的类型\n123First obj1;//编译报错，obj1和obj2不是一个类型 Second obj2 = obj1;\n\n我们可以不定义类，先进行类的声明\n1class Bags;\n\n这种声明有时被称作前向声明（forward declaration），它向程序中引入了名字Screen并且指明Bags是一种类类型。对于类型Bags来说，在它声明之后定义之前是一个不完全类型（incomplete type），也就是说，此时我们已知Bags是一个类类型，但是不清楚它到底包含哪些成员。\n不完全类型只能在非常有限的情景下使用： 可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。\n直到类被定义之后数据成员才能被声明成这种类类型。我们必须首先完成类的定义，然后编译器才能知道存储该数据成员需要多少空间。 因为只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。 然而，一旦一个类的名字出现后，它就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针：\n123456class Link_screen&#123;    Screen window;    Link_screen *next;    Link_screen *prev;&#125;;\n\n友元类和成员函数可以将一个类A声明为另一个类B的友元，则A类对象可以访问B类对象的私有成员。\n1234567class Screen&#123;public:    // Window_mgr可以访问Screen类的私有部分    friend class Window_mgr;    //Screen类的其他部分......&#125;;\n\nWindow_mgr类可以访问Screen类的私有成员，通过class前向声明了Window_mgr类。 接下来我们定义Window_mgr类\n12345678910111213141516171819class Window_mgr&#123;public:    //窗口中每个屏幕的编号    using ScreenIndex = std::vector&lt;Screen&gt;::size_type;    //按照编号将指定的Screen重置为空白    void clear(ScreenIndex);private:    std::vector&lt;Screen&gt; screens&#123;Screen(24, 80, &#x27; &#x27;)&#125;;&#125;;void Window_mgr::clear(ScreenIndex i)&#123;    // s是一个Screen的引用，指向我们想清空的屏幕    Screen &amp;s = screens[i];    //清空屏幕    s.contents = string(s.height * s.width, &#x27; &#x27;);&#125;\n\n也可以让成员函数作为友元\n1234567class Screen&#123;public:    // Window_mgr可以访问Screen类的私有部分    friend void Window_mgr::clear(ScreenIndex);    //Screen类的其他部分......&#125;;\n\n· 首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。 · 接下来定义Screen，包括对于clear的友元声明。 · 最后定义clear，此时它才可以使用Screen的成员。\n类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中\n","slug":"类的访问控制","date":"2021-06-15T10:49:36.000Z","categories_index":"类的认识","tags_index":"C++,成员函数,友元","author_index":"kiyose408"},{"id":"f7867369ce6c59c22c6335141c563f0b","title":"类和对象","content":"类:::tip我们要设计一个Sales_data类来反映图书的销售情况，它把书籍的销售数据抽象化。就像“鸟”类可以用来描述鹦鹉或麻雀这类对象，“Sales_data”类则用来表示具体的图书销售记录。通过创建Sales_data对象并输入相关数据，系统能够自动统计该书的销售量和总收入。简而言之，Sales_data类是图书录入系统中用于高效管理销售信息的核心组件。如果我们实现Sales_data类，外部调用是这样的:::\n1234567891011121314151617181920212223242526272829303132333435363738void dealSales()&#123;    // 初始化汇总的Sales_data对象    Sales_data total;        // 读取第一条销售记录    if (read(std::cin, total))    &#123;        // 用于暂存每条新读取的销售记录        Sales_data trans;                // 循环读取后续销售记录        while (read(std::cin, trans))        &#123;            // 检查当前记录与已汇总记录的ISBN是否一致            if (total.isbn() == trans.isbn())            &#123;                // 若一致，则合并当前记录到总记录中                total.combine(trans);            &#125;            else            &#123;                // 若不一致，输出当前累计的销售数据，并开始新的累加周期                print(std::cout, total) &lt;&lt; std::endl;                // 将当前记录设为新的累加起点                total = trans;            &#125;        &#125;                // 输出最后一个或唯一一个汇总周期的销售数据        print(std::cout, total) &lt;&lt; std::endl;    &#125;    else    &#123;        // 若无数据可读，则提示错误        std::cerr &lt;&lt; &quot;No sales data input detected.&quot; &lt;&lt; std::endl;    &#125;&#125;\n\n在我们的图书销售管理系统中，Sales_data类被精心设计以封装与图书销售记录相关的操作，具体包括关键的接口功能：\n\nISBN 查询成员函数 (isbn()): 此成员函数允许用户获取某个Sales_data对象所代表图书的ISBN编号，便于识别和分类不同的图书记录。\n\n合并销售数据成员函数 (combine()): 该功能使得一个Sales_data对象能够累积另一个相同ISBN图书的销售数据，这对于统计特定图书的总体销售情况极为重要。\n\n加法运算函数 (add()): 提供了一个静态方法或友元函数形式的加法操作，能够直接将两个Sales_data对象相加，计算合并后的销售总量和总收入，简化多记录处理流程。\n\n读取数据成员函数 (read()): 该成员负责从输入流（如标准输入std::cin）读取销售记录数据，并根据格式填充到Sales_data对象中，增强了程序的交互性和灵活性。\n\n打印输出成员函数 (print()): 允许将Sales_data对象的内容格式化输出到指定的输出流（如std::cout），方便查看和记录销售统计数据，提高了系统的可审计性和透明度。\n\n\n基于以上设计原则定义的Sales_data类，不仅能够高效地管理单本图书的销售信息，还能轻松整合并分析整个图书目录的销售概况，为图书录入系统提供了强大的数据处理支持。\n1234567891011121314151617181920212223242526272829303132#ifndef __CLASS_H__#define __CLASS_H__class Sales_data&#123;public:    //通过default实现默认构造    // Sales_data() = default;    //显示实现默认构造    Sales_data() : bookNo(&quot;&quot;), units_sold(0), revenue(0.0) &#123;&#125;    // copy构造，根据Sales_data类型对象构造一个新对象    Sales_data(const Sales_data &amp;sa);    //返回图书号    std::string isbn() const &#123; return bookNo; &#125;    //获取平均单价    double avg_price() const;    //将一个Sales_data对象合并到当前类对象    Sales_data &amp;combine(const Sales_data &amp;);private:    //图书编号    std::string bookNo;    //销量    unsigned units_sold = 0;    //收入    double revenue = 0.0;&#125;;// Sales_data的非成员接口extern Sales_data add(const Sales_data &amp;, const Sales_data &amp;);extern std::ostream &amp;print(std::ostream &amp;, const Sales_data &amp;);extern std::istream &amp;read(std::istream &amp;, Sales_data &amp;);extern void dealSales();#endif\n\n接下来我们逐个部分介绍\n成员函数在Sales_data类中，isbn成员函数扮演着至关重要的角色，它直接反映出类实例所关联的图书ISBN号。此函数之所以能访问bookNo成员，得益于C++中成员函数对this指针的隐式使用。当调用如a.isbn()时，this自动指向调用该函数的Sales_data对象a，从而允许间接访问a的bookNo属性。\n关于this指针的特性：\n\n类型与限制：在非const成员函数中，this是一个指向调用对象的非常量版本的常量指针(Sales_data *const)，确保指针本身不可修改，但可通过解引用来修改对象状态。在const成员函数中，this变为指向常量对象的指针(const Sales_data *const)，意味着既不能改变this指针自身，也不能通过它修改对象的状态，确保了常量成员函数的纯只读性质。\n\n常量成员函数的意义在于，它们能被常量对象或者通过常量引用&#x2F;指针访问的对象安全调用，保证了数据的不可变性，增加了函数使用的灵活性和安全性。\n至于成员函数的实现细节：\n\n编译器处理流程：首先，编译器处理类的成员声明，随后才是成员函数的具体定义。这意味着成员函数可以在声明后定义，且能自由引用类内的其他成员，不受定义顺序限制，如isbn访问bookNo。外部定义规则：若成员函数在类外定义，需严格遵循其在类内声明的签名，包括返回类型、参数列表及函数名，并在必要时明确const限定符以匹配const成员函数的声明。函数定义前还需冠以类名，以表明其所属关系，如Sales_data::isbn() const {…}。\n\n综上所述，通过精确控制成员函数的const属性和合理利用this指针，Sales_data类实现了对图书数据的高效且安全的操作，无论是直接访问属性还是通过复杂的业务逻辑如数据合并与统计。\n1234567double Sales_data::avg_price() const&#123;    if (units_sold)        return revenue / units_sold;    else        return 0;&#125;\n\n定义返回this对象的combine函数\n1234567Sales_data &amp;Sales_data::combine(const Sales_data &amp;sa)&#123;    this-&gt;units_sold += sa.units_sold;    this-&gt;revenue += sa.revenue;    //返回调用该函数的对象    return *this;&#125;\n\n核心亮点在于该函数的返回类型与返回语句，这两个方面尤为值得关注。在设计函数时，若其功能紧密贴近某内置运算符，我们应确保该函数行为与该运算符保持高度一致。具体而言，借鉴内置赋值运算符的逻辑，其特性在于将左侧运算对象作为左值返回。因此，在自定义类似功能时，也应遵循这一机制，以增强代码的自然性和可预测性。\n类相关非成员函数非成员函数的定义方式遵循常规函数的规则，关键在于巧妙地分离声明与定义。当面临这样一个场景：某函数虽在逻辑上隶属某类但未置于类内部实现时，最佳实践是将此函数与类的声明（而非实际定义）置于同一头文件中。如此一来，用户只需包含这单一文件，便能无缝访问类接口的所有组成部分，极大提升了代码的整合性与易用性。\n12345678910111213std::ostream &amp;print(std::ostream &amp;os, const Sales_data &amp;item)&#123;    os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot;       &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_price();    return os;&#125;std::istream &amp;read(std::istream &amp;is, Sales_data &amp;item)&#123;    double price = 0;    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;    return is;&#125;\n\n在此情况下，编译过程将会遇到错误提示，根本原因在于尝试从非成员函数内部直接访问了类对象的私有成员。由于Sales_data类通过private关键字将其成员变量严格设定为私有，这自然而然地限制了外部非成员函数的直接触及。为了解决这一权限冲突，合理的策略是在类的声明部分明智地引入友元函数声明。此举有效授予该函数特殊权限，使其能够越过通常的访问限制，顺畅地与Sales_data类的私有成员进行交互。\n12friend std::ostream &amp;print(std::ostream &amp;, const Sales_data &amp;);friend std::istream &amp;read(std::istream &amp;, Sales_data &amp;);\n\n这样print和read声明为Sales_item类的友元函数，就代表其能访问Sales_item类的私有成员了。 接下来我们同样定义add函数.\n123456Sales_data add(const Sales_data &amp;sa1, const Sales_data &amp;sa2)&#123;    Sales_data total = sa1;    total.combine(sa2);    return total;&#125;\n\n\n鉴于combine函数已被设为public，这意味着它对外部可见并可被直接调用，因此无需将add函数特别指定为Sales_item类的友元函数。\n在此过程中，新创建了一个Sales_data类型的对象total，旨在积累两笔交易信息之和。通过使用sa1的复制构造函数初始化total，实质上是深拷贝了sa1的所有数据成员——包括bookNo、units_sold及revenue至total，实现了两者状态的一致性。\n随后，通过调用total.combine(sa2)方法，将sa2的销售单位数(units_sold)和收入(revenue)累积至total中。此步骤高效合并了两笔交易数据。\n最终，函数返回total的一个副本，确保了原始数据的完整性与函数的无副作用特性。值得注意的是，这一系列操作背后的机制凸显了复制构造函数的重要性——它负责在创建新对象时正确复制原有对象的状态，故实现一个稳健的Sales_data类复制构造函数显得尤为重要。\n123456Sales_data::Sales_data(const Sales_data &amp;sa)&#123;    this-&gt;bookNo = sa.bookNo;    this-&gt;revenue = sa.revenue;    this-&gt;units_sold = sa.units_sold;&#125;\n\n构造函数构造函数，以其与类名相同的命名方式，是类初始化不可或缺的一部分。其特性总结如下：\n\n无返回类型：构造函数独特之处在于不声明返回类型，而其他成员函数则需明确返回类型。\n参数与函数体：构造函数支持参数列表和函数体定义，灵活性与普通函数相似，可为空。\n重载与区分：类可包含多个构造函数，依据参数类型或数量的不同实现重载，与普通函数重载原则一致。\n非const特性：构造函数不能被标记为const，因初始化阶段可能修改对象状态，即使对象最终为const。\nconst对象初始化：构造函数在const对象创建期间可执行写操作，直至初始化完毕对象变为不可变。\n默认构造函数：自动提供无参构造，即默认构造函数，除非类中已有其它构造函数定义。\n合成默认构造：缺少显式定义时，编译器介入生成合成默认构造函数，遵循特定初始化规则：\n利用类内初始值：优先采用成员变量定义时的初始值进行初始化。\n默认值初始化：若无类内初始值，则成员按各自类型的默认规则初始化（如数值型为0，指针为nullptr）。\n\n\n\n综上所述，构造函数的设计直接关系到类实例化时的状态初始化，编译器通过一系列明确的规则保障了这一过程的自动化与一致性，特别是对于未明确指定构造逻辑的情况。\n我的理解：当你没有显式地为类定义任何构造函数时，C++ 编译器会自动生成一个默认构造函数。这个默认构造函数会按照以下规则初始化类的数据成员：\n\n如果有类内初始值: 数据成员会使用在类声明中提供的初始值来初始化。例如，如果你在类声明中为 revenue 成员变量指定了默认值 0.0，为 units_sold 指定 0，这些值就会被用来初始化新创建的对象的相应成员。\n\n如果没有类内初始值: 对于没有明确给出初始值的成员，编译器将执行默认初始化。对于基本数据类型的成员（如 int, double），这通常意味着将其初始化为 0 或 0.0；对于指针类型，初始化为 nullptr；对于类类型成员，则递归应用这些规则。对于像 std::string 这样的类类型（假设 bookNo 是一个 std::string 成员），如果没有提供初始值，它将被默认初始化为空字符串（&quot;&quot;）。\n\n\n如果 Sales_data 类定义中 revenue 和 units_sold 成员有默认值分别为 0.0 和 0，而 bookNo 没有给出初始值，那么创建 Sales_data 的对象时：\n\nrevenue 会被初始化为 0.0\nunits_sold 会被初始化为 0\nbookNo 作为 std::string，会被初始化为空字符串 &quot;&quot;\n\n这是编译器提供的默认行为，确保了即使没有显式构造函数，类的实例也能得到合理的初始化。为何某些类需自定义默认构造函数？针对常规类设计，明确定义默认构造函数显得尤为关键，其背后蕴含三大核心缘由：\n\n编译器行为的明确性：【关键点】默认构造函数仅在无明确声明时由编译器自动合成。当类中不存在任何构造函数定义，编译器会贴心地提供一个默认版本。但一旦类中包含了其他构造函数，这一合成过程即刻终止，除非手动添加默认构造函数，否则类将缺失此功能。这一原则基于深思熟虑的设计考量：若类在特定情境下需控制初始化流程，那么普遍情况下同样需要这种控制权。\n\n避免未定义行为：【注意】含有内置类型或复合类型成员的类，需谨慎处理默认初始化。缺省情况下，内置类型及复合类型成员可能被赋予未定义值。因此，仅当所有此类成员均在类内获得明确初始化值时，采用合成默认构造函数才是安全合理的做法。\n\n编译器限制与依赖问题：【要点】类中含无默认构造函数的其他类类型成员时，需手动介入。编译器在面临此类复杂依赖时，无法自动生成默认构造函数，要求开发者明确实现，以确保所有成员得到恰当初始化。\n\n\nC++11的解决方案：= default指令为了简化流程且保留默认行为，C++11引入= default关键字。此指令允许在构造函数声明或定义处使用，指示编译器生成默认构造函数。无论置于类内（此时默认为内联）还是类外，= default均为确保构造函数存在性提供了简洁途径。\n构造函数初始化列表的重要性特别强调，构造函数初始化列表是高效、准确初始化成员变量的关键实践。通过在列表中逐一指定成员及其初始值，开发人员能直接控制对象构造期间的内存初始化顺序和方式，避免了潜在的资源浪费或逻辑错误。\n我们再为Sales_data添加几个带参数的构造函数\n123Sales_data(const std::string &amp;s) : bookNo(s) &#123;&#125;Sales_data(const std::string &amp;s, unsigned n, double p)    : bookNo(s), units_sold(n), revenue(p * n) &#123;&#125;\n\n我们再实现一个构造函数，其参数为ostream类型\n1234Sales_data::Sales_data(std::istream &amp;is)&#123;    read(is, *this);&#125;","slug":"类和对象","date":"2021-06-01T02:15:58.000Z","categories_index":"类的认识","tags_index":"C++,类和对象,成员函数,构造函数","author_index":"kiyose408"},{"id":"d7ccd0a2fc5b38ef8ee1737116d9945c","title":"函数","content":"函数一个典型的函数（function）定义包括以下部分：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。其中，形参以逗号隔开，形参的列表位于一对圆括号之内，如下就是一个函数的定义\n123void funca()&#123;    cout &lt;&lt; &quot;hello world!!!&quot; &lt;&lt; endl;&#125;\n\n局部变量在C++语言中，名字有作用域，对象有生命周期（lifetime）。理解这两个概念非常重要。 · 名字的作用域是程序文本的一部分，名字在其中可见。 · 对象的生命周期是程序执行过程中该对象存在的一段时间。 如我们所知，函数体是一个语句块。块构成一个新的作用域，我们可以在其中定义变量。形参和函数体内部定义的变量统称为局部变量（local variable）。它们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏（hide）在外层作用域中同名的其他所有声明中。\n自动对象对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为自动对象（automatic object）。函数形参和函数内部定义的普通变量都是自动对象。\n局部静态对象某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型从而获得这样的对象。局部静态对象（local static object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。\n1234567891011size_t count_calls()&#123;    //调用结束后，这个值仍然有效    static size_t ctr = 0;    return ++ctr;&#125;for (size_t i = 0; i != 10; ++i)&#123;    cout &lt;&lt; count_calls() &lt;&lt; endl;&#125;\n\n这段程序将输出从1到10（包括10在内）的数字。在控制流第一次经过ctr的定义之前，ctr被创建并初始化为0。每次调用将ctr加1并返回新值。每次执行count_calls函数时，变量ctr的值都已经存在并且等于函数上一次退出时ctr的值。因此，第二次调用时ctr的值是1，第三次调用时ctr的值是2，以此类推。 局部静态变量赋初值只在第一次执行时赋初值的操作，以后再执行都不会进行赋初值的操作。而且生命周期随着程序结束才结束。\n参数传递值传递函数的形参如果是非引用类型则是值传递,函数内部修改形参不会影响到外部实参的值\n12345678void nochange(int a)&#123;    a--;    cout &lt;&lt; a &lt;&lt; endl;&#125;    int m = 6;    nochange(m);    cout &lt;&lt; m &lt;&lt; endl;\n\n程序输出5和6，在函数内部输出的是5，在函数外部输出的是6，可见值传递不会改变实参的值，如果要改变实参的值可以通过引用或者指针操作。\n指针形参指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值\n12345678void change(int *p)&#123;    (*p)--;    cout &lt;&lt; *p &lt;&lt; endl;&#125;int m = 6;change(&amp;m);cout &lt;&lt; m &lt;&lt; endl;\n\n输出5，5 p指向了m的地址，所以*p取到的是m的空间数据，这样就达到修改m的效果。\n传引用参数函数参数为引用类型可以达到通过函数内部修改外部实参的效果，也可以减少传递参数造成的copy开销，拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。\n12345678void change(int &amp;ra)&#123;    ra--;    cout &lt;&lt; ra &lt;&lt; endl;&#125;int m = 6;change(m);cout &lt;&lt; m &lt;&lt; endl;\n\n输出两个5，参数为引用类型，可以通过函数内部修改外部实参的值。 我们准备编写一个函数比较两个string对象的长度。因为string对象可能会非常长，所以应该尽量避免直接拷贝它们，这时使用引用形参是比较明智的选择。又因为比较长度无须改变string对象的内容，所以把形参定义成对常量的引用\n1234bool isShorter(const string &amp;s1, const string &amp;s2)&#123;    return s1.size() &lt; s2.size();&#125;\n\n使用引用形参返回额外信息一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。举个例子，我们定义一个名为find_char的函数，它返回在string对象中某个指定字符第一次出现的位置。同时，我们也希望函数能返回该字符出现的总次数。\n1234567891011121314151617181920string ::size_type find_char(const string &amp;s, char c, string::size_type &amp;occurs)&#123;    //第一次出现的位置(如果有的话)    auto ret = s.size();    //设置表示出现次数的形参的值    occurs = 0;    for (decltype(ret) i = 0; i != s.size(); ++i)    &#123;        if (s[i] == c)        &#123;            if (ret == s.size())                //记录c第一次出现的位置                ret = i;            //出现的次数+1            ++occurs;        &#125;    &#125;    return ret;&#125;\n\n参数为数组当函数的参数为数组时，一般都显示传递一个数组的大小参数\n123456789// const int ia[]等价于const int * ia// size表示数组的大小，将它显示地传给函数用于控制对ia元素的访问void print_array(const int ia[], size_t size)&#123;    for (size_t i = 0; i != size; ++i)    &#123;        cout &lt;&lt; ia[i] &lt;&lt; endl;    &#125;&#125;\n\n主函数可以这样调用\n12int j[] = &#123;0, 1&#125;; print_array(j, end(j) - begin(j));\n\n数组引用形参12345678// arr是数组的引用，维度是类型的一部分void print_arrayref(int (&amp;arr)[10])&#123;    for (auto elem : arr)    &#123;        cout &lt;&lt; elem &lt;&lt; endl;    &#125;&#125;\n\ninitializer_list形参如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组\n12345678void error_msg(initializer_list&lt;string&gt; il)&#123;    for (auto beg = il.begin(); beg != il.end(); beg++)    &#123;        cout &lt;&lt; *beg &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;\n\n返回值函数可以是void类型不返回数据，也可以是有返回值类型，但是不要返回局部变量的指针或者引用。如前所述，返回局部对象的引用是错误的；同样，返回局部对象的指针也是错误的。一旦函数完成，局部对象被释放，指针将指向一个不存在的对象。 也可以返回引用类型，这样返回值就可以作为左值使用\n12345678char &amp;get_val(string &amp;str, string::size_type ix)&#123;    return str[ix];&#125;  string s(&quot;a value&quot;);    cout &lt;&lt; s &lt;&lt; endl; //输出a value      //将s的第一个字母修改为A    get_val(s, 0) = &#x27;A&#x27;;\n\n返回值为数组的指针或引用因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。\n123456// arrT是一个类型别名，他表示的类型含有10个整数数组typedef int arrT[10];// arrT的等价声明using arrT2 = int[10];// func返回一个指向含有10个整数的数组的指针arrT *func(int);\n\n声明一个返回数组指针的函数如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。因此，返回数组指针的函数形式如下所示：\n1Type (*function(parameter_list))[dimension]\n\n举个具体点的例子，下面这个func函数的声明没有使用类型别名：\n1int (*func(int i))[10];\n\n· func（int i）表示调用func函数时需要一个int类型的实参。 · （＊func（int i））意味着我们可以对函数调用的结果执行解引用操作。 · （＊func（int i））[10]表示解引用func的调用将得到一个大小是10的数组。 · int （＊func（int i））[10]表示数组中的元素是int类型。\n尾置类型在C++11新标准中还有一种可以简化上述func声明的方法，就是使用尾置返回类型（trailing return type）。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto：\n123// func接受一个int类型的实参，返回值为一个指针//该指针指向含有10个整数的数组auto func(int i) -&gt; int (*)[10];\n\n使用decltype如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个：\n12345678int odd[] = &#123;1, 3, 5, 7, 9&#125;;int even[] = &#123;0, 2, 4, 6, 8&#125;;//返回一个指针，该指针指向含有5个整数的数组decltype(odd) *arrPtr(int i)&#123;    return (i % 2) ? &amp;odd : &amp;even;&#125;\n\n函数重载如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载（overloaded）函数。\n123void print(const char *cp);void print(const int *beg, const int *end);void print(const int ia[], size_t size);\n\n利用const_cast实现两个返回最小字符串的函数\n12345678910const string &amp;shorterString(const string &amp;s1, const string &amp;s2)&#123;    return s1.size() &lt;= s2.size() ? s1 : s2;&#125;string &amp;shorterString(string &amp;s1, string &amp;s2)&#123;    auto &amp;r = shorterString(const_cast&lt;const string &amp;&gt;(s1), const_cast&lt;const string &amp;&gt;(s2));    return const_cast&lt;string &amp;&gt;(r);&#125;\n\n默认实参我们可以对函数形参设置默认值，如果不传实参，则用形参默认值\n12typedef string::size_type sz;void screen(sz ht = 24, sz wh = 80, char back = &#x27; &#x27;);\n\n我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。 使用时可以\n123456//函数形参分别为100,200,&#x27;a&#x27;screen(100,200,&#x27;a&#x27;);//函数形参分别为100,200,&#x27; &#x27;screen(100,200);//函数形参分别为24,80,&#x27; &#x27;screen();\n\n内联函数内联函数可避免函数调用的开销将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开 constexpr函数（constexpr function）是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句：\n12constexpr int new_sz() &#123; return 42; &#125;constexpr int foo = new_sz();\n\n执行该初始化任务时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。 我们允许constexpr函数的返回值并非一个常量：\n1constexpr size_t scale(size_t cnt) &#123; return new_sz() * cnt; &#125;\n\n当scale的实参是常量表达式时，它的返回值也是常量表达式；反之则不然：\n123456//正确，scale(2)返回的是常量int arr[scale(2)];//i不是常量，scale返回的不是常量int i = 2;//编译器报错int arr2[scale(i)];\n\n函数指针函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。\n12// pf指向一个函数,该函数的参数是两个const string 的引用，返回bool类型bool (*pf)(const string &amp;, const string &amp;);\n\n从我们声明的名字开始观察，pf前面有个＊，因此pf是指针；右侧是形参列表，表示pf指向的是函数；再观察左侧，发现函数的返回类型是布尔值。因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。 ＊pf两端的括号必不可少。如果不写这对括号，则pf2是一个返回值为bool指针的函数：\n12//声明一个名为pf2的函数返回值类型为bool*bool *pf2(const string &amp;, const string &amp;);\n\n虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要想声明一个返回函数指针的函数，最简单的办法是使用类型别名\n1234// F是函数类型，不是指针using F = int(int *, int);// PF是指针类型using PF = int (*)(int *, int);\n\nf1,f2,f3都是返回函数指针的函数\n123F *f1(int);PF f2(int);int (*f3(int))(int *, int);\n\n对于f3的声明，按照由内向外的顺序阅读这条声明语句：我们看到f3有形参列表，所以f3是个函数；f3前面有*，所以f3返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int。 我们可以使用尾置声明\n1234auto f4(int) -&gt; int (*)(int *, int);string::size_type sumLength(const string &amp;, const string &amp;);//根据形参取值，getFcn函数返回值为指向sumLength的指针decltype(sumLength) *getFcn(const string &amp;);\n\n以下几种调用都是正常的\n123456789using PF = int (*)(int *, int*);using F =  int(int *, int *);PF test1 = &amp;test;PF test2 = test;F* test3 = test;test1(nullptr, nullptr);test2(nullptr, nullptr);(*test2)(nullptr, nullptr);test3(nullptr, nullptr);","slug":"函数","date":"2021-05-20T12:10:53.000Z","categories_index":"C++基础","tags_index":"C++,函数","author_index":"kiyose408"},{"id":"078e2f87da9d852a50ee4a0e04f46d2b","title":"多维数组","content":"数组的数组严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。谨记这一点，对今后理解和使用多维数组大有益处。当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另外一个维度表示其元素（也是数组）大小：\n12345678void multi_array()&#123;    //大小为3的数组，每个元素是含有4个整数的数组    int ia[3][4];    //大小为10的数组,他的每个元素都是大小为20的数组    //这些数组的元素是含有30个整数的数组    int arr[10][20][30] = &#123;0&#125;;&#125;\n\n多维数组初始化允许使用花括号括起来的一组值初始化多维数组，这点和普通的数组一样。下面的初始化形式中，多维数组的每一行分别用花括号括了起来：\n1234567891011121314void multi_init()&#123;    //三个元素，每个元素大小都是4的数组    int ia[3][4] = &#123;        &#123;0, 1, 2, 3&#125;,        &#123;4, 5, 6, 7&#125;,        &#123;8, 9, 10, 11&#125;&#125;;    //可以用一个花括号初始化二维数组    int ib[3][4] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11&#125;;    //显示初始化每行的首元素    int ic[3][4] = &#123;&#123;0&#125;, &#123;4&#125;, &#123;8&#125;&#125;;    //显示初始化第一行,其他元素被初始化为0    int id[3][4] = &#123;0, 3, 4, 6&#125;;&#125;\n\n下标访问可以使用下标运算符来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。\n12345678910int arr[3][3][3] = &#123;      0,      1,      2,  &#125;;  //用arr的首元素为ia最后一行的最后一个元素赋值  int ia[3][4] = &#123;0&#125;;  ia[2][3] = arr[0][0][0];  // row是一个ia第二个元素数组的引用，包含四个元素  int(&amp;row)[4] = ia[1];\n\n程序中经常会用到两层嵌套的for循环来处理多维数组的元素\n123456789101112   int ia[rowCnt][colCnt]=&#123;0&#125;;//遍历   constexpr size_t rowCnt = 3, colCnt = 4;   for (size_t i = 0; i != rowCnt; ++i)   &#123;       //对于行内的每一列       for (size_t j = 0; j != colCnt; ++j)       &#123;           //将元素的位置索引作为他的值           ia[i][j] = i * colCnt + j;       &#125;   &#125;\n\n可以使用范围 for语句处理多维数组,由于在C++11新标准中新增了范围for语句，所以前一个程序可以简化为如下形式：\n12345678size_t cnt = 0;   for (auto &amp;row : ia)   &#123;       for (auto &amp;col : row)       &#123;           col = cnt++;       &#125;   &#125;\n\n因为要改变数组元素的值，所以我们选用引用类型作为循环控制变量，但其实还有一个深层次的原因促使我们这么做。举一个例子，考虑如下的循环\n1234567for (auto &amp;row : ia)  &#123;      for (auto col : row)      &#123;          cout &lt;&lt; col &lt;&lt; endl;      &#125;  &#125;\n\n这个循环中并没有任何写操作，可是我们还是将外层循环的控制变量声明成了引用类型，这是为了避免数组被自动转成指针,假设不用引用类型，则循环如下述形式：\n1234567 for (auto row : ia)&#123;    for (auto col : row)    &#123;        cout &lt;&lt; col &lt;&lt; endl;    &#125;&#125;\n\n程序将无法通过编译。这是因为，像之前一样第一个循环遍历ia的所有元素，注意这些元素实际上是大小为4的数组。因为row不是引用类型，所以编译器初始化row时会自动将这些数组形式的元素（和其他类型的数组一样）转换成指向该数组内首元素的指针。这样得到的row的类型就是int＊，显然内层的循环就不合法了，编译器将试图在一个int＊内遍历，这显然和程序的初衷相去甚远。 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。\n指针和多维数组当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。 定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。 因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针：\n123456789void multi_pointer()&#123;    //大小为3的数组，每个元素是含有4个整数的数组    int ia[3][4];    // p指向含有4个整数的数组    int(*p)[4] = ia;    // p指向ia的尾元素    p = &amp;ia[2];&#125;\n\n我们首先明确（＊p）意味着p是一个指针。接着观察右边发现，指针p所指的是一个维度为4的数组；再观察左边知道，数组中的元素是整数。因此，p就是指向含有4个整数的数组的指针。 在上述声明中，圆括号必不可少：\n1234//整数指针的数组   int *ib[4];   //指向含有4个整数的数组   int(*ib)[4];\n\n随着C++11新标准的提出，通过使用auto或者decltype,就能尽可能地避免在数组前面加上一个指针类型了：\n12345678910// p指向一个含有4个整数的数组   for (auto p = ia; p != ia + 3; ++p)   &#123;       // q指向4个整数数组的首元素，也就是说q指向一个整数       for (auto q = *p; q != *p + 4; q++)       &#123;           cout &lt;&lt; *q &lt;&lt; &#x27; &#x27;;       &#125;       cout &lt;&lt; endl;   &#125;\n\n外层的for循环首先声明一个指针p并令其指向ia的第一个内层数组，然后依次迭代直到ia的全部3行都处理完为止。其中递增运算++p负责将指针p移动到ia的下一行。内层的for循环负责输出内层数组所包含的值。它首先令指针q指向p当前所在行的第一个元素。＊p是一个含有4个整数的数组，像往常一样，数组名被自动地转换成指向该数组首元素的指针。内层for循环不断迭代直到我们处理完了当前内层数组的所有元素为止。为了获取内层for循环的终止条件，再一次解引用p得到指向内层数组首元素的指针，给它加上4就得到了终止条件。 当然，使用标准库函数begin和end也能实现同样的功能，而且看起来更简洁一些：\n123456789101112// p指向ia的第一个数组   for (auto p = begin(ia); p != end(ia); p++)   &#123;       // q指向内层数组的首元素       for (auto q = begin(*p); q != end(*p); q++)       &#123;           //输出q所指的整数           cout &lt;&lt; *q &lt;&lt; &#x27; &#x27;;       &#125;       cout &lt;&lt; endl;   &#125;\n\n循环终止条件由end函数负责判断。虽然我们也能推断出p的类型是指向含有4个整数的数组的指针，q的类型是指向整数的指针，但是使用auto关键字我们就不必再烦心这些类型到底是什么了。\n类型别名简化多维数组的指针可以通过typedef和using等关键字定义类型\n12345678// C11新标准定义类型别名// int_array 是一个包含四个元素的整形数组类型using int_array = int[4];//等价的typedef声明// int_array_same 是一个包含四个元素的整形数组类型typedef int int_array_same[4];//如果不会用typedef定义数组类型，可以先定义一个数组变量int int_array_inst[4];\n\n如果不会用typedef定义数组类型，可以先定义一个数组变量\n1int int_array_inst[4];\n\n然后加上typedef即可\n1typedef int int_array_inst[4];\n\n此时int_array_inst就是一个大小为4的整形数组类型。 通过类型定义，我们重新实现遍历\n12345678910int ia[3][4];//输出ia中每个元素的值，每个内层数组各占一行for (int_array *p = ia; p != ia + 3; p++)&#123;    for (int *q = *p; q != *p + 4; q++)    &#123;        cout &lt;&lt; *q &lt;&lt; &#x27; &#x27;;    &#125;    cout &lt;&lt; endl;&#125;","slug":"多维数组","date":"2021-05-15T14:15:53.000Z","categories_index":"C++基础","tags_index":"C++,多维数组","author_index":"kiyose408"},{"id":"e16187d7a3c490f96b788338bdd79d24","title":"数组","content":"数组数组是一种类似于标准库类型vector的数据结构，但是在性能和灵活性的权衡上又与vector有所不同。与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与vector不同的地方是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。\n数组初始化初始化数组要指定大小，如果不指定维度系统会根据初始化列表自动设置数组大小，但是不要将数组数组的大小小于列表长度，否则编译器会报错。\n123456789101112131415161718192021222324252627282930void arrary_init()&#123;    //不是常量表达式    unsigned cnt = 42;    //常量表达式    constexpr unsigned sz = 42;    //常量表达式    const unsigned usz = 42;    //包含10个整数    int arr[10];    //含有42个整形指针的数组    int *parr[sz];    //含有42个string的数组    string strvec[usz];    //含有42个int的数组    string invec[get_size()];    // 编译报错,因为cnt不是常量表达式    // string bad[cnt];    const unsigned msz = 3;    //含有3个元素的数组，元素值分别为0,1,2    int ia1[msz] = &#123;0, 1, 2&#125;;    //维度是3的数组    int a2[] = &#123;0, 1, 2&#125;;    //等价于a3[] = &#123;0,1,2,0,0&#125;    int a3[5] = &#123;0, 1, 2&#125;;    //等价于a4[] = &#123;&quot;hi&quot;,&quot;bye&quot;,&quot;&quot;&#125;    string a4[3] = &#123;&quot;hi&quot;, &quot;bye&quot;&#125;;    //错误，初始值过多    // string a5[2] = &#123;0, 1, 2&#125;;&#125;\n\n错误操作不允许拷贝和赋值不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：\n123456//含有3个整数的数组 int a[] = &#123;0,1,2&#125;; //不允许用一个数组初始化另一个数组 int a2[] = a; //不能把一个数组直接赋值给另一个数组  a2 = a;\n\n复杂声明和vector一样，数组能存放大多数类型的对象。例如，可以定义一个存放指针的数组。又因为数组本身就是对象，所以允许定义数组的指针及数组的引用。在这几种情况中，定义存放指针的数组比较简单和直接，但是定义数组的指针或数组的引用就稍微复杂一点了：\n123456789101112void dif_array()&#123;    // ptrs是含有10个整形指针的数组    int *ptrs[10];    //不存在引用的数组    // int &amp;refs[10] = /*?*/;    int arr[10] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;    // 数组的引用 arrRef是arr的引用    int(&amp;arrRef)[10] = arr;    // Parray指向一个含有10个整数的数组    int(*Parray)[10] = &amp;arr;&#125;\n\n数组访问和vector一样，数组也支持下标访问和遍历访问\n123456789101112131415161718192021void visit_array()&#123;    //以10分为一个分数段统计成绩，0~9，10~19...，90~99,100    // 11 个分数段，全部初始化为0    unsigned scores[11] = &#123;&#125;;    unsigned grade;    while (cin &gt;&gt; grade)    &#123;        if (grade &lt;= 100)        &#123;            ++scores[grade / 10];        &#125;    &#125;    //通过for range 遍历打印    for (auto i : scores)    &#123;        cout &lt;&lt; i &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;\n\n指针和数组在C++语言中，指针和数组有非常紧密的联系。使用数组的时候编译器一般会把它转换成指针。 通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。 数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。 因此像其他对象一样，对数组的元素使用取地址符就能得到指向该元素的指针：\n1234//数组的元素是string元素 string nums[] = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;; // p指向nums的第一个元素 string *p = &amp;nums[0];\n\n在一些情况下数组的操作实际上是指针的操作，这一结论有很多隐含的意思。其中一层意思是当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组：\n123456// ia是一个含有10个整数的数组int ia[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;// ia2是一个整数型指针，指向ia第一个元素auto ia2(ia);//错误：ia2是一个指针，不能用int值给指针赋值// ia2 = 42;\n\n尽管ia是由10个整数构成的数组，但当使用ia作为初始值时，编译器实际执行的初始化过程类似于下面的形式：\n12ia2是int*类型auto ia2(&amp;ia[0]);\n\n必须指出的是，当使用decltype关键字时上述转换不会发生，decltype（ia）返回的类型是由10个整数构成的数组：\n1234567// ia3是一个含有10个整数的数组    decltype(ia) ia3 = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;    int *pint = nullptr;    //错误，不能用整形指针给数组赋值    // ia3 = pint;    //正确，可以对数组的元素赋值    ia3[4] = 1024;\n\n指针也是迭代器就像使用迭代器遍历vector对象中的元素一样，使用指针也能遍历数组中的元素。当然，这样做的前提是先得获取到指向数组第一个元素的指针和指向数组尾元素的下一位置的指针。之前已经介绍过，通过数组名字或者数组中首元素的地址都能得到指向首元素的指针；不过获取尾后指针就要用到数组的另外一个特殊性质了。\n123int arr[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;int *p = arr; // p指向arr的第一个元素++p;          // p指向arr[1]\n\n我们可以设法获取数组尾元素之后的那个并不存在的元素的地址：\n1int *e = &amp;arr[10]; //指向arr尾元素的下一个位置的指针\n\n这里显然使用下标运算符索引了一个不存在的元素，arr有10个元素，尾元素所在位置的索引是9，接下来那个不存在的元素唯一的用处就是提供其地址用于初始化e。就像尾后迭代器一样，尾后指针也不指向具体的元素。因此，不能对尾后指针执行解引用或递增的操作。 所以我们利用指针的末尾元素可以实现另一种方式的遍历\n12for (int *b = arr; b != e; ++b)       cout &lt;&lt; *b &lt;&lt; endl;\n\n数组也支持sizeof操作sizeof计算的是数组所占用的空间,除以sizeof(int)，得到的就是数组的长度，所以数组的遍历可以这样\n1234for (int i = 0; i &lt; sizeof(arr) / sizeof(int); i++)&#123;    cout &lt;&lt; arr[i] &lt;&lt; endl;&#125;\n\n标准库函数begin尽管能计算得到尾后指针，但这种用法极易出错。为了让指针的使用更简单、更安全，C++11新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数：\n123456789// beg指向arr第一个元素    int *beg = begin(arr);    // last指向arr最后一个元素的下一个位置    int *last = end(arr);    while (beg != last)    &#123;        cout &lt;&lt; *beg &lt;&lt; endl;        beg++;    &#125;\n\n通过begin和end函数获取数组第一个元素地址和最后一个元素的下一个位置，然后实现遍历，非常安全\n指针运算指向数组元素的指针包括解引用、递增、比较、与整数相加、两个指针相减等，用在指针和用在迭代器上意义完全一致。给（从）一个指针加上（减去）某整数值，结果仍是指针。新指针指向的元素与原来的指针相比前进了（后退了）该整数值个位置：\n12345int arr[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;//等价于int *p = &amp;arr[0]int *ip = arr;//等价于ip2指向arr的第四个元素int *ip2 = ip + 4;\n\n另外一种计算数组元素个数的方式\n123456   int arr[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;// beg指向arr第一个元素   int *beg = begin(arr);   // last指向arr最后一个元素的下一个位置   int *last = end(arr);   int length = last - beg;\n\nC风格字符串C风格字符串被C++包含在cstring头文件里,包括strcmp字符串比较，strcpy字符串copy，strcat字符串连接 比较字符串\n12345678910const char cal1[] = &quot;A string example&quot;;const char cal2[] = &quot;A different string&quot;;if (strcmp(cal1, cal2) &lt; 0)&#123;    cout &lt;&lt; &quot;cal1 is less than cal2&quot; &lt;&lt; endl;&#125;else&#123;    cout &lt;&lt; &quot;cal2 is less than cal1&quot; &lt;&lt; endl;&#125;\n\n字符串连接 字符串的连接用到了memset清空操作，以及strcpy, strcat等操作，大家看看就好不用深入理解，这是C语言的方式\n12345678910111213141516171819202122232425262728293031void c_string()&#123;    const char cal1[] = &quot;A string example&quot;;    const char cal2[] = &quot;A different string&quot;;    if (strcmp(cal1, cal2) &lt; 0)    &#123;        cout &lt;&lt; &quot;cal1 is less than cal2&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;cal2 is less than cal1&quot; &lt;&lt; endl;    &#125;    const int total_len = strlen(cal1) + strlen(cal2) + 1;    //开辟total_len字节的空间    char *total_str = new char(total_len);    //将空间清空为0    memset(total_str, 0, total_len);    //将cal1 copy 到 total_str    strcpy(total_str, cal1);    //将total_str和cal2连接    strcat(total_str, cal2);    //输出total_str 的值    cout &lt;&lt; &quot;total_str is &quot; &lt;&lt; total_str &lt;&lt; endl;    //最后释放内存    if (total_str != nullptr)    &#123;        delete total_str;        total_str = nullptr;    &#125;&#125;\n\n习惯使用C语言的同学可以通过c_str()函数将string转化为const char*类型的字符串\n12string strcpp = &quot;CPP&quot;;const char *strc = strcpp.c_str();\n\n使用数组初始化vector对象vector除了可以通过初始化列表，指定初始值和大小等方式外，还可以通过数组和vector初始化 通过vector初始化\n123456vector&lt;int&gt; v1 = &#123;1, 3, 5, 7, 9&#125;;vector&lt;int&gt; v2(v1);for (auto v : v2)&#123;    cout &lt;&lt; v &lt;&lt; endl;&#125;\n\n通过数组初始化\n12345678910void vector_init2()&#123;    int a[] = &#123;2, 4, 6, 8, 10&#125;;    vector&lt;int&gt; v3(begin(a), end(a));    for (auto v : v3)    &#123;        cout &lt;&lt; v &lt;&lt; endl;    &#125;&#125;","slug":"数组","date":"2021-05-12T04:00:58.000Z","categories_index":"C++基础","tags_index":"C++,数组","author_index":"kiyose408"},{"id":"5391af7718199d3c4ba5b2fd9250437c","title":"迭代器","content":"迭代器当我们要遍历容器如vector,map等复杂结构时，可以通过迭代器进行遍历，依次取出容器中的值。通过容器类的begin()和end()函数获取指向第一个元素位置的迭代器和指向最后一个元素下一个位置的迭代器。 迭代器初步使用\n123456789void iterator_func()&#123;    string s(&quot;some string&quot;);    if (s.begin() != s.end())    &#123;        auto it = s.begin();        *it = toupper(*it);    &#125;&#125;\n\n上面代码修改了字符串第一个字母为大写。只有当字符串为空时s.begin()==s.end()\n迭代器运算迭代器支持加减运算，支持比较运算\n123456789*iter 返回iter所指对象得引用iter-&gt;mem 解引用返回iter所指对象得mem成员++iter 迭代器位置后移，指向下一个元素--iter 迭代器位置前移，指向上一个元素iter1 == iter2 判断iter1和iter2是否相等iter1 != iter2 判断iter1和iter2不相等iter = iter + n 迭代器iter向后偏移n个元素iter = iter -n 迭代器iter 向前偏移n个元素iter1 &gt;= iter2 迭代器iter1指向的元素是否在iter2之后\n\n迭代器遍历通过迭代器修改第一个单词为大写，遇到空格或者字符串末尾结束\n1234567string s(&quot;some string&quot;);for (auto iter = s.begin(); iter != s.end() &amp;&amp; !isspace(*iter); iter++)&#123;    *iter = toupper(*iter);&#125;cout &lt;&lt; &quot;str is &quot; &lt;&lt; s &lt;&lt; endl;\n\n通过iter++依次访问s中得每个字符，*iter返回的是每个字符的引用\n泛型编程关键概念：泛型编程原来使用C或Java的程序员在转而使用C++语言之后，会对for循环中使用！&#x3D;而非&lt;进行判断有点儿奇怪，。C++程序员习惯性地使用！&#x3D;，其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标准库提供的所有容器上都有效。之前已经说过，只有string和vector等一些标准库类型有下标运算符，而并非全都如此。与之类似，所有标准库容器的迭代器都定义了==和！&#x3D;，但是它们中的大多数都没有定义&lt;运算符。因此，只要我们养成使用迭代器和！&#x3D;的习惯，就不用太在意用的到底是哪种容器类型。\n迭代器类型那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型：const_iterator和常量指针差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。如果vector对象或string对象是一个常量，只能使用const_iterator；如果vector对象或string对象不是常量，那么既能使用iterator也能使用const_iterator。\n123456789101112131415161718// it能读写vector&lt;int&gt;的元素  vector&lt;int&gt;::iterator it;  // it2能读写string对象中的字符  vector&lt;string&gt;::iterator it2;  // it3 只能读元素,不能写元素  vector&lt;int&gt;::const_iterator it3;  // it4 只能读字符，不能写字符  vector&lt;string&gt;::const_iterator it4;  vector&lt;int&gt; v;  const vector&lt;int&gt; cv;  // vit1的类型是vector&lt;int&gt;::iterator  auto vit1 = v.begin();  // vit2的类型是vector&lt;int&gt;::const_iterator  auto vit2 = cv.begin();  //通过cbegin和cend可以获取常量迭代器  // cvit 类型为vector&lt;int&gt;::const_iterator  auto cvit = v.cbegin();\n\n解引用迭代器解引用要注意将*和迭代器括起来，因为*的优先级比.低，假设iter是vector&lt;string&gt;::iterator类型 判断迭代器所指向的字符串是否为空应该用(*iter).empty() 如果用*iter.empty()会被编译器理解为对迭代器先进行empty()函数运算再解引用，会报错，因为迭代器没有empty()操作 为了方便可以通过-&gt;解引用取出元素的成员或者成员函数，如下我们通过遍历，直到遇到空字符串就退出遍历\n12345678vector&lt;string&gt; text = &#123;&quot;zack&quot;,                       &quot;vivo&quot;,                       &quot;&quot;,                       &quot;lisus&quot;&#125;;for (auto it = text.begin(); it != text.end() &amp;&amp; !it-&gt;empty(); ++it)&#123;    cout &lt;&lt; *it &lt;&lt; endl;&#125;\n\n迭代器失效在通过迭代器遍历vector,string ,map等容器时，如果遍历的循环中添加元素或者删除元素会导致迭代器失效，因为添加元素或者删除元素会影响迭代器的值，可以通过如下方式在遍历的同时删除元素\n12345678910auto itdel = text.begin();while (itdel != text.end())&#123;    if (itdel-&gt;empty())    &#123;        itdel = text.erase(itdel);        continue;    &#125;    itdel++;&#125;\n\ntext.erase(itdel)返回的时下一个元素的迭代器，所以直接跳出本次循环继续遍历即可。\n二分查找迭代器可以做加减操作，所以我们用迭代器实现一个二分查找, orderv是一个vector,里面的数字是有序的，我们查找9\n1234567891011121314151617181920212223242526272829303132333435363738vector&lt;int&gt; orderv = &#123;1,                      2,                      3,                      5,                      6,                      8,                      9,                      10&#125;;bool bfind = false;auto findit = orderv.begin();auto beginit = orderv.begin();auto endit = orderv.end();while (beginit != endit)&#123;    auto midit = beginit + (endit - beginit) / 2;    if (*midit == 9)    &#123;        findit = midit;        bfind = true;        break;    &#125;    if (*midit &gt; 9)    &#123;        endit = midit - 1;    &#125;    if (*midit &lt; 9)    &#123;        beginit = midit + 1;    &#125;&#125;if (bfind)&#123;    cout &lt;&lt; &quot;find success, iter val is &quot; &lt;&lt; *findit &lt;&lt; endl;&#125;","slug":"迭代器","date":"2021-05-08T18:15:50.000Z","categories_index":"C++基础","tags_index":"C++,迭代器","author_index":"kiyose408"},{"id":"bfb8c7eb75a20258cca7b53c5617a35a","title":"Vector","content":"简介本文介绍vector的使用方法，vector是一种高效访问和修改的容器，支持遍历，索引访问。\n初始化1 用花括号进行列表初始化 2 可以用()指定初始值和个数初始化\n123456789101112131415void vector_init()&#123;    //列表初始化    vector&lt;string&gt; v1&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;    //错误用法    // vector&lt;string&gt; v2(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);    //初始化vector大小为10，每个元素为-1    vector&lt;int&gt; ivec(10, -1);    // 10个string类型的元素,每个都是hi    vector&lt;string&gt; svec(10, &quot;hi!&quot;);    // 10个元素，每个都初始化为0    vector&lt;int&gt; ivec2(10);    // 10个元素，每个都初始化为空string    vector&lt;string&gt; svec2(10);&#125;\n\n添加元素123456//利用push_back将元素添加到vector末尾vector&lt;int&gt; v2;for (int i = 0; i != 100; ++i)&#123;    v2.push_back(i);&#125;\n\n遍历访问1234567891011 // 求vector 每个元素平方值vector&lt;int&gt; v3&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;for (auto &amp;i : v3)&#123;    i *= i;&#125;for (auto i : v3)&#123;    cout &lt;&lt; i &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;\n\n下标访问123456789101112//索引访问// 11个分数段，全部初始化为0vector&lt;unsigned&gt; scores(11, 0);unsigned grade;//读取成绩while (cin &gt;&gt; grade)&#123;    //只处理有效成绩，小于等于100的成绩    if (grade &lt;= 100)    //对应的分数段+1，修改索引对应的元素值        ++scores[grade / 10];&#125;","slug":"vector类","date":"2021-05-07T02:15:20.000Z","categories_index":"C++基础","tags_index":"C++,Vector","author_index":"kiyose408"},{"id":"d7215eab570338175fadc0dc91188274","title":"String类","content":"简介今天介绍string类的使用\n初始化和定义123456789//默认初始化,s1是一个空字符串string s1;//赋值初始化,s2是s1的副本string s2 = s1;//直接初始化 字面值初始化string s3 = &quot;hiya&quot;;//直接初始化 构造函数初始化string s4(10, &#x27;c&#x27;);string s5(&quot;hello zack&quot;);\n\nstring操作12345678910111213141516171819202122232425262728293031323334353637383940414243void opstr_func()&#123;    //定义空字符串    string s;    //从输入流写入s    cin &gt;&gt; s;    //将s写入输出流    cout &lt;&lt; s &lt;&lt; endl;    //循环读取，直到遇到换行符或者非法输入    string world;    while (cin &gt;&gt; world)        cout &lt;&lt; world &lt;&lt; endl;    //读取一整行    string linestr;    while (getline(cin, linestr))    &#123;        cout &lt;&lt; linestr &lt;&lt; endl;    &#125;    //每次读入一整行，遇到空行跳过    while (getline(cin, linestr))    &#123;        if (!linestr.empty())        &#123;            cout &lt;&lt; linestr &lt;&lt; endl;            //打印字符串长度            cout &lt;&lt; linestr.size() &lt;&lt; endl;            // size()返回string::size_type类型的数据            string::size_type size = linestr.size();        &#125;    &#125;    // 比较    string str1 = &quot;Hello&quot;;    string str2 = &quot;Hello W&quot;;    string str3 = &quot;Za&quot;;    //依次比较每个字符，字符大的字符串就大    auto b2 = str3 &gt; str1;    cout &lt;&lt; b2 &lt;&lt; endl;    //前面字符相同，长度长的字符串大    auto b = str2 &gt; str1;    cout &lt;&lt; b &lt;&lt; endl;&#125;\n\nstring 类重载了 比较运算符，也重载了+运算符等,所以string支持+运算\n123456// string类对象相加string s1 = &quot;Hello&quot;, s2 = &quot;Zack&quot;;string s3 = s1 + &quot;,&quot; + s2 + &#x27;\\n&#x27;;cout &lt;&lt; s3 &lt;&lt; endl;//加号两侧至少有一个是string类型，否则报错// string s4 = &quot;Hello&quot; + &quot;Zack&quot;;\n\n对C语言的兼容建议：使用C++版本的C标准库头文件 C++标准库中除了定义C++语言特有的功能外，也兼容了C语言的标准库。C语言的头文件形如name.h，C++则将这些文件命名为cname。也就是去掉了.h后缀，而在文件名name之前添加了字母c，这里的c表示这是一个属于C语言标准库的头文件。因此，cctype头文件和ctype.h头文件的内容是一样的，只不过从命名规范上来讲更符合C++语言的要求。特别的，在名为cname的头文件中定义的名字从属于命名空间std，而定义在名为.h的头文件中的则不然。一般来说，C++程序应该使用名为cname的头文件而不使用name.h的形式，标准库中的名字总能在命名空间std中找到。如果使用.h形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些又是C++语言所独有的。\nC11用法如果想对string对象中的每个字符做点儿什么操作，目前最好的办法是使用C++11新标准提供的一种语句：范围for（rangefor）语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作，其语法形式是：\n12for(declaration:expression)    statement\n\n其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。一个string对象表示一个字符的序列，因此string对象可以作为范围for语句中的expression部分。举一个简单的例子，我们可以使用范围for语句把string对象中的字符每行一个输出出来：\n123456string str(&quot;hello zack&quot;);    //遍历输出str中的每个字符for (auto c : str)&#123;    cout &lt;&lt; c &lt;&lt; endl;&#125;\n\n统计字符串中标点符号的数量\n1234567891011string s(&quot;Hello World!!!&quot;);decltype(s.size()) punct_cnt = 0;//统计s中标点符号的数量for (auto c : s)&#123;    if (ispunct(c))        punct_cnt++;&#125;cout &lt;&lt; punct_cnt     &lt;&lt; &quot; punctuation characters in &quot;    &lt;&lt; s &lt;&lt; endl;\n\n将字符串变为大写\n12345678//将字符串变为大写string s3(&quot;Hello Vivo&quot;);for (auto &amp;c : s3)&#123;    //通过引用string中的字符，然后修改字符    c = toupper(c);&#125;cout &lt;&lt; s &lt;&lt; endl;\n\n将第一个单词变为大写\n1234567//通过下标索引修改字符串//把第一个单词变为大写string sind(&quot;some string&quot;);for (decltype(sind.size()) index = 0; index != sind.size() &amp;&amp; isspace(sind[index]); ++index)&#123;    sind[index] = toupper(sind[index]);&#125;","slug":"C++的string类","date":"2021-05-03T04:15:58.000Z","categories_index":"C++基础","tags_index":"C++,String类","author_index":"kiyose408"},{"id":"9a1c9eab819449bb12fa84a4154b8457","title":"C++的输入和输出.","content":"iostreamC++提供了标准的输入输出流功能，需要包含iostream头文件，之后就可以使用cin进行输入，cout进行输出。\n1234567891011#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void cin_func()&#123;    string input;    cout &lt;&lt; &quot;input your words &quot; &lt;&lt; endl;    cin &gt;&gt; input;    cout &lt;&lt; &quot;your input is &quot; &lt;&lt; endl;    cout &lt;&lt; input &lt;&lt; endl;&#125;\n程序输出：\n1234input your wordszackyour input iszack\n&gt;&gt;  会获取输入来写入缓存，并返回cin对象，&lt;&lt;  会从缓存中读取数据，写入cout并返回cout，最后endl会将cout缓存中的数据输出到终端。\n变量12345678910111213141516171819void var_func()&#123;    //整形，4字节    int a = 100;    //ll整形, 8字节    long long lla = 1000;    //长整型， 4 字节    long la = 1024;    //短整型,2 字节    short sa = 200;    //带符号字符型,    //字符型使用时最好指示带符号还是不带符号    //因为在不同的机器上不指明char符号可能会有问题    signed char sc = &#x27;a&#x27;;    //无符号字符型    unsigned char uc = &#x27;m&#x27;;    //bool类型    bool bt = true;&#125;\n\n类型转换当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true。 当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。 当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。 当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8比特大小的unsigned char所得的结果是255。 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。\n12345bool b = 42; //b为trueint i = b; //i 为1i = 3.14; //i 为3double pi = i; //pi为3.0unsigned char c = -1; //\n\n变量的声明和定义用extern在头文件声明，在CPP源文件中定义，可以保证变量不会被重复包含。\n12//只声明aextern int a;\n如果extern后面做了赋值操作，则不是声明而是定义。\n12extern int a= 100;\n不带extern直接类型+变量名就是定义。\n123//如下都是定义int age = 100;int num ;\n\n引用引用就是变量的别名，通过修改引用达到修改变量的值的目的。\n12345int j = 20;// i 是j的引用int &amp;i = j;j = 200;cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;\n\n指针指针值指针的值（即地址）应属下列4种状态之一： 1.指向一个对象。 2.指向紧邻对象所占空间的下一个位置。 3.空指针，意味着指针没有指向任何对象。 4.无效指针，也就是上述情况之外的其他值。\n12345678//通过对指针的值做解引用(*)，拿到其指向的值，再修改这个值，达到修改指向对象数据的目的void piont_func()&#123;    int age = 18;    int *page = &amp;age;    *page += 2;    cout &lt;&lt; age &lt;&lt; &quot; &quot; &lt;&lt; page &lt;&lt; endl;&#125;\n\n指向指针的引用12345678910111213void poinref_func()&#123;    int i = 42;    // p是一个指针    int *p;    // r 是一个对p的引用    int *&amp;r = p;    // 令r指向了一个指针p    //给r赋值为&amp;i,就是p指向了i    r = &amp;i;    //解引用r得到i,也就是p指向的对象，将i的值修改为0    *r = 0;&#125;\n\n常量12345678910111213141516171819202122232425262728293031void const_func()&#123;    // 常量定义一定要初始化赋值，否则编译报错    const int bufSize = 512;    //修改bufSize的值会报错    //编译器提示表达式必须是可修改的左值    // bufSize = 222;    //运行时初始化    const int i = get_size();    //编译时初始化    const int j = 43;    //如果定义const变量不初始化也会报错    // const int k;    //利用一个常量初始化另一个常量    const int cj = j;    // const引用,引用及其对应的对象都是const    const int &amp;r1 = cj;    //不可以修改r1的值    // r1 = 42;    //不可以用非常量引用指向一个常量对象    // int &amp;r2 = ci;    int iv = 42;    //允许将const int&amp;绑定到一个普通int对象上    const int &amp;r1 = iv;    //正确, r2是一个常量引用    const int &amp;r2 = 42;    //正确, r3是一个常量引用    const int &amp;r3 = r1 * 2;    //错误, r4 是一个普通非常量的引用    // int &amp;r4 = r1 * 2;&#125;\n\n指向常量的指针指向常量的指针不可以通过指针修改指向内容的数据\n1234567891011121314void pconst_func()&#123;    //指向常量的指针    const double pi = 3.14;    //不可以用普通指针指向常量    // double *ptr = &amp;pi;    //用常量指针指向常量    const double *cptr = &amp;pi;    //不能给*cptr赋值因为cptr指向的是常量    // *cptr = 42;    //指向常量的指针指向非常量    double dval = 3.14;    cptr = &amp;dval;&#125;\n\n常量指针指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。 常量指针（const pointer）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。 把＊放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值\n123456789101112//常量指针//常量指针的值初始化后就不允许修改int errNumb = 0;// curErr将一直指向errNumbint *const curErr = &amp;errNumb;//不允许修改curErr的指向int rightNumb = 1;//编译报错，提示=左侧必须为可修改的左值// curErr = &amp;rightNumb;const double pi = 3.14159;// pip是一个指向常量对象的常量指针const double *const pip = &amp;pi;\n\n顶层const指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词顶层const（top-levelconst）表示指针本身是个常量，而用名词底层const（low-level const）表示指针所指的对象是一个常量。顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const。\nconstexper变量在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。当然可以定义一个const变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。可以这么说，在此种情况下，对象的定义和使用根本就是两回事儿\nC++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：\n123456789void constexpr_func()&#123;    // 20是一个常量表达式    constexpr int mf = 20;    // mf + 1是一个常量表达式    constexpr int limit = mf + 1;    // size是一个constexpr函数    constexpr int sizen = size();&#125;\n\n尽管不能使用普通函数作为constexpr变量的初始值，新标准允许定义一种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。\n常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”（literal type）。到目前为止接触过的数据类型中，算术类型、引用和指针都属于字面值类型。 尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。\n指针和constexpr在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。\n1234567void pointer_constexpr()&#123;    // p是一个指向整形常量的指针,p可以修改，但是*P不可修改    const int *p = nullptr;    // q是一个指向整形变量的常量指针,q不可修改,但是*q可以修改    constexpr int *q = nullptr;&#125;\np和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在于constexpr把它所定义的对象置为顶层const。与其他常量指针类似，constexpr 指针既可以指向常量也可以指向一个非常量：\n12345678910111213141516171819int j = 0;// i 的类型是整型常量constexpr int i = 42;void pointer_constexpr()&#123;    // p是一个指向整形常量的指针,p可以修改，但是*P不可修改    const int *p = nullptr;    // q是一个指向整形变量的常量指针,q不可修改,但是*q可以修改    constexpr int *q = nullptr;    // np是一个指向整数的常量指针，其中为空    constexpr int *np = nullptr;    // i和j必须定义在函数体之外，否则报错，提示p访问运行时存储    //因为constexpr要求表达式为常量，在编译时展开    //  p是常量指针，指向整形常量i    constexpr const int *p2 = &amp;i;    // p1是常量指针，指向整数j    constexpr int *p1 = &amp;j;&#125;\n\n类型别名类型别名(type alias)是一个名字，他是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚的知道使用该类型的真实目的。有两种方法可用于定义类型别名。传统的方法是使用关键字typedef: 1 typedef\n12345678910void typedef_func()&#123;    // wages是double的同义词    typedef double wages;    // base是double的同义词， p 是double*的同义词    typedef wages base, *p;    // C11用法    using newd = double;    newd dd = 3.14;&#125;\n新标准规定了一种新的方法，使用别名声明（aliasdeclaration）来定义类型的别名，using newd &#x3D; 都变了就是通过using定义new类型和double是相同的。\n如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型pstring，它实际上是char *的别名。\n12345678910111213141516void typedef_func()&#123;    typedef char *pstring;    // pstring是一个指向char的常量指针    const pstring cstr = 0;    // ps 是一个指针，其对象是指向char的常量指针    const pstring *ps;    char b = &#x27;H&#x27;;    //不可修改    // cstr = &amp;b;    ps = &amp;cstr;    const pstring cstr2 = &amp;b;    ps = &amp;cstr2;    //不可修改*ps的值    // *ps = cstr;&#125;\n\nauto 推导编程时常常需要把表达式的值付给变量，这就要求在声明变量的时候清楚地知道表达式的类型。为了做到这一点在C++11新标准中引入了auto类型说明符，用它就能让编译器去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如double）不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值，使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样。\n123456789101112131415161718192021void auto_func()&#123;    int a = 100;    int b = 1024;    // c被推导为int类型    auto c = a + b;    auto i = 0, *p = &amp;i;    //一条声明语句只能有一个基本数据类型    //不同类型编译器会报错    // auto sz = 0, pi = 3.14;    const int ma = 1;    // auto会忽略顶层const    //可以通过const明确指出，此时f为const int类型    const auto f = ma;    // auto配合引用类型    auto &amp;g = a;    // 不能为非常量引用绑定字面值    // auto &amp;h = 42;    //指明const 引用绑定字面值    const auto &amp;j = 42;&#125;\n\nauto一般会忽略掉顶层const，同时底层const则会保留下来 要在一条语句中定义多个变量，切记，符号&amp;和＊只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型：\n12345678// k是int类型，l是int的引用// auto 忽略了顶层constauto k = ci, &amp;l = i;// m是int常量的引用，p是指向int常量的指针// auto保留了底层constauto &amp;m = ci, *p = &amp;ci;// 错误 i的类型是int， ci的类型是 const int// auto &amp;n = i, *p2 = &amp;ci;\n\ndecltype类型指示符有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：\n1decltype(size()) sum;\n\n编译器并不实际调用函数size，而是使用当调用发生时size的返回值类型作为sum的类型。换句话说，编译器为sum指定的类型是什么呢？就是假如size被调用的话将会返回的那个类型。decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：\n1234567891011void decltype_func()&#123;    decltype(size()) sum;    const int ci = 0, &amp;cj = ci;    // x的类型是const int    decltype(ci) x = 0;    // y的类型是 const int&amp; , y绑定到变量x    decltype(cj) y = x;    //错误，z是一个引用，必须初始化    // decltype(cj) z;&#125;\n\n因为cj是一个引用，decltype（cj）的结果就是引用类型，因此作为引用的z必须被初始化。需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型.\n1234567int i = 42, *p = &amp;i, &amp;r = i;// b1 是一个int类型的引用decltype(r) b1 = i;// r+0 通过decltype返回int类型decltype(r + 0) b2;//错误，必须初始化,c是int&amp;类型// decltype(*p) c;","slug":"C++的输入和输出","date":"2021-05-01T18:15:58.000Z","categories_index":"C++基础","tags_index":"C++,iostream,变量和常量","author_index":"kiyose408"},{"id":"8f8db2152464e78ca34ca60a3d6e1e07","title":"HBuilderX快捷编写Markdown","content":"在HBuilderX中编写Markdown文件时，可以利用以下快捷键来提高效率：\n\nEmmet快速输入：\n\n敲击h2+Tab可生成二级标题，同理适用于其他级别的标题，如h3+Tab生成三级标题等。\n\n\n智能双击：\n\n双击#号可选中整个标题段落。\n\n\n智能回车：\n\n行尾回车或行中Ctrl+Enter强制换行后会自动补全相应的#符号。\n连续两次回车后自动移除补全的#。\n\n\n递进标题层级与切换列表符：\n\n回车后再次按Tab键可递进一层标题。\n再次按Tab切换列表符类型。\n\n\n插入元素：\n\n加粗：Ctrl/Cmd + B\n标题：Ctrl/Cmd + H\n插入链接：Ctrl/Cmd + K\n插入代码块：Ctrl/Cmd + Shift + C\n行内代码：Ctrl/Cmd + Shift + K\n插入图片：Ctrl/Cmd + Shift + I\n无序列表：Ctrl/Cmd + Shift + L\n\n\n文档操作：\n\n折叠标题段落：在标题前的-号上点击或使用Alt+-（展开使用Alt+=）。\n全文折叠&#x2F;展开：Ctrl+Alt+Shift+- 或 =。\n折叠其他区域：Alt+Shift+O。\n\n\n导航与视图：\n\n打开或隐藏视图栏目：Alt+N聚焦编辑区。\n切换标签页：Alt+数字键，如Alt+1切换到第一个标签页。\n\n\n其他常用快捷键：\n\n中途换行：Ctrl+Enter\n向上插入空行：Ctrl+Shift+Enter\n注释代码：Ctrl+/\n\n\n\n这些快捷键可以帮助您更高效地在HBuilderX中编写和编辑Markdown文档。请注意，具体快捷键可能依据软件版本和个人设置有所不同，请根据实际情况调整。\n","slug":"HbuildX中编写Markdown文件的快捷办法","date":"2021-04-15T10:50:36.000Z","categories_index":"实用教程","tags_index":"markdown,HBuildX,快捷操作","author_index":"kiyose408"},{"id":"c847bfd470a979bb27b4c7fa12ad9905","title":"Hexo文章模版","content":"头部信息Hexo 的 Aurora 主题是一个流行的开源博客主题，提供了丰富的自定义选项来帮助用户个性化他们的博客。在编写文章时，可以通过在文章的 Front-matter（头部信息）中添加特定的配置项来控制文章的显示方式和其他特性。Aurora 主题支持 Hexo 默认的 Front-matter 配置项，同时也可能包含一些特定于该主题的配置。以下是一些你可以在 Aurora 主题文章头部配置的常见选项：\n\ntitle: 文章标题。\n\ndate: 文章发布日期。\n\nupdated: 文章最后更新日期（可选）。\n\ncategories: 文章分类，可以是单个字符串或字符串数组。\n\ntags: 文章标签，通常是字符串数组。\n\nlayout: 布局类型，默认通常是 post。\n\npermalink: 自定义文章的永久链接。\n\ncomments: 是否开启评论功能，通常接受 true 或 false。\n\n\nAurora 特定的 Front-matter 配置可能包括但不限于：\n\nthumbnail: 文章缩略图的路径，用于摘要卡片或列表视图中。\n\nbanner: 文章顶部的大图 banner，适用于某些文章详情页面。\n\nexcerpt: 文章摘要，如果未设置，主题可能会自动从正文摘取一部分作为摘要。\n\nmathjax: 如果文章中包含数学公式，可以设置为 true 来启用 MathJax 支持。\n\ntoc: 是否在文章中显示目录（Table of Contents），通常接受 true 或 false。\n\ncopyright: 版权信息或原文链接，适用于转载文章。\n\nreward: 打赏信息，如果开启了打赏功能，可以在这里设置相关信息。\n\nsticky: 是否置顶文章，通常在首页列表中将文章置顶显示，可能接受 true 或 false。\n\nseries: 如果文章属于某个系列，可以在这里指定系列名称。\n\npassword: 为文章设置阅读密码。\n\n\n请注意，随着Aurora主题的更新，可用的配置项可能会有所变化，因此建议查阅Aurora主题的官方文档或GitHub仓库的最新说明，以获取最准确和最新的配置信息。同时，自定义配置时，遵循Markdown文件的YAML格式规范是很重要的。\n1234567891011121314151617181920212223---title: Autora文章模版date: 2020-05-30 2:15:58update: 2020-05-30 10:29:43categories: \t- 实用教学tags:\t- hexo\t- auroralayout: postpermalink:comments: falsethumbnail:banner:excerpt: mathjax:toc:copyright:reward: sticky: series: password: ---\n\nmarkdown的基础使用方法Markdown 是一种轻量级的文本格式语言，设计初衷是为了让人们使用易读易写的纯文本格式编写文档，然后转换成结构化的HTML（超文本标记语言）。下面是一些基本的Markdown语法示例，涵盖了日常写作中最常用的功能：\n标题\n一级标题：# 我是一级标题\n二级标题：## 我是二级标题\n三级标题：### 我是三级标题\n…以此类推，最多到六级标题。\n\n段落与换行\n直接输入文本就是一段落，段落之间空一行表示分隔。\n换行：在行尾加上两个空格然后回车。\n\n强调\n斜体：*斜体文本* 或 _斜体文本_斜体文本\n粗体：**粗体文本** 或 __粗体文本__粗体文本\n删除线：~~删除线文本~~删除线文本\n\n列表\n无序列表：\n- 列表项1\n- 列表项2\n\n\n有序列表：\n列表项1\n列表项2\n\n\n\n链接\n[链接文字](链接地址)，如：百度\n\n图片\n![图片描述](图片地址)，如：![我的图片](https://example.com/image.jpg)\n\n代码\n行内代码：代码片段，如：print(&quot;Hello World&quot;)\n代码块：  12这里是代码块多行代码\n\n引用\n\n引用文本\n\n\n\n分割线\n--- 或 *** 或 ___，用于创建水平分割线。\n\n任务列表\n- [ ] 未完成任务\n\n- [x] 已完成任务\n\n \n未完成任务\n\n \n已完成任务\n\n\n以上是Markdown的基本使用方法，掌握这些就能满足大部分写作需求。Markdown的强大之处在于它的简洁与易学性，随着使用你会逐渐发现更多进阶功能和技巧。\n","slug":"Hexo文章模版","date":"2020-05-29T18:15:58.000Z","categories_index":"实用教程","tags_index":"hexo,aurora","author_index":"kiyose408"},{"id":"8412bcb71a16d5331194e0e41f73e27d","title":"Hexo搭建博客网站","content":"使用Hexo快速搭建个人笔记网站的步骤相对直接，下面是简化的流程指导：\n准备工作\n安装Node.js: Hexo是基于Node.js的，首先确保你的计算机上安装了Node.js。访问 Node.js官方网站 下载并安装最新稳定版。\n\n安装Git: 如果你还没有Git，也需要安装它，因为后续会用到Git来部署网站到GitHub等平台。访问 Git官方网站 下载安装。\n\n\n安装Hexo\n打开命令行工具（Windows下是CMD或PowerShell，Mac&#x2F;Linux下是Terminal）。\n\n运行以下命令安装Hexo：\n1Normal Tips Container\n\n创建Hexo项目\n在你想要存放博客文件的目录下，打开命令行工具，运行以下命令初始化Hexo项目：\n1hexo init your-blog-name\nyour-blog-name 是你给博客起的名字，这个命令会在这个目录下创建一个基本的Hexo项目结构。\n\n初始化完成后，进入项目目录：\n1cd your-blog-name\n\n安装项目依赖：\n1npm install\n\n启动本地服务器预览\n运行以下命令启动本地服务器：1hexo server\n访问 http://localhost:4000 查看你的博客。\n\n编写笔记（博客文章）\n使用Markdown编写笔记，文件通常放在source/_posts目录下。可以通过命令创建新文章：1hexo new &quot;我的第一篇笔记&quot;\n\n部署到GitHub Pages\n登录GitHub，创建一个新的仓库，比如命名为your-github-username.github.io。\n\n回到本地Hexo项目，编辑 _config.yml 文件，配置部署部分，添加如下内容：\n1234deploy:  type: git  repo: https://github.com/your-github-username/your-github-username.github.io.git  branch: main # 或者 master，取决于你的GitHub Pages设置\n\n安装部署工具（如果你还没有安装的话）：\n1npm install hexo-deployer-git --save\n\n最后，运行命令部署到GitHub：\n1hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy\n\n完成上述步骤后，你的笔记网站就会被部署到GitHub Pages，可以通过 https://your-github-username.github.io 访问。\n记得替换上述命令中的your-blog-name、your-github-username等占位符为实际的名称。此外，你可以通过更换Hexo主题来个性化你的网站外观，主题可以从Hexo的官方主题库或GitHub上找到。\n博客的更新在Hexo中，当你对博客的文件进行了更新或修改后，需要经过以下几个步骤来更新部署你的博客：\n\n生成静态文件：打开终端（Command Prompt、PowerShell、Terminal或Git Bash等），导航到你的Hexo项目根目录，然后运行以下命令来生成新的静态文件：\n1hexo clean &amp;&amp; hexo generate\n或简写为：\n1hexo g\nhexo clean 命令会先清除之前生成的静态文件，确保部署的是最新的内容。hexo generate 或 hexo g 则会根据你的Markdown文件和配置生成新的静态文件。\n\n部署到远程服务器：接下来，你需要将生成的静态文件部署到你的远程服务器或GitHub Pages、GitLab Pages等托管服务上。执行以下命令进行部署：\n1hexo deploy\n或简写为：\n1hexo d\n首次使用hexo deploy前，你可能需要在 _config.yml 文件中配置部署信息，例如如果你使用GitHub Pages，可能需要如下配置：\n1234deploy:  type: git  repo: https://github.com/your_username/your_repo.git  branch: main # 或者 gh-pages，取决于你的设置\n确保你已经正确设置了SSH密钥，并且你的GitHub或其他托管服务账户已授权。\n\n\n如果你之前已经配置了自动部署或者有特定的部署脚本（比如通过deploy.sh），则只需执行部署命令，Hexo会自动处理文件的生成和推送。\n完成以上步骤后，你的博客就应该更新为最新的内容了。记得检查你的部署日志输出，确认部署过程中没有错误发生。\nmarkdown文章前置模版1234567891011121314---layout:title: abstracts: date: tags:  -   - categories:  - cover: feature: truetop: false---","slug":"Hexo搭建博客","date":"2020-05-16T15:15:58.000Z","categories_index":"实用教程","tags_index":"Hexo,网站搭建","author_index":"kiyose408"}]