[{"id":"8412bcb71a16d5331194e0e41f73e27d","title":"Hexo搭建博客网站","content":"使用Hexo快速搭建个人笔记网站的步骤相对直接，下面是简化的流程指导：\n准备工作\n安装Node.js: Hexo是基于Node.js的，首先确保你的计算机上安装了Node.js。访问 Node.js官方网站 下载并安装最新稳定版。\n\n安装Git: 如果你还没有Git，也需要安装它，因为后续会用到Git来部署网站到GitHub等平台。访问 Git官方网站 下载安装。\n\n\n安装Hexo\n打开命令行工具（Windows下是CMD或PowerShell，Mac&#x2F;Linux下是Terminal）。\n\n运行以下命令安装Hexo：\n1Normal Tips Container\n\n创建Hexo项目\n在你想要存放博客文件的目录下，打开命令行工具，运行以下命令初始化Hexo项目：\n1hexo init your-blog-name\nyour-blog-name 是你给博客起的名字，这个命令会在这个目录下创建一个基本的Hexo项目结构。\n\n初始化完成后，进入项目目录：\n1cd your-blog-name\n\n安装项目依赖：\n1npm install\n\n启动本地服务器预览\n运行以下命令启动本地服务器：1hexo server\n访问 http://localhost:4000 查看你的博客。\n\n编写笔记（博客文章）\n使用Markdown编写笔记，文件通常放在source/_posts目录下。可以通过命令创建新文章：1hexo new &quot;我的第一篇笔记&quot;\n\n部署到GitHub Pages\n登录GitHub，创建一个新的仓库，比如命名为your-github-username.github.io。\n\n回到本地Hexo项目，编辑 _config.yml 文件，配置部署部分，添加如下内容：\n1234deploy:  type: git  repo: https://github.com/your-github-username/your-github-username.github.io.git  branch: main # 或者 master，取决于你的GitHub Pages设置\n\n安装部署工具（如果你还没有安装的话）：\n1npm install hexo-deployer-git --save\n\n最后，运行命令部署到GitHub：\n1hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy\n\n完成上述步骤后，你的笔记网站就会被部署到GitHub Pages，可以通过 https://your-github-username.github.io 访问。\n记得替换上述命令中的your-blog-name、your-github-username等占位符为实际的名称。此外，你可以通过更换Hexo主题来个性化你的网站外观，主题可以从Hexo的官方主题库或GitHub上找到。\n博客的更新在Hexo中，当你对博客的文件进行了更新或修改后，需要经过以下几个步骤来更新部署你的博客：\n\n生成静态文件：打开终端（Command Prompt、PowerShell、Terminal或Git Bash等），导航到你的Hexo项目根目录，然后运行以下命令来生成新的静态文件：\n1hexo clean &amp;&amp; hexo generate\n或简写为：\n1hexo g\nhexo clean 命令会先清除之前生成的静态文件，确保部署的是最新的内容。hexo generate 或 hexo g 则会根据你的Markdown文件和配置生成新的静态文件。\n\n部署到远程服务器：接下来，你需要将生成的静态文件部署到你的远程服务器或GitHub Pages、GitLab Pages等托管服务上。执行以下命令进行部署：\n1hexo deploy\n或简写为：\n1hexo d\n首次使用hexo deploy前，你可能需要在 _config.yml 文件中配置部署信息，例如如果你使用GitHub Pages，可能需要如下配置：\n1234deploy:  type: git  repo: https://github.com/your_username/your_repo.git  branch: main # 或者 gh-pages，取决于你的设置\n确保你已经正确设置了SSH密钥，并且你的GitHub或其他托管服务账户已授权。\n\n\n如果你之前已经配置了自动部署或者有特定的部署脚本（比如通过deploy.sh），则只需执行部署命令，Hexo会自动处理文件的生成和推送。\n完成以上步骤后，你的博客就应该更新为最新的内容了。记得检查你的部署日志输出，确认部署过程中没有错误发生。\nmarkdown文章前置模版1234567891011121314---layout:title: abstracts: date: tags:  -   - categories:  - cover: feature: truetop: false---","slug":"Hexo搭建博客","date":"2022-05-16T15:15:58.000Z","categories_index":"实用教程","tags_index":"Hexo,网站搭建","author_index":"kiyose408"},{"id":"d7ccd0a2fc5b38ef8ee1737116d9945c","title":"函数","content":"函数一个典型的函数（function）定义包括以下部分：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。其中，形参以逗号隔开，形参的列表位于一对圆括号之内，如下就是一个函数的定义\n123void funca()&#123;    cout &lt;&lt; &quot;hello world!!!&quot; &lt;&lt; endl;&#125;\n\n局部变量在C++语言中，名字有作用域，对象有生命周期（lifetime）。理解这两个概念非常重要。 · 名字的作用域是程序文本的一部分，名字在其中可见。 · 对象的生命周期是程序执行过程中该对象存在的一段时间。 如我们所知，函数体是一个语句块。块构成一个新的作用域，我们可以在其中定义变量。形参和函数体内部定义的变量统称为局部变量（local variable）。它们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏（hide）在外层作用域中同名的其他所有声明中。\n自动对象对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为自动对象（automatic object）。函数形参和函数内部定义的普通变量都是自动对象。\n局部静态对象某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型从而获得这样的对象。局部静态对象（local static object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。\n1234567891011size_t count_calls()&#123;    //调用结束后，这个值仍然有效    static size_t ctr = 0;    return ++ctr;&#125;for (size_t i = 0; i != 10; ++i)&#123;    cout &lt;&lt; count_calls() &lt;&lt; endl;&#125;\n\n这段程序将输出从1到10（包括10在内）的数字。在控制流第一次经过ctr的定义之前，ctr被创建并初始化为0。每次调用将ctr加1并返回新值。每次执行count_calls函数时，变量ctr的值都已经存在并且等于函数上一次退出时ctr的值。因此，第二次调用时ctr的值是1，第三次调用时ctr的值是2，以此类推。 局部静态变量赋初值只在第一次执行时赋初值的操作，以后再执行都不会进行赋初值的操作。而且生命周期随着程序结束才结束。\n参数传递值传递函数的形参如果是非引用类型则是值传递,函数内部修改形参不会影响到外部实参的值\n12345678void nochange(int a)&#123;    a--;    cout &lt;&lt; a &lt;&lt; endl;&#125;    int m = 6;    nochange(m);    cout &lt;&lt; m &lt;&lt; endl;\n\n程序输出5和6，在函数内部输出的是5，在函数外部输出的是6，可见值传递不会改变实参的值，如果要改变实参的值可以通过引用或者指针操作。\n指针形参指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值\n12345678void change(int *p)&#123;    (*p)--;    cout &lt;&lt; *p &lt;&lt; endl;&#125;int m = 6;change(&amp;m);cout &lt;&lt; m &lt;&lt; endl;\n\n输出5，5 p指向了m的地址，所以*p取到的是m的空间数据，这样就达到修改m的效果。\n传引用参数函数参数为引用类型可以达到通过函数内部修改外部实参的效果，也可以减少传递参数造成的copy开销，拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。\n12345678void change(int &amp;ra)&#123;    ra--;    cout &lt;&lt; ra &lt;&lt; endl;&#125;int m = 6;change(m);cout &lt;&lt; m &lt;&lt; endl;\n\n输出两个5，参数为引用类型，可以通过函数内部修改外部实参的值。 我们准备编写一个函数比较两个string对象的长度。因为string对象可能会非常长，所以应该尽量避免直接拷贝它们，这时使用引用形参是比较明智的选择。又因为比较长度无须改变string对象的内容，所以把形参定义成对常量的引用\n1234bool isShorter(const string &amp;s1, const string &amp;s2)&#123;    return s1.size() &lt; s2.size();&#125;\n\n使用引用形参返回额外信息一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。举个例子，我们定义一个名为find_char的函数，它返回在string对象中某个指定字符第一次出现的位置。同时，我们也希望函数能返回该字符出现的总次数。\n1234567891011121314151617181920string ::size_type find_char(const string &amp;s, char c, string::size_type &amp;occurs)&#123;    //第一次出现的位置(如果有的话)    auto ret = s.size();    //设置表示出现次数的形参的值    occurs = 0;    for (decltype(ret) i = 0; i != s.size(); ++i)    &#123;        if (s[i] == c)        &#123;            if (ret == s.size())                //记录c第一次出现的位置                ret = i;            //出现的次数+1            ++occurs;        &#125;    &#125;    return ret;&#125;\n\n参数为数组当函数的参数为数组时，一般都显示传递一个数组的大小参数\n123456789// const int ia[]等价于const int * ia// size表示数组的大小，将它显示地传给函数用于控制对ia元素的访问void print_array(const int ia[], size_t size)&#123;    for (size_t i = 0; i != size; ++i)    &#123;        cout &lt;&lt; ia[i] &lt;&lt; endl;    &#125;&#125;\n\n主函数可以这样调用\n12int j[] = &#123;0, 1&#125;; print_array(j, end(j) - begin(j));\n\n数组引用形参12345678// arr是数组的引用，维度是类型的一部分void print_arrayref(int (&amp;arr)[10])&#123;    for (auto elem : arr)    &#123;        cout &lt;&lt; elem &lt;&lt; endl;    &#125;&#125;\n\ninitializer_list形参如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组\n12345678void error_msg(initializer_list&lt;string&gt; il)&#123;    for (auto beg = il.begin(); beg != il.end(); beg++)    &#123;        cout &lt;&lt; *beg &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;\n\n返回值函数可以是void类型不返回数据，也可以是有返回值类型，但是不要返回局部变量的指针或者引用。如前所述，返回局部对象的引用是错误的；同样，返回局部对象的指针也是错误的。一旦函数完成，局部对象被释放，指针将指向一个不存在的对象。 也可以返回引用类型，这样返回值就可以作为左值使用\n12345678char &amp;get_val(string &amp;str, string::size_type ix)&#123;    return str[ix];&#125;  string s(&quot;a value&quot;);    cout &lt;&lt; s &lt;&lt; endl; //输出a value      //将s的第一个字母修改为A    get_val(s, 0) = &#x27;A&#x27;;\n\n返回值为数组的指针或引用因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。\n123456// arrT是一个类型别名，他表示的类型含有10个整数数组typedef int arrT[10];// arrT的等价声明using arrT2 = int[10];// func返回一个指向含有10个整数的数组的指针arrT *func(int);\n\n声明一个返回数组指针的函数如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。因此，返回数组指针的函数形式如下所示：\n1Type (*function(parameter_list))[dimension]\n\n举个具体点的例子，下面这个func函数的声明没有使用类型别名：\n1int (*func(int i))[10];\n\n· func（int i）表示调用func函数时需要一个int类型的实参。 · （＊func（int i））意味着我们可以对函数调用的结果执行解引用操作。 · （＊func（int i））[10]表示解引用func的调用将得到一个大小是10的数组。 · int （＊func（int i））[10]表示数组中的元素是int类型。\n尾置类型在C++11新标准中还有一种可以简化上述func声明的方法，就是使用尾置返回类型（trailing return type）。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto：\n123// func接受一个int类型的实参，返回值为一个指针//该指针指向含有10个整数的数组auto func(int i) -&gt; int (*)[10];\n\n使用decltype如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个：\n12345678int odd[] = &#123;1, 3, 5, 7, 9&#125;;int even[] = &#123;0, 2, 4, 6, 8&#125;;//返回一个指针，该指针指向含有5个整数的数组decltype(odd) *arrPtr(int i)&#123;    return (i % 2) ? &amp;odd : &amp;even;&#125;\n\n函数重载如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载（overloaded）函数。\n123void print(const char *cp);void print(const int *beg, const int *end);void print(const int ia[], size_t size);\n\n利用const_cast实现两个返回最小字符串的函数\n12345678910const string &amp;shorterString(const string &amp;s1, const string &amp;s2)&#123;    return s1.size() &lt;= s2.size() ? s1 : s2;&#125;string &amp;shorterString(string &amp;s1, string &amp;s2)&#123;    auto &amp;r = shorterString(const_cast&lt;const string &amp;&gt;(s1), const_cast&lt;const string &amp;&gt;(s2));    return const_cast&lt;string &amp;&gt;(r);&#125;\n\n默认实参我们可以对函数形参设置默认值，如果不传实参，则用形参默认值\n12typedef string::size_type sz;void screen(sz ht = 24, sz wh = 80, char back = &#x27; &#x27;);\n\n我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。 使用时可以\n123456//函数形参分别为100,200,&#x27;a&#x27;screen(100,200,&#x27;a&#x27;);//函数形参分别为100,200,&#x27; &#x27;screen(100,200);//函数形参分别为24,80,&#x27; &#x27;screen();\n\n内联函数内联函数可避免函数调用的开销将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开 constexpr函数（constexpr function）是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句：\n12constexpr int new_sz() &#123; return 42; &#125;constexpr int foo = new_sz();\n\n执行该初始化任务时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。 我们允许constexpr函数的返回值并非一个常量：\n1constexpr size_t scale(size_t cnt) &#123; return new_sz() * cnt; &#125;\n\n当scale的实参是常量表达式时，它的返回值也是常量表达式；反之则不然：\n123456//正确，scale(2)返回的是常量int arr[scale(2)];//i不是常量，scale返回的不是常量int i = 2;//编译器报错int arr2[scale(i)];\n\n函数指针函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。\n12// pf指向一个函数,该函数的参数是两个const string 的引用，返回bool类型bool (*pf)(const string &amp;, const string &amp;);\n\n从我们声明的名字开始观察，pf前面有个＊，因此pf是指针；右侧是形参列表，表示pf指向的是函数；再观察左侧，发现函数的返回类型是布尔值。因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。 ＊pf两端的括号必不可少。如果不写这对括号，则pf2是一个返回值为bool指针的函数：\n12//声明一个名为pf2的函数返回值类型为bool*bool *pf2(const string &amp;, const string &amp;);\n\n虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要想声明一个返回函数指针的函数，最简单的办法是使用类型别名\n1234// F是函数类型，不是指针using F = int(int *, int);// PF是指针类型using PF = int (*)(int *, int);\n\nf1,f2,f3都是返回函数指针的函数\n123F *f1(int);PF f2(int);int (*f3(int))(int *, int);\n\n对于f3的声明，按照由内向外的顺序阅读这条声明语句：我们看到f3有形参列表，所以f3是个函数；f3前面有*，所以f3返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int。 我们可以使用尾置声明\n1234auto f4(int) -&gt; int (*)(int *, int);string::size_type sumLength(const string &amp;, const string &amp;);//根据形参取值，getFcn函数返回值为指向sumLength的指针decltype(sumLength) *getFcn(const string &amp;);\n\n以下几种调用都是正常的\n123456789using PF = int (*)(int *, int*);using F =  int(int *, int *);PF test1 = &amp;test;PF test2 = test;F* test3 = test;test1(nullptr, nullptr);test2(nullptr, nullptr);(*test2)(nullptr, nullptr);test3(nullptr, nullptr);","slug":"函数","date":"2021-05-08T12:10:53.000Z","categories_index":"C++基础","tags_index":"C++,函数","author_index":"kiyose408"},{"id":"078e2f87da9d852a50ee4a0e04f46d2b","title":"多维数组","content":"数组的数组严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。谨记这一点，对今后理解和使用多维数组大有益处。当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另外一个维度表示其元素（也是数组）大小：\n12345678void multi_array()&#123;    //大小为3的数组，每个元素是含有4个整数的数组    int ia[3][4];    //大小为10的数组,他的每个元素都是大小为20的数组    //这些数组的元素是含有30个整数的数组    int arr[10][20][30] = &#123;0&#125;;&#125;\n\n多维数组初始化允许使用花括号括起来的一组值初始化多维数组，这点和普通的数组一样。下面的初始化形式中，多维数组的每一行分别用花括号括了起来：\n1234567891011121314void multi_init()&#123;    //三个元素，每个元素大小都是4的数组    int ia[3][4] = &#123;        &#123;0, 1, 2, 3&#125;,        &#123;4, 5, 6, 7&#125;,        &#123;8, 9, 10, 11&#125;&#125;;    //可以用一个花括号初始化二维数组    int ib[3][4] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11&#125;;    //显示初始化每行的首元素    int ic[3][4] = &#123;&#123;0&#125;, &#123;4&#125;, &#123;8&#125;&#125;;    //显示初始化第一行,其他元素被初始化为0    int id[3][4] = &#123;0, 3, 4, 6&#125;;&#125;\n\n下标访问可以使用下标运算符来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。\n12345678910int arr[3][3][3] = &#123;      0,      1,      2,  &#125;;  //用arr的首元素为ia最后一行的最后一个元素赋值  int ia[3][4] = &#123;0&#125;;  ia[2][3] = arr[0][0][0];  // row是一个ia第二个元素数组的引用，包含四个元素  int(&amp;row)[4] = ia[1];\n\n程序中经常会用到两层嵌套的for循环来处理多维数组的元素\n123456789101112   int ia[rowCnt][colCnt]=&#123;0&#125;;//遍历   constexpr size_t rowCnt = 3, colCnt = 4;   for (size_t i = 0; i != rowCnt; ++i)   &#123;       //对于行内的每一列       for (size_t j = 0; j != colCnt; ++j)       &#123;           //将元素的位置索引作为他的值           ia[i][j] = i * colCnt + j;       &#125;   &#125;\n\n可以使用范围 for语句处理多维数组,由于在C++11新标准中新增了范围for语句，所以前一个程序可以简化为如下形式：\n12345678size_t cnt = 0;   for (auto &amp;row : ia)   &#123;       for (auto &amp;col : row)       &#123;           col = cnt++;       &#125;   &#125;\n\n因为要改变数组元素的值，所以我们选用引用类型作为循环控制变量，但其实还有一个深层次的原因促使我们这么做。举一个例子，考虑如下的循环\n1234567for (auto &amp;row : ia)  &#123;      for (auto col : row)      &#123;          cout &lt;&lt; col &lt;&lt; endl;      &#125;  &#125;\n\n这个循环中并没有任何写操作，可是我们还是将外层循环的控制变量声明成了引用类型，这是为了避免数组被自动转成指针,假设不用引用类型，则循环如下述形式：\n1234567 for (auto row : ia)&#123;    for (auto col : row)    &#123;        cout &lt;&lt; col &lt;&lt; endl;    &#125;&#125;\n\n程序将无法通过编译。这是因为，像之前一样第一个循环遍历ia的所有元素，注意这些元素实际上是大小为4的数组。因为row不是引用类型，所以编译器初始化row时会自动将这些数组形式的元素（和其他类型的数组一样）转换成指向该数组内首元素的指针。这样得到的row的类型就是int＊，显然内层的循环就不合法了，编译器将试图在一个int＊内遍历，这显然和程序的初衷相去甚远。 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。\n指针和多维数组当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。 定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。 因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针：\n123456789void multi_pointer()&#123;    //大小为3的数组，每个元素是含有4个整数的数组    int ia[3][4];    // p指向含有4个整数的数组    int(*p)[4] = ia;    // p指向ia的尾元素    p = &amp;ia[2];&#125;\n\n我们首先明确（＊p）意味着p是一个指针。接着观察右边发现，指针p所指的是一个维度为4的数组；再观察左边知道，数组中的元素是整数。因此，p就是指向含有4个整数的数组的指针。 在上述声明中，圆括号必不可少：\n1234//整数指针的数组   int *ib[4];   //指向含有4个整数的数组   int(*ib)[4];\n\n随着C++11新标准的提出，通过使用auto或者decltype,就能尽可能地避免在数组前面加上一个指针类型了：\n12345678910// p指向一个含有4个整数的数组   for (auto p = ia; p != ia + 3; ++p)   &#123;       // q指向4个整数数组的首元素，也就是说q指向一个整数       for (auto q = *p; q != *p + 4; q++)       &#123;           cout &lt;&lt; *q &lt;&lt; &#x27; &#x27;;       &#125;       cout &lt;&lt; endl;   &#125;\n\n外层的for循环首先声明一个指针p并令其指向ia的第一个内层数组，然后依次迭代直到ia的全部3行都处理完为止。其中递增运算++p负责将指针p移动到ia的下一行。内层的for循环负责输出内层数组所包含的值。它首先令指针q指向p当前所在行的第一个元素。＊p是一个含有4个整数的数组，像往常一样，数组名被自动地转换成指向该数组首元素的指针。内层for循环不断迭代直到我们处理完了当前内层数组的所有元素为止。为了获取内层for循环的终止条件，再一次解引用p得到指向内层数组首元素的指针，给它加上4就得到了终止条件。 当然，使用标准库函数begin和end也能实现同样的功能，而且看起来更简洁一些：\n123456789101112// p指向ia的第一个数组   for (auto p = begin(ia); p != end(ia); p++)   &#123;       // q指向内层数组的首元素       for (auto q = begin(*p); q != end(*p); q++)       &#123;           //输出q所指的整数           cout &lt;&lt; *q &lt;&lt; &#x27; &#x27;;       &#125;       cout &lt;&lt; endl;   &#125;\n\n循环终止条件由end函数负责判断。虽然我们也能推断出p的类型是指向含有4个整数的数组的指针，q的类型是指向整数的指针，但是使用auto关键字我们就不必再烦心这些类型到底是什么了。\n类型别名简化多维数组的指针可以通过typedef和using等关键字定义类型\n12345678// C11新标准定义类型别名// int_array 是一个包含四个元素的整形数组类型using int_array = int[4];//等价的typedef声明// int_array_same 是一个包含四个元素的整形数组类型typedef int int_array_same[4];//如果不会用typedef定义数组类型，可以先定义一个数组变量int int_array_inst[4];\n\n如果不会用typedef定义数组类型，可以先定义一个数组变量\n1int int_array_inst[4];\n\n然后加上typedef即可\n1typedef int int_array_inst[4];\n\n此时int_array_inst就是一个大小为4的整形数组类型。 通过类型定义，我们重新实现遍历\n12345678910int ia[3][4];//输出ia中每个元素的值，每个内层数组各占一行for (int_array *p = ia; p != ia + 3; p++)&#123;    for (int *q = *p; q != *p + 4; q++)    &#123;        cout &lt;&lt; *q &lt;&lt; &#x27; &#x27;;    &#125;    cout &lt;&lt; endl;&#125;","slug":"多维数组","date":"2021-05-07T14:15:53.000Z","categories_index":"C++基础","tags_index":"C++,多维数组","author_index":"kiyose408"},{"id":"e16187d7a3c490f96b788338bdd79d24","title":"数组","content":"数组数组是一种类似于标准库类型vector的数据结构，但是在性能和灵活性的权衡上又与vector有所不同。与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与vector不同的地方是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。\n数组初始化初始化数组要指定大小，如果不指定维度系统会根据初始化列表自动设置数组大小，但是不要将数组数组的大小小于列表长度，否则编译器会报错。\n123456789101112131415161718192021222324252627282930void arrary_init()&#123;    //不是常量表达式    unsigned cnt = 42;    //常量表达式    constexpr unsigned sz = 42;    //常量表达式    const unsigned usz = 42;    //包含10个整数    int arr[10];    //含有42个整形指针的数组    int *parr[sz];    //含有42个string的数组    string strvec[usz];    //含有42个int的数组    string invec[get_size()];    // 编译报错,因为cnt不是常量表达式    // string bad[cnt];    const unsigned msz = 3;    //含有3个元素的数组，元素值分别为0,1,2    int ia1[msz] = &#123;0, 1, 2&#125;;    //维度是3的数组    int a2[] = &#123;0, 1, 2&#125;;    //等价于a3[] = &#123;0,1,2,0,0&#125;    int a3[5] = &#123;0, 1, 2&#125;;    //等价于a4[] = &#123;&quot;hi&quot;,&quot;bye&quot;,&quot;&quot;&#125;    string a4[3] = &#123;&quot;hi&quot;, &quot;bye&quot;&#125;;    //错误，初始值过多    // string a5[2] = &#123;0, 1, 2&#125;;&#125;\n\n错误操作不允许拷贝和赋值不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：\n123456//含有3个整数的数组 int a[] = &#123;0,1,2&#125;; //不允许用一个数组初始化另一个数组 int a2[] = a; //不能把一个数组直接赋值给另一个数组  a2 = a;\n\n复杂声明和vector一样，数组能存放大多数类型的对象。例如，可以定义一个存放指针的数组。又因为数组本身就是对象，所以允许定义数组的指针及数组的引用。在这几种情况中，定义存放指针的数组比较简单和直接，但是定义数组的指针或数组的引用就稍微复杂一点了：\n123456789101112void dif_array()&#123;    // ptrs是含有10个整形指针的数组    int *ptrs[10];    //不存在引用的数组    // int &amp;refs[10] = /*?*/;    int arr[10] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;    // 数组的引用 arrRef是arr的引用    int(&amp;arrRef)[10] = arr;    // Parray指向一个含有10个整数的数组    int(*Parray)[10] = &amp;arr;&#125;\n\n数组访问和vector一样，数组也支持下标访问和遍历访问\n123456789101112131415161718192021void visit_array()&#123;    //以10分为一个分数段统计成绩，0~9，10~19...，90~99,100    // 11 个分数段，全部初始化为0    unsigned scores[11] = &#123;&#125;;    unsigned grade;    while (cin &gt;&gt; grade)    &#123;        if (grade &lt;= 100)        &#123;            ++scores[grade / 10];        &#125;    &#125;    //通过for range 遍历打印    for (auto i : scores)    &#123;        cout &lt;&lt; i &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;\n\n指针和数组在C++语言中，指针和数组有非常紧密的联系。使用数组的时候编译器一般会把它转换成指针。 通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。 数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。 因此像其他对象一样，对数组的元素使用取地址符就能得到指向该元素的指针：\n1234//数组的元素是string元素 string nums[] = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;; // p指向nums的第一个元素 string *p = &amp;nums[0];\n\n在一些情况下数组的操作实际上是指针的操作，这一结论有很多隐含的意思。其中一层意思是当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组：\n123456// ia是一个含有10个整数的数组int ia[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;// ia2是一个整数型指针，指向ia第一个元素auto ia2(ia);//错误：ia2是一个指针，不能用int值给指针赋值// ia2 = 42;\n\n尽管ia是由10个整数构成的数组，但当使用ia作为初始值时，编译器实际执行的初始化过程类似于下面的形式：\n12ia2是int*类型auto ia2(&amp;ia[0]);\n\n必须指出的是，当使用decltype关键字时上述转换不会发生，decltype（ia）返回的类型是由10个整数构成的数组：\n1234567// ia3是一个含有10个整数的数组    decltype(ia) ia3 = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;    int *pint = nullptr;    //错误，不能用整形指针给数组赋值    // ia3 = pint;    //正确，可以对数组的元素赋值    ia3[4] = 1024;\n\n指针也是迭代器就像使用迭代器遍历vector对象中的元素一样，使用指针也能遍历数组中的元素。当然，这样做的前提是先得获取到指向数组第一个元素的指针和指向数组尾元素的下一位置的指针。之前已经介绍过，通过数组名字或者数组中首元素的地址都能得到指向首元素的指针；不过获取尾后指针就要用到数组的另外一个特殊性质了。\n123int arr[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;int *p = arr; // p指向arr的第一个元素++p;          // p指向arr[1]\n\n我们可以设法获取数组尾元素之后的那个并不存在的元素的地址：\n1int *e = &amp;arr[10]; //指向arr尾元素的下一个位置的指针\n\n这里显然使用下标运算符索引了一个不存在的元素，arr有10个元素，尾元素所在位置的索引是9，接下来那个不存在的元素唯一的用处就是提供其地址用于初始化e。就像尾后迭代器一样，尾后指针也不指向具体的元素。因此，不能对尾后指针执行解引用或递增的操作。 所以我们利用指针的末尾元素可以实现另一种方式的遍历\n12for (int *b = arr; b != e; ++b)       cout &lt;&lt; *b &lt;&lt; endl;\n\n数组也支持sizeof操作sizeof计算的是数组所占用的空间,除以sizeof(int)，得到的就是数组的长度，所以数组的遍历可以这样\n1234for (int i = 0; i &lt; sizeof(arr) / sizeof(int); i++)&#123;    cout &lt;&lt; arr[i] &lt;&lt; endl;&#125;\n\n标准库函数begin尽管能计算得到尾后指针，但这种用法极易出错。为了让指针的使用更简单、更安全，C++11新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数：\n123456789// beg指向arr第一个元素    int *beg = begin(arr);    // last指向arr最后一个元素的下一个位置    int *last = end(arr);    while (beg != last)    &#123;        cout &lt;&lt; *beg &lt;&lt; endl;        beg++;    &#125;\n\n通过begin和end函数获取数组第一个元素地址和最后一个元素的下一个位置，然后实现遍历，非常安全\n指针运算指向数组元素的指针包括解引用、递增、比较、与整数相加、两个指针相减等，用在指针和用在迭代器上意义完全一致。给（从）一个指针加上（减去）某整数值，结果仍是指针。新指针指向的元素与原来的指针相比前进了（后退了）该整数值个位置：\n12345int arr[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;//等价于int *p = &amp;arr[0]int *ip = arr;//等价于ip2指向arr的第四个元素int *ip2 = ip + 4;\n\n另外一种计算数组元素个数的方式\n123456   int arr[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;// beg指向arr第一个元素   int *beg = begin(arr);   // last指向arr最后一个元素的下一个位置   int *last = end(arr);   int length = last - beg;\n\nC风格字符串C风格字符串被C++包含在cstring头文件里,包括strcmp字符串比较，strcpy字符串copy，strcat字符串连接 比较字符串\n12345678910const char cal1[] = &quot;A string example&quot;;const char cal2[] = &quot;A different string&quot;;if (strcmp(cal1, cal2) &lt; 0)&#123;    cout &lt;&lt; &quot;cal1 is less than cal2&quot; &lt;&lt; endl;&#125;else&#123;    cout &lt;&lt; &quot;cal2 is less than cal1&quot; &lt;&lt; endl;&#125;\n\n字符串连接 字符串的连接用到了memset清空操作，以及strcpy, strcat等操作，大家看看就好不用深入理解，这是C语言的方式\n12345678910111213141516171819202122232425262728293031void c_string()&#123;    const char cal1[] = &quot;A string example&quot;;    const char cal2[] = &quot;A different string&quot;;    if (strcmp(cal1, cal2) &lt; 0)    &#123;        cout &lt;&lt; &quot;cal1 is less than cal2&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;cal2 is less than cal1&quot; &lt;&lt; endl;    &#125;    const int total_len = strlen(cal1) + strlen(cal2) + 1;    //开辟total_len字节的空间    char *total_str = new char(total_len);    //将空间清空为0    memset(total_str, 0, total_len);    //将cal1 copy 到 total_str    strcpy(total_str, cal1);    //将total_str和cal2连接    strcat(total_str, cal2);    //输出total_str 的值    cout &lt;&lt; &quot;total_str is &quot; &lt;&lt; total_str &lt;&lt; endl;    //最后释放内存    if (total_str != nullptr)    &#123;        delete total_str;        total_str = nullptr;    &#125;&#125;\n\n习惯使用C语言的同学可以通过c_str()函数将string转化为const char*类型的字符串\n12string strcpp = &quot;CPP&quot;;const char *strc = strcpp.c_str();\n\n使用数组初始化vector对象vector除了可以通过初始化列表，指定初始值和大小等方式外，还可以通过数组和vector初始化 通过vector初始化\n123456vector&lt;int&gt; v1 = &#123;1, 3, 5, 7, 9&#125;;vector&lt;int&gt; v2(v1);for (auto v : v2)&#123;    cout &lt;&lt; v &lt;&lt; endl;&#125;\n\n通过数组初始化\n12345678910void vector_init2()&#123;    int a[] = &#123;2, 4, 6, 8, 10&#125;;    vector&lt;int&gt; v3(begin(a), end(a));    for (auto v : v3)    &#123;        cout &lt;&lt; v &lt;&lt; endl;    &#125;&#125;","slug":"数组","date":"2021-05-06T04:00:58.000Z","categories_index":"C++基础","tags_index":"C++,数组","author_index":"kiyose408"},{"id":"5391af7718199d3c4ba5b2fd9250437c","title":"迭代器","content":"迭代器当我们要遍历容器如vector,map等复杂结构时，可以通过迭代器进行遍历，依次取出容器中的值。通过容器类的begin()和end()函数获取指向第一个元素位置的迭代器和指向最后一个元素下一个位置的迭代器。 迭代器初步使用\n123456789void iterator_func()&#123;    string s(&quot;some string&quot;);    if (s.begin() != s.end())    &#123;        auto it = s.begin();        *it = toupper(*it);    &#125;&#125;\n\n上面代码修改了字符串第一个字母为大写。只有当字符串为空时s.begin()==s.end()\n迭代器运算迭代器支持加减运算，支持比较运算\n123456789*iter 返回iter所指对象得引用iter-&gt;mem 解引用返回iter所指对象得mem成员++iter 迭代器位置后移，指向下一个元素--iter 迭代器位置前移，指向上一个元素iter1 == iter2 判断iter1和iter2是否相等iter1 != iter2 判断iter1和iter2不相等iter = iter + n 迭代器iter向后偏移n个元素iter = iter -n 迭代器iter 向前偏移n个元素iter1 &gt;= iter2 迭代器iter1指向的元素是否在iter2之后\n\n迭代器遍历通过迭代器修改第一个单词为大写，遇到空格或者字符串末尾结束\n1234567string s(&quot;some string&quot;);for (auto iter = s.begin(); iter != s.end() &amp;&amp; !isspace(*iter); iter++)&#123;    *iter = toupper(*iter);&#125;cout &lt;&lt; &quot;str is &quot; &lt;&lt; s &lt;&lt; endl;\n\n通过iter++依次访问s中得每个字符，*iter返回的是每个字符的引用\n泛型编程关键概念：泛型编程原来使用C或Java的程序员在转而使用C++语言之后，会对for循环中使用！&#x3D;而非&lt;进行判断有点儿奇怪，。C++程序员习惯性地使用！&#x3D;，其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标准库提供的所有容器上都有效。之前已经说过，只有string和vector等一些标准库类型有下标运算符，而并非全都如此。与之类似，所有标准库容器的迭代器都定义了==和！&#x3D;，但是它们中的大多数都没有定义&lt;运算符。因此，只要我们养成使用迭代器和！&#x3D;的习惯，就不用太在意用的到底是哪种容器类型。\n迭代器类型那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型：const_iterator和常量指针差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。如果vector对象或string对象是一个常量，只能使用const_iterator；如果vector对象或string对象不是常量，那么既能使用iterator也能使用const_iterator。\n123456789101112131415161718// it能读写vector&lt;int&gt;的元素  vector&lt;int&gt;::iterator it;  // it2能读写string对象中的字符  vector&lt;string&gt;::iterator it2;  // it3 只能读元素,不能写元素  vector&lt;int&gt;::const_iterator it3;  // it4 只能读字符，不能写字符  vector&lt;string&gt;::const_iterator it4;  vector&lt;int&gt; v;  const vector&lt;int&gt; cv;  // vit1的类型是vector&lt;int&gt;::iterator  auto vit1 = v.begin();  // vit2的类型是vector&lt;int&gt;::const_iterator  auto vit2 = cv.begin();  //通过cbegin和cend可以获取常量迭代器  // cvit 类型为vector&lt;int&gt;::const_iterator  auto cvit = v.cbegin();\n\n解引用迭代器解引用要注意将*和迭代器括起来，因为*的优先级比.低，假设iter是vector&lt;string&gt;::iterator类型 判断迭代器所指向的字符串是否为空应该用(*iter).empty() 如果用*iter.empty()会被编译器理解为对迭代器先进行empty()函数运算再解引用，会报错，因为迭代器没有empty()操作 为了方便可以通过-&gt;解引用取出元素的成员或者成员函数，如下我们通过遍历，直到遇到空字符串就退出遍历\n12345678vector&lt;string&gt; text = &#123;&quot;zack&quot;,                       &quot;vivo&quot;,                       &quot;&quot;,                       &quot;lisus&quot;&#125;;for (auto it = text.begin(); it != text.end() &amp;&amp; !it-&gt;empty(); ++it)&#123;    cout &lt;&lt; *it &lt;&lt; endl;&#125;\n\n迭代器失效在通过迭代器遍历vector,string ,map等容器时，如果遍历的循环中添加元素或者删除元素会导致迭代器失效，因为添加元素或者删除元素会影响迭代器的值，可以通过如下方式在遍历的同时删除元素\n12345678910auto itdel = text.begin();while (itdel != text.end())&#123;    if (itdel-&gt;empty())    &#123;        itdel = text.erase(itdel);        continue;    &#125;    itdel++;&#125;\n\ntext.erase(itdel)返回的时下一个元素的迭代器，所以直接跳出本次循环继续遍历即可。\n二分查找迭代器可以做加减操作，所以我们用迭代器实现一个二分查找, orderv是一个vector,里面的数字是有序的，我们查找9\n1234567891011121314151617181920212223242526272829303132333435363738vector&lt;int&gt; orderv = &#123;1,                      2,                      3,                      5,                      6,                      8,                      9,                      10&#125;;bool bfind = false;auto findit = orderv.begin();auto beginit = orderv.begin();auto endit = orderv.end();while (beginit != endit)&#123;    auto midit = beginit + (endit - beginit) / 2;    if (*midit == 9)    &#123;        findit = midit;        bfind = true;        break;    &#125;    if (*midit &gt; 9)    &#123;        endit = midit - 1;    &#125;    if (*midit &lt; 9)    &#123;        beginit = midit + 1;    &#125;&#125;if (bfind)&#123;    cout &lt;&lt; &quot;find success, iter val is &quot; &lt;&lt; *findit &lt;&lt; endl;&#125;","slug":"迭代器","date":"2021-05-04T18:15:50.000Z","categories_index":"C++基础","tags_index":"C++,迭代器","author_index":"kiyose408"},{"id":"bfb8c7eb75a20258cca7b53c5617a35a","title":"Vector","content":"简介本文介绍vector的使用方法，vector是一种高效访问和修改的容器，支持遍历，索引访问。\n初始化1 用花括号进行列表初始化 2 可以用()指定初始值和个数初始化\n123456789101112131415void vector_init()&#123;    //列表初始化    vector&lt;string&gt; v1&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;    //错误用法    // vector&lt;string&gt; v2(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);    //初始化vector大小为10，每个元素为-1    vector&lt;int&gt; ivec(10, -1);    // 10个string类型的元素,每个都是hi    vector&lt;string&gt; svec(10, &quot;hi!&quot;);    // 10个元素，每个都初始化为0    vector&lt;int&gt; ivec2(10);    // 10个元素，每个都初始化为空string    vector&lt;string&gt; svec2(10);&#125;\n\n添加元素123456//利用push_back将元素添加到vector末尾vector&lt;int&gt; v2;for (int i = 0; i != 100; ++i)&#123;    v2.push_back(i);&#125;\n\n遍历访问1234567891011 // 求vector 每个元素平方值vector&lt;int&gt; v3&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;for (auto &amp;i : v3)&#123;    i *= i;&#125;for (auto i : v3)&#123;    cout &lt;&lt; i &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; endl;\n\n下标访问123456789101112//索引访问// 11个分数段，全部初始化为0vector&lt;unsigned&gt; scores(11, 0);unsigned grade;//读取成绩while (cin &gt;&gt; grade)&#123;    //只处理有效成绩，小于等于100的成绩    if (grade &lt;= 100)    //对应的分数段+1，修改索引对应的元素值        ++scores[grade / 10];&#125;","slug":"vector类","date":"2021-05-04T02:15:20.000Z","categories_index":"C++基础","tags_index":"C++,Vector","author_index":"kiyose408"},{"id":"d7215eab570338175fadc0dc91188274","title":"String类","content":"简介今天介绍string类的使用\n初始化和定义123456789//默认初始化,s1是一个空字符串string s1;//赋值初始化,s2是s1的副本string s2 = s1;//直接初始化 字面值初始化string s3 = &quot;hiya&quot;;//直接初始化 构造函数初始化string s4(10, &#x27;c&#x27;);string s5(&quot;hello zack&quot;);\n\nstring操作12345678910111213141516171819202122232425262728293031323334353637383940414243void opstr_func()&#123;    //定义空字符串    string s;    //从输入流写入s    cin &gt;&gt; s;    //将s写入输出流    cout &lt;&lt; s &lt;&lt; endl;    //循环读取，直到遇到换行符或者非法输入    string world;    while (cin &gt;&gt; world)        cout &lt;&lt; world &lt;&lt; endl;    //读取一整行    string linestr;    while (getline(cin, linestr))    &#123;        cout &lt;&lt; linestr &lt;&lt; endl;    &#125;    //每次读入一整行，遇到空行跳过    while (getline(cin, linestr))    &#123;        if (!linestr.empty())        &#123;            cout &lt;&lt; linestr &lt;&lt; endl;            //打印字符串长度            cout &lt;&lt; linestr.size() &lt;&lt; endl;            // size()返回string::size_type类型的数据            string::size_type size = linestr.size();        &#125;    &#125;    // 比较    string str1 = &quot;Hello&quot;;    string str2 = &quot;Hello W&quot;;    string str3 = &quot;Za&quot;;    //依次比较每个字符，字符大的字符串就大    auto b2 = str3 &gt; str1;    cout &lt;&lt; b2 &lt;&lt; endl;    //前面字符相同，长度长的字符串大    auto b = str2 &gt; str1;    cout &lt;&lt; b &lt;&lt; endl;&#125;\n\nstring 类重载了 比较运算符，也重载了+运算符等,所以string支持+运算\n123456// string类对象相加string s1 = &quot;Hello&quot;, s2 = &quot;Zack&quot;;string s3 = s1 + &quot;,&quot; + s2 + &#x27;\\n&#x27;;cout &lt;&lt; s3 &lt;&lt; endl;//加号两侧至少有一个是string类型，否则报错// string s4 = &quot;Hello&quot; + &quot;Zack&quot;;\n\n对C语言的兼容建议：使用C++版本的C标准库头文件 C++标准库中除了定义C++语言特有的功能外，也兼容了C语言的标准库。C语言的头文件形如name.h，C++则将这些文件命名为cname。也就是去掉了.h后缀，而在文件名name之前添加了字母c，这里的c表示这是一个属于C语言标准库的头文件。因此，cctype头文件和ctype.h头文件的内容是一样的，只不过从命名规范上来讲更符合C++语言的要求。特别的，在名为cname的头文件中定义的名字从属于命名空间std，而定义在名为.h的头文件中的则不然。一般来说，C++程序应该使用名为cname的头文件而不使用name.h的形式，标准库中的名字总能在命名空间std中找到。如果使用.h形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些又是C++语言所独有的。\nC11用法如果想对string对象中的每个字符做点儿什么操作，目前最好的办法是使用C++11新标准提供的一种语句：范围for（rangefor）语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作，其语法形式是：\n12for(declaration:expression)    statement\n\n其中，expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。一个string对象表示一个字符的序列，因此string对象可以作为范围for语句中的expression部分。举一个简单的例子，我们可以使用范围for语句把string对象中的字符每行一个输出出来：\n123456string str(&quot;hello zack&quot;);    //遍历输出str中的每个字符for (auto c : str)&#123;    cout &lt;&lt; c &lt;&lt; endl;&#125;\n\n统计字符串中标点符号的数量\n1234567891011string s(&quot;Hello World!!!&quot;);decltype(s.size()) punct_cnt = 0;//统计s中标点符号的数量for (auto c : s)&#123;    if (ispunct(c))        punct_cnt++;&#125;cout &lt;&lt; punct_cnt     &lt;&lt; &quot; punctuation characters in &quot;    &lt;&lt; s &lt;&lt; endl;\n\n将字符串变为大写\n12345678//将字符串变为大写string s3(&quot;Hello Vivo&quot;);for (auto &amp;c : s3)&#123;    //通过引用string中的字符，然后修改字符    c = toupper(c);&#125;cout &lt;&lt; s &lt;&lt; endl;\n\n将第一个单词变为大写\n1234567//通过下标索引修改字符串//把第一个单词变为大写string sind(&quot;some string&quot;);for (decltype(sind.size()) index = 0; index != sind.size() &amp;&amp; isspace(sind[index]); ++index)&#123;    sind[index] = toupper(sind[index]);&#125;","slug":"C++的string类","date":"2021-05-03T04:15:58.000Z","categories_index":"C++基础","tags_index":"C++,String类","author_index":"kiyose408"},{"id":"9a1c9eab819449bb12fa84a4154b8457","title":"C++的输入和输出.","content":"iostreamC++提供了标准的输入输出流功能，需要包含iostream头文件，之后就可以使用cin进行输入，cout进行输出。\n1234567891011#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void cin_func()&#123;    string input;    cout &lt;&lt; &quot;input your words &quot; &lt;&lt; endl;    cin &gt;&gt; input;    cout &lt;&lt; &quot;your input is &quot; &lt;&lt; endl;    cout &lt;&lt; input &lt;&lt; endl;&#125;\n程序输出：\n1234input your wordszackyour input iszack\n&gt;&gt;  会获取输入来写入缓存，并返回cin对象，&lt;&lt;  会从缓存中读取数据，写入cout并返回cout，最后endl会将cout缓存中的数据输出到终端。\n变量12345678910111213141516171819void var_func()&#123;    //整形，4字节    int a = 100;    //ll整形, 8字节    long long lla = 1000;    //长整型， 4 字节    long la = 1024;    //短整型,2 字节    short sa = 200;    //带符号字符型,    //字符型使用时最好指示带符号还是不带符号    //因为在不同的机器上不指明char符号可能会有问题    signed char sc = &#x27;a&#x27;;    //无符号字符型    unsigned char uc = &#x27;m&#x27;;    //bool类型    bool bt = true;&#125;\n\n类型转换当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true。 当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。 当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。 当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8比特大小的unsigned char所得的结果是255。 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。\n12345bool b = 42; //b为trueint i = b; //i 为1i = 3.14; //i 为3double pi = i; //pi为3.0unsigned char c = -1; //\n\n变量的声明和定义用extern在头文件声明，在CPP源文件中定义，可以保证变量不会被重复包含。\n12//只声明aextern int a;\n如果extern后面做了赋值操作，则不是声明而是定义。\n12extern int a= 100;\n不带extern直接类型+变量名就是定义。\n123//如下都是定义int age = 100;int num ;\n\n引用引用就是变量的别名，通过修改引用达到修改变量的值的目的。\n12345int j = 20;// i 是j的引用int &amp;i = j;j = 200;cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;\n\n指针指针值指针的值（即地址）应属下列4种状态之一： 1.指向一个对象。 2.指向紧邻对象所占空间的下一个位置。 3.空指针，意味着指针没有指向任何对象。 4.无效指针，也就是上述情况之外的其他值。\n12345678//通过对指针的值做解引用(*)，拿到其指向的值，再修改这个值，达到修改指向对象数据的目的void piont_func()&#123;    int age = 18;    int *page = &amp;age;    *page += 2;    cout &lt;&lt; age &lt;&lt; &quot; &quot; &lt;&lt; page &lt;&lt; endl;&#125;\n\n指向指针的引用12345678910111213void poinref_func()&#123;    int i = 42;    // p是一个指针    int *p;    // r 是一个对p的引用    int *&amp;r = p;    // 令r指向了一个指针p    //给r赋值为&amp;i,就是p指向了i    r = &amp;i;    //解引用r得到i,也就是p指向的对象，将i的值修改为0    *r = 0;&#125;\n\n常量12345678910111213141516171819202122232425262728293031void const_func()&#123;    // 常量定义一定要初始化赋值，否则编译报错    const int bufSize = 512;    //修改bufSize的值会报错    //编译器提示表达式必须是可修改的左值    // bufSize = 222;    //运行时初始化    const int i = get_size();    //编译时初始化    const int j = 43;    //如果定义const变量不初始化也会报错    // const int k;    //利用一个常量初始化另一个常量    const int cj = j;    // const引用,引用及其对应的对象都是const    const int &amp;r1 = cj;    //不可以修改r1的值    // r1 = 42;    //不可以用非常量引用指向一个常量对象    // int &amp;r2 = ci;    int iv = 42;    //允许将const int&amp;绑定到一个普通int对象上    const int &amp;r1 = iv;    //正确, r2是一个常量引用    const int &amp;r2 = 42;    //正确, r3是一个常量引用    const int &amp;r3 = r1 * 2;    //错误, r4 是一个普通非常量的引用    // int &amp;r4 = r1 * 2;&#125;\n\n指向常量的指针指向常量的指针不可以通过指针修改指向内容的数据\n1234567891011121314void pconst_func()&#123;    //指向常量的指针    const double pi = 3.14;    //不可以用普通指针指向常量    // double *ptr = &amp;pi;    //用常量指针指向常量    const double *cptr = &amp;pi;    //不能给*cptr赋值因为cptr指向的是常量    // *cptr = 42;    //指向常量的指针指向非常量    double dval = 3.14;    cptr = &amp;dval;&#125;\n\n常量指针指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。 常量指针（const pointer）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。 把＊放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值\n123456789101112//常量指针//常量指针的值初始化后就不允许修改int errNumb = 0;// curErr将一直指向errNumbint *const curErr = &amp;errNumb;//不允许修改curErr的指向int rightNumb = 1;//编译报错，提示=左侧必须为可修改的左值// curErr = &amp;rightNumb;const double pi = 3.14159;// pip是一个指向常量对象的常量指针const double *const pip = &amp;pi;\n\n顶层const指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词顶层const（top-levelconst）表示指针本身是个常量，而用名词底层const（low-level const）表示指针所指的对象是一个常量。顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const。\nconstexper变量在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。当然可以定义一个const变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。可以这么说，在此种情况下，对象的定义和使用根本就是两回事儿\nC++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：\n123456789void constexpr_func()&#123;    // 20是一个常量表达式    constexpr int mf = 20;    // mf + 1是一个常量表达式    constexpr int limit = mf + 1;    // size是一个constexpr函数    constexpr int sizen = size();&#125;\n\n尽管不能使用普通函数作为constexpr变量的初始值，新标准允许定义一种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。\n常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”（literal type）。到目前为止接触过的数据类型中，算术类型、引用和指针都属于字面值类型。 尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。\n指针和constexpr在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。\n1234567void pointer_constexpr()&#123;    // p是一个指向整形常量的指针,p可以修改，但是*P不可修改    const int *p = nullptr;    // q是一个指向整形变量的常量指针,q不可修改,但是*q可以修改    constexpr int *q = nullptr;&#125;\np和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在于constexpr把它所定义的对象置为顶层const。与其他常量指针类似，constexpr 指针既可以指向常量也可以指向一个非常量：\n12345678910111213141516171819int j = 0;// i 的类型是整型常量constexpr int i = 42;void pointer_constexpr()&#123;    // p是一个指向整形常量的指针,p可以修改，但是*P不可修改    const int *p = nullptr;    // q是一个指向整形变量的常量指针,q不可修改,但是*q可以修改    constexpr int *q = nullptr;    // np是一个指向整数的常量指针，其中为空    constexpr int *np = nullptr;    // i和j必须定义在函数体之外，否则报错，提示p访问运行时存储    //因为constexpr要求表达式为常量，在编译时展开    //  p是常量指针，指向整形常量i    constexpr const int *p2 = &amp;i;    // p1是常量指针，指向整数j    constexpr int *p1 = &amp;j;&#125;\n\n类型别名类型别名(type alias)是一个名字，他是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚的知道使用该类型的真实目的。有两种方法可用于定义类型别名。传统的方法是使用关键字typedef: 1 typedef\n12345678910void typedef_func()&#123;    // wages是double的同义词    typedef double wages;    // base是double的同义词， p 是double*的同义词    typedef wages base, *p;    // C11用法    using newd = double;    newd dd = 3.14;&#125;\n新标准规定了一种新的方法，使用别名声明（aliasdeclaration）来定义类型的别名，using newd &#x3D; 都变了就是通过using定义new类型和double是相同的。\n如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型pstring，它实际上是char *的别名。\n12345678910111213141516void typedef_func()&#123;    typedef char *pstring;    // pstring是一个指向char的常量指针    const pstring cstr = 0;    // ps 是一个指针，其对象是指向char的常量指针    const pstring *ps;    char b = &#x27;H&#x27;;    //不可修改    // cstr = &amp;b;    ps = &amp;cstr;    const pstring cstr2 = &amp;b;    ps = &amp;cstr2;    //不可修改*ps的值    // *ps = cstr;&#125;\n\nauto 推导编程时常常需要把表达式的值付给变量，这就要求在声明变量的时候清楚地知道表达式的类型。为了做到这一点在C++11新标准中引入了auto类型说明符，用它就能让编译器去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如double）不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值，使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样。\n123456789101112131415161718192021void auto_func()&#123;    int a = 100;    int b = 1024;    // c被推导为int类型    auto c = a + b;    auto i = 0, *p = &amp;i;    //一条声明语句只能有一个基本数据类型    //不同类型编译器会报错    // auto sz = 0, pi = 3.14;    const int ma = 1;    // auto会忽略顶层const    //可以通过const明确指出，此时f为const int类型    const auto f = ma;    // auto配合引用类型    auto &amp;g = a;    // 不能为非常量引用绑定字面值    // auto &amp;h = 42;    //指明const 引用绑定字面值    const auto &amp;j = 42;&#125;\n\nauto一般会忽略掉顶层const，同时底层const则会保留下来 要在一条语句中定义多个变量，切记，符号&amp;和＊只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型：\n12345678// k是int类型，l是int的引用// auto 忽略了顶层constauto k = ci, &amp;l = i;// m是int常量的引用，p是指向int常量的指针// auto保留了底层constauto &amp;m = ci, *p = &amp;ci;// 错误 i的类型是int， ci的类型是 const int// auto &amp;n = i, *p2 = &amp;ci;\n\ndecltype类型指示符有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：\n1decltype(size()) sum;\n\n编译器并不实际调用函数size，而是使用当调用发生时size的返回值类型作为sum的类型。换句话说，编译器为sum指定的类型是什么呢？就是假如size被调用的话将会返回的那个类型。decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：\n1234567891011void decltype_func()&#123;    decltype(size()) sum;    const int ci = 0, &amp;cj = ci;    // x的类型是const int    decltype(ci) x = 0;    // y的类型是 const int&amp; , y绑定到变量x    decltype(cj) y = x;    //错误，z是一个引用，必须初始化    // decltype(cj) z;&#125;\n\n因为cj是一个引用，decltype（cj）的结果就是引用类型，因此作为引用的z必须被初始化。需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型.\n1234567int i = 42, *p = &amp;i, &amp;r = i;// b1 是一个int类型的引用decltype(r) b1 = i;// r+0 通过decltype返回int类型decltype(r + 0) b2;//错误，必须初始化,c是int&amp;类型// decltype(*p) c;","slug":"C++的输入和输出","date":"2021-05-01T18:15:58.000Z","categories_index":"C++基础","tags_index":"C++,iostream,变量和常量","author_index":"kiyose408"}]