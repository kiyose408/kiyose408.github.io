[{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"使用Hexo快速搭建个人笔记网站的步骤相对直接，下面是简化的流程指导：\n准备工作\n安装Node.js: Hexo是基于Node.js的，首先确保你的计算机上安装了Node.js。访问 Node.js官方网站 下载并安装最新稳定版。\n\n安装Git: 如果你还没有Git，也需要安装它，因为后续会用到Git来部署网站到GitHub等平台。访问 Git官方网站 下载安装。\n\n\n安装Hexo\n打开命令行工具（Windows下是CMD或PowerShell，Mac&#x2F;Linux下是Terminal）。\n\n运行以下命令安装Hexo：:::tipnpm install -g hexo-cli:::\n\n\n创建Hexo项目\n在你想要存放博客文件的目录下，打开命令行工具，运行以下命令初始化Hexo项目：\n1hexo init your-blog-name\nyour-blog-name 是你给博客起的名字，这个命令会在这个目录下创建一个基本的Hexo项目结构。\n\n初始化完成后，进入项目目录：\n1cd your-blog-name\n\n安装项目依赖：\n1npm install\n\n启动本地服务器预览\n运行以下命令启动本地服务器：1hexo server\n访问 http://localhost:4000 查看你的博客。\n\n编写笔记（博客文章）\n使用Markdown编写笔记，文件通常放在source/_posts目录下。可以通过命令创建新文章：1hexo new &quot;我的第一篇笔记&quot;\n\n部署到GitHub Pages\n登录GitHub，创建一个新的仓库，比如命名为your-github-username.github.io。\n\n回到本地Hexo项目，编辑 _config.yml 文件，配置部署部分，添加如下内容：\n1234deploy:  type: git  repo: https://github.com/your-github-username/your-github-username.github.io.git  branch: main # 或者 master，取决于你的GitHub Pages设置\n\n安装部署工具（如果你还没有安装的话）：\n1npm install hexo-deployer-git --save\n\n最后，运行命令部署到GitHub：\n1hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy\n\n完成上述步骤后，你的笔记网站就会被部署到GitHub Pages，可以通过 https://your-github-username.github.io 访问。\n记得替换上述命令中的your-blog-name、your-github-username等占位符为实际的名称。此外，你可以通过更换Hexo主题来个性化你的网站外观，主题可以从Hexo的官方主题库或GitHub上找到。\n博客的更新在Hexo中，当你对博客的文件进行了更新或修改后，需要经过以下几个步骤来更新部署你的博客：\n\n生成静态文件：打开终端（Command Prompt、PowerShell、Terminal或Git Bash等），导航到你的Hexo项目根目录，然后运行以下命令来生成新的静态文件：\n1hexo clean &amp;&amp; hexo generate\n或简写为：\n1hexo g\nhexo clean 命令会先清除之前生成的静态文件，确保部署的是最新的内容。hexo generate 或 hexo g 则会根据你的Markdown文件和配置生成新的静态文件。\n\n部署到远程服务器：接下来，你需要将生成的静态文件部署到你的远程服务器或GitHub Pages、GitLab Pages等托管服务上。执行以下命令进行部署：\n1hexo deploy\n或简写为：\n1hexo d\n首次使用hexo deploy前，你可能需要在 _config.yml 文件中配置部署信息，例如如果你使用GitHub Pages，可能需要如下配置：\n1234deploy:  type: git  repo: https://github.com/your_username/your_repo.git  branch: main # 或者 gh-pages，取决于你的设置\n确保你已经正确设置了SSH密钥，并且你的GitHub或其他托管服务账户已授权。\n\n\n如果你之前已经配置了自动部署或者有特定的部署脚本（比如通过deploy.sh），则只需执行部署命令，Hexo会自动处理文件的生成和推送。\n完成以上步骤后，你的博客就应该更新为最新的内容了。记得检查你的部署日志输出，确认部署过程中没有错误发生。\n","slug":"Hexo搭建博客","date":"2024-05-16T15:15:58.000Z","categories_index":"","tags_index":"","author_index":"kiyose408"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"iostreamC++提供了标准的输入输出流功能，需要包含iostream头文件，之后就可以使用cin进行输入，cout进行输出。\n1234567891011#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void cin_func()&#123;    string input;    cout &lt;&lt; &quot;input your words &quot; &lt;&lt; endl;    cin &gt;&gt; input;    cout &lt;&lt; &quot;your input is &quot; &lt;&lt; endl;    cout &lt;&lt; input &lt;&lt; endl;&#125;\n程序输出：\n1234input your wordszackyour input iszack\n&gt;&gt;  会获取输入来写入缓存，并返回cin对象，&lt;&lt;  会从缓存中读取数据，写入cout并返回cout，最后endl会将cout缓存中的数据输出到终端。\n变量12345678910111213141516171819void var_func()&#123;    //整形，4字节    int a = 100;    //ll整形, 8字节    long long lla = 1000;    //长整型， 4 字节    long la = 1024;    //短整型,2 字节    short sa = 200;    //带符号字符型,    //字符型使用时最好指示带符号还是不带符号    //因为在不同的机器上不指明char符号可能会有问题    signed char sc = &#x27;a&#x27;;    //无符号字符型    unsigned char uc = &#x27;m&#x27;;    //bool类型    bool bt = true;&#125;\n\n类型转换当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true。 当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。 当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。 当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8比特大小的unsigned char所得的结果是255。 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。\n12345bool b = 42; //b为trueint i = b; //i 为1i = 3.14; //i 为3double pi = i; //pi为3.0unsigned char c = -1; //\n\n变量的声明和定义用extern在头文件声明，在CPP源文件中定义，可以保证变量不会被重复包含。\n12//只声明aextern int a;\n如果extern后面做了赋值操作，则不是声明而是定义。\n12extern int a= 100;\n不带extern直接类型+变量名就是定义。\n123//如下都是定义int age = 100;int num ;\n\n引用引用就是变量的别名，通过修改引用达到修改变量的值的目的。\n12345int j = 20;// i 是j的引用int &amp;i = j;j = 200;cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;\n\n指针指针值指针的值（即地址）应属下列4种状态之一： 1.指向一个对象。 2.指向紧邻对象所占空间的下一个位置。 3.空指针，意味着指针没有指向任何对象。 4.无效指针，也就是上述情况之外的其他值。\n12345678//通过对指针的值做解引用(*)，拿到其指向的值，再修改这个值，达到修改指向对象数据的目的void piont_func()&#123;    int age = 18;    int *page = &amp;age;    *page += 2;    cout &lt;&lt; age &lt;&lt; &quot; &quot; &lt;&lt; page &lt;&lt; endl;&#125;\n\n指向指针的引用12345678910111213void poinref_func()&#123;    int i = 42;    // p是一个指针    int *p;    // r 是一个对p的引用    int *&amp;r = p;    // 令r指向了一个指针p    //给r赋值为&amp;i,就是p指向了i    r = &amp;i;    //解引用r得到i,也就是p指向的对象，将i的值修改为0    *r = 0;&#125;\n\n常量12345678910111213141516171819202122232425262728293031void const_func()&#123;    // 常量定义一定要初始化赋值，否则编译报错    const int bufSize = 512;    //修改bufSize的值会报错    //编译器提示表达式必须是可修改的左值    // bufSize = 222;    //运行时初始化    const int i = get_size();    //编译时初始化    const int j = 43;    //如果定义const变量不初始化也会报错    // const int k;    //利用一个常量初始化另一个常量    const int cj = j;    // const引用,引用及其对应的对象都是const    const int &amp;r1 = cj;    //不可以修改r1的值    // r1 = 42;    //不可以用非常量引用指向一个常量对象    // int &amp;r2 = ci;    int iv = 42;    //允许将const int&amp;绑定到一个普通int对象上    const int &amp;r1 = iv;    //正确, r2是一个常量引用    const int &amp;r2 = 42;    //正确, r3是一个常量引用    const int &amp;r3 = r1 * 2;    //错误, r4 是一个普通非常量的引用    // int &amp;r4 = r1 * 2;&#125;\n\n指向常量的指针指向常量的指针不可以通过指针修改指向内容的数据\n1234567891011121314void pconst_func()&#123;    //指向常量的指针    const double pi = 3.14;    //不可以用普通指针指向常量    // double *ptr = &amp;pi;    //用常量指针指向常量    const double *cptr = &amp;pi;    //不能给*cptr赋值因为cptr指向的是常量    // *cptr = 42;    //指向常量的指针指向非常量    double dval = 3.14;    cptr = &amp;dval;&#125;\n\n常量指针指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。 常量指针（const pointer）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。 把＊放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值\n123456789101112//常量指针//常量指针的值初始化后就不允许修改int errNumb = 0;// curErr将一直指向errNumbint *const curErr = &amp;errNumb;//不允许修改curErr的指向int rightNumb = 1;//编译报错，提示=左侧必须为可修改的左值// curErr = &amp;rightNumb;const double pi = 3.14159;// pip是一个指向常量对象的常量指针const double *const pip = &amp;pi;\n\n顶层const指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词顶层const（top-levelconst）表示指针本身是个常量，而用名词底层const（low-level const）表示指针所指的对象是一个常量。顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const。\nconstexper变量在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。当然可以定义一个const变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。可以这么说，在此种情况下，对象的定义和使用根本就是两回事儿\nC++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：\n123456789void constexpr_func()&#123;    // 20是一个常量表达式    constexpr int mf = 20;    // mf + 1是一个常量表达式    constexpr int limit = mf + 1;    // size是一个constexpr函数    constexpr int sizen = size();&#125;\n\n尽管不能使用普通函数作为constexpr变量的初始值，新标准允许定义一种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。\n常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”（literal type）。到目前为止接触过的数据类型中，算术类型、引用和指针都属于字面值类型。 尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。\n指针和constexpr在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。\n1234567void pointer_constexpr()&#123;    // p是一个指向整形常量的指针,p可以修改，但是*P不可修改    const int *p = nullptr;    // q是一个指向整形变量的常量指针,q不可修改,但是*q可以修改    constexpr int *q = nullptr;&#125;\np和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在于constexpr把它所定义的对象置为顶层const。与其他常量指针类似，constexpr 指针既可以指向常量也可以指向一个非常量：\n12345678910111213141516171819int j = 0;// i 的类型是整型常量constexpr int i = 42;void pointer_constexpr()&#123;    // p是一个指向整形常量的指针,p可以修改，但是*P不可修改    const int *p = nullptr;    // q是一个指向整形变量的常量指针,q不可修改,但是*q可以修改    constexpr int *q = nullptr;    // np是一个指向整数的常量指针，其中为空    constexpr int *np = nullptr;    // i和j必须定义在函数体之外，否则报错，提示p访问运行时存储    //因为constexpr要求表达式为常量，在编译时展开    //  p是常量指针，指向整形常量i    constexpr const int *p2 = &amp;i;    // p1是常量指针，指向整数j    constexpr int *p1 = &amp;j;&#125;\n\n类型别名类型别名(type alias)是一个名字，他是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚的知道使用该类型的真实目的。有两种方法可用于定义类型别名。传统的方法是使用关键字typedef: 1 typedef\n12345678910void typedef_func()&#123;    // wages是double的同义词    typedef double wages;    // base是double的同义词， p 是double*的同义词    typedef wages base, *p;    // C11用法    using newd = double;    newd dd = 3.14;&#125;\n新标准规定了一种新的方法，使用别名声明（aliasdeclaration）来定义类型的别名，using newd &#x3D; 都变了就是通过using定义new类型和double是相同的。\n如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型pstring，它实际上是char *的别名。\n12345678910111213141516void typedef_func()&#123;    typedef char *pstring;    // pstring是一个指向char的常量指针    const pstring cstr = 0;    // ps 是一个指针，其对象是指向char的常量指针    const pstring *ps;    char b = &#x27;H&#x27;;    //不可修改    // cstr = &amp;b;    ps = &amp;cstr;    const pstring cstr2 = &amp;b;    ps = &amp;cstr2;    //不可修改*ps的值    // *ps = cstr;&#125;\n\nauto 推导编程时常常需要把表达式的值付给变量，这就要求在声明变量的时候清楚地知道表达式的类型。为了做到这一点在C++11新标准中引入了auto类型说明符，用它就能让编译器去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如double）不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值，使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样。\n123456789101112131415161718192021void auto_func()&#123;    int a = 100;    int b = 1024;    // c被推导为int类型    auto c = a + b;    auto i = 0, *p = &amp;i;    //一条声明语句只能有一个基本数据类型    //不同类型编译器会报错    // auto sz = 0, pi = 3.14;    const int ma = 1;    // auto会忽略顶层const    //可以通过const明确指出，此时f为const int类型    const auto f = ma;    // auto配合引用类型    auto &amp;g = a;    // 不能为非常量引用绑定字面值    // auto &amp;h = 42;    //指明const 引用绑定字面值    const auto &amp;j = 42;&#125;\n\nauto一般会忽略掉顶层const，同时底层const则会保留下来 要在一条语句中定义多个变量，切记，符号&amp;和＊只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型：\n12345678// k是int类型，l是int的引用// auto 忽略了顶层constauto k = ci, &amp;l = i;// m是int常量的引用，p是指向int常量的指针// auto保留了底层constauto &amp;m = ci, *p = &amp;ci;// 错误 i的类型是int， ci的类型是 const int// auto &amp;n = i, *p2 = &amp;ci;\n\ndecltype类型指示符有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：\n1decltype(size()) sum;\n\n编译器并不实际调用函数size，而是使用当调用发生时size的返回值类型作为sum的类型。换句话说，编译器为sum指定的类型是什么呢？就是假如size被调用的话将会返回的那个类型。decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：\n1234567891011void decltype_func()&#123;    decltype(size()) sum;    const int ci = 0, &amp;cj = ci;    // x的类型是const int    decltype(ci) x = 0;    // y的类型是 const int&amp; , y绑定到变量x    decltype(cj) y = x;    //错误，z是一个引用，必须初始化    // decltype(cj) z;&#125;\n\n因为cj是一个引用，decltype（cj）的结果就是引用类型，因此作为引用的z必须被初始化。需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型.\n1234567int i = 42, *p = &amp;i, &amp;r = i;// b1 是一个int类型的引用decltype(r) b1 = i;// r+0 通过decltype返回int类型decltype(r + 0) b2;//错误，必须初始化,c是int&amp;类型// decltype(*p) c;","slug":"C++的输入和输出","date":"2022-05-01T18:15:58.000Z","categories_index":"","tags_index":"","author_index":"kiyose408"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"组成一个基本的C++程序通常包含以下几个部分：\n\n预处理器指令：预处理器指令以 # 符号开头，它们告诉编译器在编译之前进行某些操作。例如，#include 用于包含头文件。\n主函数：C++程序从 main() 函数开始执行。main 函数是C++程序的入口点。\n声明和定义：在 main() 函数之前，可以声明变量和函数，并定义类、结构体等。\n执行语句：在 main() 函数中，可以编写执行语句来执行程序。\n\n下面是一个简单的C++程序示例，它打印出 “Hello, World!”：\n123456#include &lt;iostream&gt;int main() &#123;    std::cout &lt;&lt; &quot;Hello, World!&quot;;    return 0;&#125;\n这个程序的各部分说明：\n\n#include &lt;iostream&gt; 是预处理器指令，用于包含标准输入输出头文件。\nint main() 是主函数，C++程序从这里开始执行。\nstd::cout &lt;&lt; &quot;Hello, World!&quot;; 是执行语句，它打印出 “Hello, World!”。\nreturn 0; 表示程序正常结束。\n\nC++基础语句范例：\n123456789101112//备注#include&lt;iostream&gt;//头文件using namespace std;//命名空间int main()//主函数入口&#123;\tint value = 0;//初始化整形变量\tcout &lt;&lt; &quot;The variable is initialized as :&quot; &lt;&lt; value &lt;&lt; endl;//输出\tcout &lt;&lt; &quot;give a new value to this variable please.&quot; &lt;&lt; endl;//输出\tcin &gt;&gt; value;//输入\tcout &lt;&lt; &quot;The variable changed to  :&quot; &lt;&lt; value &lt;&lt; endl;\treturn 0;//返回值&#125;\n\n声明语句：定义函数中使用的变量的名称和类型；\n赋值语句：使用赋值运算符对变量进行赋值；\n消息语句：将消息发送给对象，激发某种行动；\n函数调用：执行函数。被调用的函数执行完毕之后，程序返回到函数调用语句后面的语句；\n函数原型：声明函数的返回类型、函数接受的参数数量和类型；\n返回语句：将一个值从被调用的函数哪里返回到调用函数中。\n\n函数\n函数格式：\n函数头和函数体\ntype functionname(argumentlist)&#123; statements&#125;\n\n\n函数特性：\n函数头：指出返回值（如果有的话）的类型和函数期望通过参数传递给他的信息的类型。\n函数体：由一系列位于花括号中的C++语句组成；\n接受一个参数\n返回一个值\n需要一个原型\n\n\n在多函数的程序中旨在需要使用到io指令的函数中使用using编译指令，只让需要访问std名称空间的函数访问更佳。\n\n","slug":"C++基础结构","date":"2022-05-01T15:15:58.000Z","categories_index":"","tags_index":"","author_index":"kiyose408"}]