{"title":"模版特例化","uid":"698bdaa973d597a4a390a291dbaefc44","slug":"模版特例化","date":"2022-04-21T15:49:00.000Z","updated":"2024-05-23T08:26:22.610Z","comments":true,"path":"api/articles/模版特例化.json","keywords":null,"cover":"img/mo.jpg","content":"<h2 id=\"特例化介绍\"><a href=\"#特例化介绍\" class=\"headerlink\" title=\"特例化介绍\"></a>特例化介绍</h2><p>模板特例化主要是用于在模板特定情况下的一些特殊定义，用来完善模板在特定情况的调用 我们先实现一个函数模板</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">int compare(const T &amp;v1, const T &amp;v2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;use compare T&amp;&quot; &lt;&lt; endl;</span><br><span class=\"line\">    if (v1 &lt; v2)</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    if (v2 &lt; v1)</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们实现一个带字面值常量的特例化版本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//带字面常量的比较函数</span><br><span class=\"line\">template &lt;size_t N, size_t M&gt;</span><br><span class=\"line\">int compare(const char (&amp;a1)[N], const char (&amp;a2)[M])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;use const char (&amp;)[N]&quot; &lt;&lt; endl;</span><br><span class=\"line\">    strcmp(a1, a2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们实现一个testcompare函数测试普通版和特例话版本的函数调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void testcompare()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    const char *p1 = &quot;h1&quot;;</span><br><span class=\"line\">    const char *p2 = &quot;mom&quot;;</span><br><span class=\"line\">    //调用特例化版本</span><br><span class=\"line\">    compare(p1, p2);</span><br><span class=\"line\">    //调用第二个版本</span><br><span class=\"line\">    compare(&quot;hi&quot;, &quot;mom&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当调用特例化版本时，N会被设定为”h1”的长度，M会被设定为”mom”长度。 但是我们发现使用通用模板类型的函数compare在被叫指针p1和p2时不是很理想，可以单独实现针对p1和p2指针特定版的模板函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;&gt;</span><br><span class=\"line\">int compare(const char* &amp;v1, const char* &amp;v2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;use compare char * &quot; &lt;&lt; endl;</span><br><span class=\"line\">    if (strlen(v1) &lt; strlen(v2))</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    else if (strlen(v2) &lt; strlen(v1))</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    else </span><br><span class=\"line\">        return strcmp(v1, v2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于char * 版本我们实现了自己的比较规则，如果长度长的那个就是大值，相等则依次比较字符串中的每个字符。</p>\n<h2 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h2><p>类模板的使用和函数模板类似，我们先声明两个模板类，然后为模板类声明一个比较函数重载运算符</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename&gt;</span><br><span class=\"line\">class BlobPtr;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename&gt;</span><br><span class=\"line\">class Blob;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">bool operator==(const Blob&lt;T&gt; &amp;, const Blob&lt;T&gt; &amp;);</span><br></pre></td></tr></table></figure>\n\n<p>我们实现<code>Blob&lt;T&gt;</code>模板类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义模板类型的blob</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class Blob</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    typedef T value_type;</span><br><span class=\"line\">    typedef typename std::vector&lt;T&gt;::size_type size_type;</span><br><span class=\"line\">    // T类型的BlobPtr是T类型的Blob的友元类</span><br><span class=\"line\">    friend class BlobPtr&lt;T&gt;;</span><br><span class=\"line\">    //重载==运算符</span><br><span class=\"line\">    friend bool operator==(const Blob&lt;T&gt; &amp;, const Blob&lt;T&gt; &amp;);</span><br><span class=\"line\">    //构造函数</span><br><span class=\"line\">    Blob()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        data = make_shared&lt;std::vector&lt;T&gt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Blob(std::initializer_list&lt;T&gt; il)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        data = make_shared&lt;std::vector&lt;T&gt;&gt;(il);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    template &lt;typename It&gt;</span><br><span class=\"line\">    Blob(It b, It e);</span><br><span class=\"line\">    // Blob 中元素数目</span><br><span class=\"line\">    size_type size() const &#123; return data-&gt;size(); &#125;</span><br><span class=\"line\">    bool empty() const &#123; return data-&gt;empty(); &#125;</span><br><span class=\"line\">    //添加和删除元素</span><br><span class=\"line\">    void push_back(const T &amp;t) &#123; data-&gt;push_back(t); &#125;</span><br><span class=\"line\">    //移动版本的push_back</span><br><span class=\"line\">    void push_back(const T &amp;&amp;t) &#123; data-&gt;push_back(std::move(t)); &#125;</span><br><span class=\"line\">    //删除元素</span><br><span class=\"line\">    void pop_back();</span><br><span class=\"line\">    //元素访问</span><br><span class=\"line\">    T &amp;back();</span><br><span class=\"line\">    T &amp;operator[](size_type i);</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;</span><br><span class=\"line\">    //校验数据是否有效</span><br><span class=\"line\">    void check(size_type i, const std::string &amp;msg) const;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>接下来实现Blob模板类的几个成员函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Blob&lt;T&gt;::check(size_type i, const std::string &amp;msg) const</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (i &gt;= data-&gt;size())</span><br><span class=\"line\">        throw std::out_of_range(msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void Blob&lt;T&gt;::pop_back()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (data-&gt;empty())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    data-&gt;pop_back();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">T &amp;Blob&lt;T&gt;::back()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return data-&gt;back();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">T &amp;Blob&lt;T&gt;::operator[](size_type i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    check(i, &quot;index out of range&quot;);</span><br><span class=\"line\">    return (*data)[i];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现了pop_back, back, check等操作，以及下标索引等函数，接下来实现比较运算符重载</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">bool operator==(const Blob&lt;T&gt; &amp;b1, const Blob&lt;T&gt; &amp;b2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (b1.size() &gt; b2.size())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (b1.siz() &lt; b2.size())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (unsigned int i = 0; i &lt; b1.size(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (b1.data[i] == b2.data[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return b1.data[i] &gt; b2.data[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时我们还没有实现迭代器版本的构造函数，与类模板的普通成员函数不同，成员函数有自己的模板，所以要写两个模板名</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//与模板类的普通成员不同，成员模板是函数模板</span><br><span class=\"line\">//模板类的T类型</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">//成员函数模板It类型</span><br><span class=\"line\">template &lt;typename It&gt;</span><br><span class=\"line\">Blob&lt;T&gt;::Blob(It b, It e)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //通过迭代器构造</span><br><span class=\"line\">    data = std::make_shared&lt;std::vector&lt;T&gt;&gt;(b, e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就可以通不同类型的vector初始化Blob的构造函数了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_tempmemfunc()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int ia[] = &#123;0, 1, 2, 3, 4&#125;;</span><br><span class=\"line\">    vector&lt;long&gt; vi = &#123;7, 6, 5, 4&#125;;</span><br><span class=\"line\">    list&lt;const char *&gt; w = &#123;&quot;now&quot;, &quot;zack&quot;, &quot;lov u&quot;&#125;;</span><br><span class=\"line\">    // Blob&lt;T&gt; T被实例化为int，</span><br><span class=\"line\">    //函数模板It被实例化为 int *</span><br><span class=\"line\">    Blob&lt;int&gt; a1(begin(ia), end(ia));</span><br><span class=\"line\">    // It为vi的迭代器类型vector&lt;long&gt;::iterator T为long类型</span><br><span class=\"line\">    Blob&lt;long&gt; a2(vi.begin(), vi.end());</span><br><span class=\"line\">    //实例化Blob&lt;string&gt;以及list&lt;const char *&gt;::iterator参数</span><br><span class=\"line\">    Blob&lt;string&gt; a3(w.begin(), w.end());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们实现BlobPtr这个模板类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class BlobPtr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    BlobPtr() : curr(0) &#123;&#125;</span><br><span class=\"line\">    BlobPtr(Blob&lt;T&gt; &amp;a, size_t sz = 0) : wptr(a.data), curr(sz) &#123;&#125;</span><br><span class=\"line\">    //递增和递减</span><br><span class=\"line\">    BlobPtr &amp;operator++(); //前置运算符</span><br><span class=\"line\">                           // BlobPtr &amp;operator--(); //前置运算符--</span><br><span class=\"line\"></span><br><span class=\"line\">    BlobPtr &amp;operator++(int);</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    std::shared_ptr&lt;std::vector&lt;T&gt;&gt;</span><br><span class=\"line\">    check(std::size_t, const std::string &amp;) const;</span><br><span class=\"line\">    std::size_t curr; //数组中的当前位置</span><br><span class=\"line\">    //保存一个weak_ptr， 表示底层vector可能被销毁</span><br><span class=\"line\">    std::weak_ptr&lt;std::vector&lt;T&gt;&gt; wptr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>BlobPtr实现了根据Blob构造自己的成员wptr以及curr，因为wptr是一个弱指针，所以只做弱关联。 接下来我们实现前置++和后置++</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BlobPtr&lt;T&gt; &amp;BlobPtr&lt;T&gt;::operator++()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this-&gt;curr++;</span><br><span class=\"line\">    return *this;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BlobPtr&lt;T&gt; &amp;BlobPtr&lt;T&gt;::operator++(int)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BlobPtr &amp;rt = *this;</span><br><span class=\"line\">    this-&gt;curr++;</span><br><span class=\"line\">    return rt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前置++很容易理解，后置++理解较为困难，这里做一下说明，后置++的函数里先用一个BlobPtr引用类型的临时变量rt存储了_this，因为this不会被释放，所以rt就是<code>_this</code>的引用，所引用的内容不会释放，这样外界接受到rt后同样是引用的<code>_this</code>。这样即使rt被回收了也没关系，因为外部已经捕获到<code>_this</code>的引用了。然后对curr++操作，这就是我们看到的先返回<code>*this</code>的引用，后++。 模板类没有实现拷贝赋值时，默认用拷贝构造完成构造初始化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_classtemp()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Blob&lt;int&gt; ia;</span><br><span class=\"line\">    Blob&lt;int&gt; ia2 = &#123;0, 1, 2, 3, 5&#125;;</span><br><span class=\"line\">    Blob&lt;string&gt; ia3 = &#123;&quot;hello &quot;, &quot;zack&quot;, &quot;nice&quot;&#125;;</span><br><span class=\"line\">    for (size_t i = 0; i &lt; ia2.size(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ia2[i] = i * i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (size_t i = 0; i &lt; ia2.size(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; ia2[i] &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (size_t i = 0; i &lt; ia3.size(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        string_upper(ia3[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (size_t i = 0; i &lt; ia3.size(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; ia3[i] &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const auto &amp;data = ia3.back();</span><br><span class=\"line\">    cout &lt;&lt; data &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    ia3.pop_back();</span><br><span class=\"line\">    const auto &amp;data2 = ia3.back();</span><br><span class=\"line\">    cout &lt;&lt; data2 &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模板的友元\"><a href=\"#模板的友元\" class=\"headerlink\" title=\"模板的友元\"></a>模板的友元</h2><p>模板类也支持友元类的访问，以下列举了几种情况</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class Pal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class Pal2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class C</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // Pal&lt;C&gt;是C类的友元</span><br><span class=\"line\">    friend class Pal&lt;C&gt;;</span><br><span class=\"line\">    //所有类型的Pal2的类都是C的友元</span><br><span class=\"line\">    template &lt;typename T&gt;</span><br><span class=\"line\">    friend class Pal2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// c2本身是一个模板类</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class C2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //和C2同类型的Pal是C2的所有实例友元</span><br><span class=\"line\">    friend class Pal&lt;T&gt;;</span><br><span class=\"line\">    // Pal2的所有实例都是C2的所有实例友元</span><br><span class=\"line\">    template &lt;typename X&gt;</span><br><span class=\"line\">    friend class Pal2;</span><br><span class=\"line\">    // Pal3是一个普通类，他是C2的所有实例的友元</span><br><span class=\"line\">    friend class Pal3;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename Type&gt;</span><br><span class=\"line\">class Bar</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //将访问权限授予用来实例化Bar的类型</span><br><span class=\"line\">    friend Type;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类模板的别名\"><a href=\"#类模板的别名\" class=\"headerlink\" title=\"类模板的别名\"></a>类模板的别名</h2><p>类模板的别名定义有以下几种方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义模板类别名</span><br><span class=\"line\">typedef long long INT64;</span><br><span class=\"line\">//我们可以为实例好的模板类定义别名</span><br><span class=\"line\">typedef Bar&lt;int&gt; mytype;</span><br><span class=\"line\">// C11 可以为模板类定义别名</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">using twin = pair&lt;T, T&gt;;</span><br><span class=\"line\">// authors 是一个pair&lt;string, string&gt;</span><br><span class=\"line\">twin&lt;string&gt; authors;</span><br><span class=\"line\">// infos 是一个pair&lt;int, int&gt;类型</span><br><span class=\"line\">twin&lt;int&gt; infos;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">using partNo = pair&lt;T, unsigned&gt;;</span><br><span class=\"line\">// books是pair&lt;string, unsigned&gt;类型</span><br><span class=\"line\">partNo&lt;string&gt; books;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类模板的静态成员\"><a href=\"#类模板的静态成员\" class=\"headerlink\" title=\"类模板的静态成员\"></a>类模板的静态成员</h2><p>类模板的静态成员要在非内联文件中初始化，也就是说在类模板声明的.h文件初始化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//类模板的static成员</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class Foo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    static std::size_t count() &#123; return ctr; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    static std::size_t ctr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">size_t Foo&lt;T&gt;::ctr = 0;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"告知编译器模板的子类型\"><a href=\"#告知编译器模板的子类型\" class=\"headerlink\" title=\"告知编译器模板的子类型\"></a>告知编译器模板的子类型</h2><p>对于string::size_type , size_type是一个类型 默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。 因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。 我们通过使用关键字typename来实现这一点：</p>\n<p>我们用下面的例子显示指名模板名作用域下的是类型不是名字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 用typename 告知编译器T::value_type是一个类型</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">typename T::value_type top(const T &amp;c)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!c.empty())</span><br><span class=\"line\">        return c.back();</span><br><span class=\"line\">    else</span><br><span class=\"line\">        return typename T::value_type();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"巧用模板类完成析构\"><a href=\"#巧用模板类完成析构\" class=\"headerlink\" title=\"巧用模板类完成析构\"></a>巧用模板类完成析构</h2><p>有时候我们可以利用模板类型实现()的重载，这样通过仿函数传递给智能指针的第二个参数，可以帮助智能指针回收内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//函数对象，给指定类型的指针执行析构</span><br><span class=\"line\">class DebugDelete</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    DebugDelete(std::ostream &amp;s = std::cerr) : os(s) &#123;&#125;</span><br><span class=\"line\">    //我们定义一个仿函数，参数是T*类型</span><br><span class=\"line\">    template &lt;typename T&gt;</span><br><span class=\"line\">    void operator()(T *p) const</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        os &lt;&lt; &quot;deleting unique_str&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        delete p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    std::ostream &amp;os;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>DebugDelete实现了仿函数，接下来写一个函数调用这个仿函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_debugdel()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    double *p = new double;</span><br><span class=\"line\">    DebugDelete d;</span><br><span class=\"line\">    //调用DebugDelete的仿函数,delete p</span><br><span class=\"line\">    d(p);</span><br><span class=\"line\">    //析构多种类型</span><br><span class=\"line\">    int *np = new int;</span><br><span class=\"line\">    //构造DebugDelete对象后调用仿函数析构np</span><br><span class=\"line\">    DebugDelete()(np);</span><br><span class=\"line\">    //作为删除器析构智能指针</span><br><span class=\"line\">    // p 被delete时会执行DebugDelete的仿函数进行析构</span><br><span class=\"line\">    unique_ptr&lt;int, DebugDelete&gt; p3(new int, DebugDelete());</span><br><span class=\"line\">    // 用DebugDelete 的仿函数析构string的指针</span><br><span class=\"line\">    unique_ptr&lt;string, DebugDelete&gt; sp(new string, DebugDelete());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模板类型推断\"><a href=\"#模板类型推断\" class=\"headerlink\" title=\"模板类型推断\"></a>模板类型推断</h2><p>有时候对于模板函数返回的类型表示起来很复杂时，可以通过auto 配合尾置类型推断返回数据类型 比如我们我们想返回迭代器指向类型的引用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//推断返回类型，通过尾置返回允许我们在参数列表之后的声明返回类型</span><br><span class=\"line\">template &lt;typename It&gt;</span><br><span class=\"line\">auto fcnrf(It beg, It end) -&gt; decltype(*beg)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //处理序列</span><br><span class=\"line\">    //返回迭代器beg指向的元素的引用</span><br><span class=\"line\">    return *beg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过decltype(*beg)返回迭代器beg指向的元素的引用类型。 如果想要返回指向元素的副本类型，不是引用类型可以通过remove_reference去引用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// remove_reference 是一个模板</span><br><span class=\"line\">// remove_reference&lt;decltype(*beg)&gt;::type</span><br><span class=\"line\">// type的类型就是beg指向元素的类型</span><br><span class=\"line\">// remove_reference&lt;int&amp;&gt;::type type就是int</span><br><span class=\"line\">// remove_reference&lt;string&amp;&gt;::type type就是string</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename It&gt;</span><br><span class=\"line\">auto fcncp(It beg, It end) -&gt; remove_reference&lt;decltype(*beg)&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //返回迭代器beg指向元素的copy</span><br><span class=\"line\">    return *beg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模板的左值和右值\"><a href=\"#模板的左值和右值\" class=\"headerlink\" title=\"模板的左值和右值\"></a>模板的左值和右值</h2><p>函数模板同样存在左值和右值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//接受左值引用的模板函数</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void f1(T &amp;t)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//接受右值引用的模板函数</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void f2(T &amp;&amp;t)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>f2(42) T就被推断为int int i &#x3D; 100; f2(i) T就被推断为int&amp; 参数类型就变为int&amp; &amp;&amp; 当模板函数的参数是一个T类型的右值引用 1 传递给该参数的实参是一个右值时，T就是该右值类型 2 传递给该参数的实参是一个左值时，T就是该左值引用类型</p>\n<p>折叠规则 X&amp;&amp; 、X&amp;&amp;&amp; 都会被折叠为X&amp; X&amp;&amp; &amp;&amp; 会被折叠为X&amp;&amp;</p>\n<p>所以我们可以推断move的实现原理，其参数一定是T&amp;&amp;类型，因为其能接受左值和右值两种类型。其返回值一定是实参类型的右值引用类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">typename remove_reference&lt;T&gt;::type &amp;&amp;my_move(T &amp;&amp;t)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return static_cast&lt;typename remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"为什么要有原样转发\"><a href=\"#为什么要有原样转发\" class=\"headerlink\" title=\"为什么要有原样转发\"></a>为什么要有原样转发</h2><p>stl::forward是用来做原样转发的，将原有类型保持原样传递给其他函数，这种机制尤为重要。因为如果不进行原样转发，传递的参数变为左值，传递给一个接受右值引用的函数会出现编译报错。 比如我们实现一个flip函数，既能接受左值又能接受右值，并且在函数内部修改这个值会同步到外部实参的效果，那他的实现一定是通过模板类型T&amp;&amp;实现的，通过折叠达到适配左值和右值的目的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>flip 函数内部调用了函数f, 将t1和t2的类型原样转发。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void gtemp(int &amp;&amp;i, int &amp;j)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void use_ftemp()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int j = 100;</span><br><span class=\"line\">    int i = 99;</span><br><span class=\"line\"></span><br><span class=\"line\">    // flip(gtemp, j, 42) 会报错</span><br><span class=\"line\">    // 因为42作为右值纯递给flip，t2会被折叠为int类型,</span><br><span class=\"line\">    // j作为左值传递给flip, T1会绑定为int&amp;，通过折叠t1变为int&amp;类型</span><br><span class=\"line\">    // 如果不进行原样转发，t2传递给gtemp第一个参数时，t2虽然是右值引用类型的变量</span><br><span class=\"line\">    // 但是t2作为左值传递给了gtemp第一个参数，编译器会报错，int&amp;&amp;无法绑定int类型</span><br><span class=\"line\">    // 所以无论右值引用类型还是左值引用类型的变量当成参数传递给其他函数时，这个变量就是一个左值。</span><br><span class=\"line\">    // 通过原样转发就保证了这个值在传递给其他函数时不改变其左值引用类型或者右值引用类型</span><br><span class=\"line\">    // 这样即使编译报错也是实参层面传递出了错误。</span><br><span class=\"line\">    flip(gtemp, i, 42);</span><br><span class=\"line\">    cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文模拟实现了vector的功能。 视频链接<a href=\"https://www.bilibili.com/video/BV15t4y1W7ZL/?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9\">https://www.bilibili.com/video/BV15t4y1W7ZL/?vd_source&#x3D;8be9e83424c2ed2c9b2a3ed1d01385e9</a> 源码链接 <a href=\"https://gitee.com/secondtonone1/cpplearn\">https://gitee.com/secondtonone1/cpplearn</a></p>\n","feature":null,"text":"模板特例化主要是用于在模板特定情况下的一些特殊定义...","permalink":"/post/模版特例化","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"C++模版","slug":"C-模版","count":4,"path":"api/categories/C-模版.json"}],"tags":[{"name":"模版","slug":"模版","count":4,"path":"api/tags/模版.json"},{"name":"特例化","slug":"特例化","count":1,"path":"api/tags/特例化.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%89%B9%E4%BE%8B%E5%8C%96%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">特例化介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E6%A8%A1%E6%9D%BF\"><span class=\"toc-text\">类模板</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8F%8B%E5%85%83\"><span class=\"toc-text\">模板的友元</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%88%AB%E5%90%8D\"><span class=\"toc-text\">类模板的别名</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98\"><span class=\"toc-text\">类模板的静态成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%91%8A%E7%9F%A5%E7%BC%96%E8%AF%91%E5%99%A8%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">告知编译器模板的子类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B7%A7%E7%94%A8%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%AE%8C%E6%88%90%E6%9E%90%E6%9E%84\"><span class=\"toc-text\">巧用模板类完成析构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD\"><span class=\"toc-text\">模板类型推断</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC\"><span class=\"toc-text\">模板的左值和右值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%8E%9F%E6%A0%B7%E8%BD%AC%E5%8F%91\"><span class=\"toc-text\">为什么要有原样转发</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"Hexo搭建博客网站","uid":"8412bcb71a16d5331194e0e41f73e27d","slug":"Hexo搭建博客","date":"2020-05-16T15:15:58.000Z","updated":"2024-05-18T18:05:11.816Z","comments":true,"path":"api/articles/Hexo搭建博客.json","keywords":null,"cover":"img/web.jpg","text":"使用Hexo搭建博客网站....","permalink":"/post/Hexo搭建博客","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"实用教程","slug":"实用教程","count":5,"path":"api/categories/实用教程.json"}],"tags":[{"name":"Hexo","slug":"Hexo","count":1,"path":"api/tags/Hexo.json"},{"name":"网站搭建","slug":"网站搭建","count":1,"path":"api/tags/网站搭建.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":true},"next_post":{"title":"模拟实现vector","uid":"5ac0cfc2a03b63f31f1f39881eb54b11","slug":"模拟实现vector","date":"2022-04-16T14:49:00.000Z","updated":"2024-05-23T08:28:33.332Z","comments":true,"path":"api/articles/模拟实现vector.json","keywords":null,"cover":"img/mo.jpg","text":"我们可以通过模板实现类似vector的类。我们实现一个StrVecTemp类，其内部通过allocator开辟空间...","permalink":"/post/模拟实现vector","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"C++模版","slug":"C-模版","count":4,"path":"api/categories/C-模版.json"}],"tags":[{"name":"模版","slug":"模版","count":4,"path":"api/tags/模版.json"},{"name":"模拟","slug":"模拟","count":1,"path":"api/tags/模拟.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null}}