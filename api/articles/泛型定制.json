{"title":"泛型定制","uid":"72f8e112b71c8b55e9acbece39e8eb93","slug":"泛型定制","date":"2022-01-25T05:49:00.000Z","updated":"2024-05-23T07:10:49.990Z","comments":true,"path":"api/articles/泛型定制.json","keywords":null,"cover":"img/fx.png","content":"<h2 id=\"向算法传递函数\"><a href=\"#向算法传递函数\" class=\"headerlink\" title=\"向算法传递函数\"></a>向算法传递函数</h2><p>默认情况下，泛型算法还实现了另外一个版本，就是接受一个额外的参数。比如sort函数，接受第三个参数，第三个参数是一个谓词。 谓词就是一个可调用的表达式，其返回值结果是一个能用作条件的值。 标准库算法所使用的谓词分为两类： 一元谓词（unary predicate，意味着它们只接受单一参数）和二元谓词（binary predicate，意味着它们有两个参数）。 接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。 我们可以暂且将谓词理解为函数 我们利用谓词，修改sort的排序规则</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool isShort(const string &amp;s1, const string &amp;s2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return s1.size() &lt; s2.size();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码将规则修改为按长度有小到大排序 接下来我们实现一个函数调用sort并传递参数isShort</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_predicate()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vector&lt;string&gt; words = &#123;&quot;hello&quot;, &quot;za&quot;, &quot;zack&quot;, &quot;no matter&quot;, &quot;what&quot;&#125;;</span><br><span class=\"line\">    sort(words.begin(), words.end(), isShort);</span><br><span class=\"line\">    for (auto it = words.begin(); it != words.end(); it++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的函数输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">za</span><br><span class=\"line\">zack</span><br><span class=\"line\">what</span><br><span class=\"line\">hello</span><br><span class=\"line\">no matter</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"lambda表达式\"><a href=\"#lambda表达式\" class=\"headerlink\" title=\"lambda表达式\"></a>lambda表达式</h2><p>lambda表达式提供了类似函数的功能，可以理解为一个匿名函数，通过传递参数和捕获外部变量的引用，值等方式完成一些逻辑处理。 一个lambda表达式表示一个可调用的代码单元。 我们可以将其理解为一个未命名的内联函数。 与任何函数类似，一个lambda具有一个返回类型、一个参数列表和一个函数体。 但与函数不同，lambda可能定义在函数内部。 一个lambda表达式具有如下形式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[capture list](parameter list) -&gt; return type &#123;function body&#125;</span><br></pre></td></tr></table></figure>\n\n<p>capture list表示捕获列表，如果lambda表达式定义在函数内部，可以通过capture list 捕获该函数的局部变量的引用或者值。 return type、parameter list和function body与任何普通函数一样，分别表示返回类型、参数列表和函数体。 我们可以忽略返回类型，lambda可以根据返回值自己推导返回类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto f = []()</span><br><span class=\"line\"> &#123; return 42; &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>此例中，我们定义了一个可调用对象f，它不接受参数，返回42。lambda的调用方式与普通函数的调用方式相同，都是使用调用运算符：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; &quot; f is &quot; &lt;&lt; f() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<p>如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void。 我们将isShorter函数定义为lambda表达式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[](const string &amp;s1, const string &amp;s2) -&gt; bool</span><br><span class=\"line\">  &#123; return s1.size() &lt; s2.size(); &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以通过调用stable_sort进行排序，长度相同的单词维持原序列.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;string&gt; words = &#123;&quot;hello&quot;, &quot;za&quot;, &quot;zack&quot;, &quot;no matter&quot;, &quot;what&quot;&#125;;</span><br><span class=\"line\">    stable_sort(words.begin(), words.end(), [](const string &amp;s1, const string &amp;s2) -&gt; bool</span><br><span class=\"line\">                &#123; return s1.size() &lt; s2.size(); &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我们打印words</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (auto it = words.begin(); it != words.end(); it++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">za</span><br><span class=\"line\">zack</span><br><span class=\"line\">what</span><br><span class=\"line\">hello</span><br><span class=\"line\">no matter</span><br></pre></td></tr></table></figure>\n\n<p>我们用lambda表达式的捕获功能，实现一个函数，查找长度大于指定数值的单词个数。 我们先实现一个将单词排序并去除重复单词的函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void erase_dup(vector&lt;string&gt; &amp;words)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //先将words中的词语排序</span><br><span class=\"line\">    sort(words.begin(), words.end());</span><br><span class=\"line\">    // unique会移动元素，将不重复的元素放在前边，重复的放在后边</span><br><span class=\"line\">    // unique返回不重复的最后一个元素的位置</span><br><span class=\"line\">    const auto uniqueiter = unique(words.begin(), words.end());</span><br><span class=\"line\">    //调用erase将重复的元素删除</span><br><span class=\"line\">    words.erase(uniqueiter, words.end());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们实现biggers函数，返回大于指定长度sz的单词的个数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int use_bigger(int sz)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vector&lt;string&gt; words = &#123;&quot;hello&quot;, &quot;za&quot;, &quot;zack&quot;, &quot;no matter&quot;, &quot;what&quot;&#125;;</span><br><span class=\"line\">    //先排序去除重复单词</span><br><span class=\"line\">    erase_dup(words);</span><br><span class=\"line\">    //再稳定排序，按照长度有小到大</span><br><span class=\"line\">    stable_sort(words.begin(), words.end(), [](const string &amp;s1, const string &amp;s2) -&gt; bool</span><br><span class=\"line\">                &#123; return s1.size() &lt; s2.size(); &#125;);</span><br><span class=\"line\">    auto findit = find_if(words.begin(), words.end(), [sz](const string &amp;s)</span><br><span class=\"line\">                          &#123; return s.size() &gt; sz; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return words.end() - findit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们测试下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; &quot;count is &quot; &lt;&lt; use_bigger(3) &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; &quot;count is &quot; &lt;&lt; use_bigger(5) &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; &quot;count is &quot; &lt;&lt; use_bigger(10) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<p>程序输出如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">count is 4</span><br><span class=\"line\">count is 1</span><br><span class=\"line\">count is 0</span><br></pre></td></tr></table></figure>\n\n<p>可以看出长度大于3的单词有4个，长度大于5的有1个，长度大于10的有0个。 我们通过lambda表达式[sz]的方式捕获了use_bigger的形参sz。 如果我们要将长度大于sz的单词全部打印出来,可以采用foreach函数，该函数接受三个参数，前两个是迭代器表示遍历的范围，第三个是一个表达式，表示对每个元素的操作。我们完善use_bigger函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int use_bigger(int sz)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vector&lt;string&gt; words = &#123;&quot;hello&quot;, &quot;za&quot;, &quot;zack&quot;, &quot;no matter&quot;, &quot;what&quot;&#125;;</span><br><span class=\"line\">    //先排序去除重复单词</span><br><span class=\"line\">    erase_dup(words);</span><br><span class=\"line\">    //再稳定排序，按照长度有小到大</span><br><span class=\"line\">    stable_sort(words.begin(), words.end(), [](const string &amp;s1, const string &amp;s2) -&gt; bool</span><br><span class=\"line\">                &#123; return s1.size() &lt; s2.size(); &#125;);</span><br><span class=\"line\">    auto findit = find_if(words.begin(), words.end(), [sz](const string &amp;s)</span><br><span class=\"line\">                          &#123; return s.size() &gt; sz; &#125;);</span><br><span class=\"line\">    for_each(findit, words.end(), [](const string &amp;s)</span><br><span class=\"line\">             &#123; cout &lt;&lt; s &lt;&lt; &quot; &quot;; &#125;);</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">    return words.end() - findit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"lambda捕获类型\"><a href=\"#lambda捕获类型\" class=\"headerlink\" title=\"lambda捕获类型\"></a>lambda捕获类型</h2><p>lambda捕获分为值捕获和引用捕获。 lambda采用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。 与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void lambda_catch()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int val = 10;</span><br><span class=\"line\">    auto fn = [val]</span><br><span class=\"line\">    &#123; return val; &#125;;</span><br><span class=\"line\">    val = 200;</span><br><span class=\"line\">    auto fv = fn();</span><br><span class=\"line\">    cout &lt;&lt; &quot;fv is &quot; &lt;&lt; fv &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码fv会输出10，因为fn捕获的是val的值，在lambda表达式创建时就捕获了val，此时val值为10. 如果采用引用方式捕获</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void lambda_catch_r()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int val = 10;</span><br><span class=\"line\">    auto fn = [&amp;val]</span><br><span class=\"line\">    &#123; return val; &#125;;</span><br><span class=\"line\">    val = 200;</span><br><span class=\"line\">    auto fv = fn();</span><br><span class=\"line\">    cout &lt;&lt; &quot;fv is &quot; &lt;&lt; fv &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时输出fv is 200， 因为fn捕获的是val的引用。 我们可以从一个函数返回lambda，此lambda不能包含引用捕获。因为如果lambda包含了函数局部变量的引用，当次局部变量被释放后，lambda调用会出现崩溃问题。</p>\n<p>捕获一个普通变量，如int、string或其他非指针类型，通常可以采用简单的值捕获方式。 在此情况下，只需关注变量在捕获时是否有我们所需的值就可以了。 如果我们捕获一个指针或迭代器，或采用引用捕获方式，就必须确保在lambda执行时，绑定到迭代器、指针或引用的对象仍然存在。 而且，需要保证对象具有预期的值。 在lambda从创建到它执行的这段时间内，可能有代码改变绑定的对象的值。 也就是说，在指针（或引用）被捕获的时刻，绑定的对象的值是我们所期望的，但在lambda执行时，该对象的值可能已经完全不同了。 一般来说，我们应该尽量减少捕获的数据量，来避免潜在的捕获导致的问题。而且，如果可能的话，应该避免捕获指针或引用。</p>\n<h2 id=\"隐式捕获\"><a href=\"#隐式捕获\" class=\"headerlink\" title=\"隐式捕获\"></a>隐式捕获</h2><p>为了指示编译器推断捕获列表，应在捕获列表中写一个&amp;或&#x3D;。&amp;告诉编译器采用捕获引用方式，&#x3D;则表示采用值捕获方式。 比如我们修改use_bigger函数，参数增加一个ostream和char的分隔符，在use_bigger内部利用for_each调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int use_bigger2(ostream &amp;os, char c, int sz)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vector&lt;string&gt; words = &#123;&quot;hello&quot;, &quot;za&quot;, &quot;zack&quot;, &quot;no matter&quot;, &quot;what&quot;&#125;;</span><br><span class=\"line\">    //先排序去除重复单词</span><br><span class=\"line\">    erase_dup(words);</span><br><span class=\"line\">    //再稳定排序，按照长度有小到大</span><br><span class=\"line\">    stable_sort(words.begin(), words.end(), [](const string &amp;s1, const string &amp;s2) -&gt; bool</span><br><span class=\"line\">                &#123; return s1.size() &lt; s2.size(); &#125;);</span><br><span class=\"line\">    auto findit = find_if(words.begin(), words.end(), [sz](const string &amp;s)</span><br><span class=\"line\">                          &#123; return s.size() &gt; sz; &#125;);</span><br><span class=\"line\">    // os 按照引用方式捕获，其余变量c 通过= 值方式隐士捕获。</span><br><span class=\"line\">    for_each(findit, words.end(), [=, &amp;os](const string &amp;s)</span><br><span class=\"line\">             &#123; os &lt;&lt; s &lt;&lt; c; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // c 按照值的方式捕获，其余按照引用方式捕获。</span><br><span class=\"line\">    for_each(findit, words.end(), [&amp;, c](const string &amp;s)</span><br><span class=\"line\">             &#123; os &lt;&lt; s &lt;&lt; c; &#125;);</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">    return words.end() - findit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码两个for_each通过不同的隐式方式捕获局部变量。</p>\n<h2 id=\"mutable改变值\"><a href=\"#mutable改变值\" class=\"headerlink\" title=\"mutable改变值\"></a>mutable改变值</h2><p>默认情况下，值捕获的变量，lambda不会改变其值。lambda可以声明mutable，这样可以修改捕获的变量值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void mutalble_lam()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int val = 100;</span><br><span class=\"line\">    auto fn = [val]() mutable</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return ++val;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; &quot;val is &quot; &lt;&lt; val &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; &quot;fn val is &quot; &lt;&lt; fn() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    val = 200;</span><br><span class=\"line\">    cout &lt;&lt; &quot;val is &quot; &lt;&lt; val &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; &quot;fn val is &quot; &lt;&lt; fn() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val is 100</span><br><span class=\"line\">fn val is 101</span><br><span class=\"line\">val is 200</span><br><span class=\"line\">fn val is 102</span><br></pre></td></tr></table></figure>\n\n<p>fn捕获val的值，因为fn是mutable所以可以修改val，但不会影响外界的val。</p>\n<h2 id=\"lambda返回类型\"><a href=\"#lambda返回类型\" class=\"headerlink\" title=\"lambda返回类型\"></a>lambda返回类型</h2><p>我们要做一个返回序列中数值的绝对值的函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void rt_lambda()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vector&lt;int&gt; nums = &#123;-1, 2, 3, -5, 6, 7, -9&#125;;</span><br><span class=\"line\">    transform(nums.begin(), nums.end(), nums.begin(), [](int a)</span><br><span class=\"line\">              &#123; return a &lt; 0 ? -a : a; &#125;);</span><br><span class=\"line\">    for_each(nums.begin(), nums.end(), [](int a)</span><br><span class=\"line\">             &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过transform将nums中的数值全部变为其绝对值。transform前两个参数表示输入序列，第三个参数表示写入的目的序列，如果目的序列迭代器和输入序列开始的迭代器相同，则表示transform序列全部元素。lambda表达式并没有写返回值类型，但是是一个三目运算符的表达式，所以lambda可以推断返回类型。如果将lambda表达式写成如下会报错。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[](int a)&#123; if(a&lt;0) return -a; else return a; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时我们修改上面的lambda表达式，明确写出返回类型为int</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transform(nums.begin(), nums.end(), nums.begin(), [](int a) -&gt; int</span><br><span class=\"line\">             &#123; if (a &lt; 0)  return -a; else return a; &#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"bind绑定参数\"><a href=\"#bind绑定参数\" class=\"headerlink\" title=\"bind绑定参数\"></a>bind绑定参数</h2><p>bind的形式为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auto newCallable = bind(callable, arg_list);</span><br></pre></td></tr></table></figure>\n\n<p>newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。 即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。</p>\n<p>arg_list中的参数可能包含形如_n的名字，其中n是一个整数。这些参数是“占位符”，表示newCallable的参数，它们占据了传递给newCallable的参数的“位置”。 数值n表示生成的可调用对象中参数的位置：_1为newCallable的第一个参数，_2为第二个参数，依此类推。 我们先实现一个判断字符串长度的函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool check_size(const string &amp;str, int sz)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (str.size() &gt; sz)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>check_size如果字符串str的长度大于sz就返回true，否则就返回false。 接下来用bind操作生成一个新的函数，只接受一个sz参数。 使用bind函数要包含头文件functional，也需要使用using namespace std::placeholders</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void calsize_count()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    string str = &quot;hello&quot;;</span><br><span class=\"line\">    //将check_size第一个参数绑定给bind_check</span><br><span class=\"line\">    auto bind_check = bind(check_size, _1, 6);</span><br><span class=\"line\">    //相当于调用check_size(str,6)</span><br><span class=\"line\">    bool bck = bind_check(str);</span><br><span class=\"line\">    if (bck)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;check res is true&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;check res is false&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过bind将check_size第一个参数绑定给bind_check，第二个参数为6 所以调用bind_check(str)相当于调用check_size(str,6)。 我们可以用bind方式实现find_if的查找，因为find_if接受的谓词只能有一个参数，所以通过bind将check_size生成为单参数函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int use_bigger3(ostream &amp;os, char c, int sz)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vector&lt;string&gt; words = &#123;&quot;hello&quot;, &quot;za&quot;, &quot;zack&quot;, &quot;no matter&quot;, &quot;what&quot;&#125;;</span><br><span class=\"line\">    //先排序去除重复单词</span><br><span class=\"line\">    erase_dup(words);</span><br><span class=\"line\">    //再稳定排序，按照长度有小到大</span><br><span class=\"line\">    stable_sort(words.begin(), words.end(), [](const string &amp;s1, const string &amp;s2) -&gt; bool</span><br><span class=\"line\">                &#123; return s1.size() &lt; s2.size(); &#125;);</span><br><span class=\"line\">    auto findit = find_if(words.begin(), words.end(), bind(check_size, _1, sz));</span><br><span class=\"line\"></span><br><span class=\"line\">    // c 按照值的方式捕获，其余按照引用方式捕获。</span><br><span class=\"line\">    for_each(findit, words.end(), [&amp;, c](const string &amp;s)</span><br><span class=\"line\">             &#123; os &lt;&lt; s &lt;&lt; c; &#125;);</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">    return words.end() - findit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过bind生成新的函数传递给find_if就可以使用了。 bind极大地方便了泛型编程的可扩展性。</p>\n","feature":null,"text":"默认情况下，泛型算法还实现了另外一个版本，就是接受一个额外的参数。...","permalink":"/post/泛型定制","photos":[],"count_time":{"symbolsCount":"9.9k","symbolsTime":"9 mins."},"categories":[{"name":"泛型用法","slug":"泛型用法","count":3,"path":"api/categories/泛型用法.json"}],"tags":[{"name":"lambda表达式","slug":"lambda表达式","count":2,"path":"api/tags/lambda表达式.json"},{"name":"泛型","slug":"泛型","count":2,"path":"api/tags/泛型.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%91%E7%AE%97%E6%B3%95%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">向算法传递函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">lambda表达式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#lambda%E6%8D%95%E8%8E%B7%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">lambda捕获类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9A%90%E5%BC%8F%E6%8D%95%E8%8E%B7\"><span class=\"toc-text\">隐式捕获</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#mutable%E6%94%B9%E5%8F%98%E5%80%BC\"><span class=\"toc-text\">mutable改变值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#lambda%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">lambda返回类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bind%E7%BB%91%E5%AE%9A%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">bind绑定参数</span></a></li></ol>","author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"迭代器分类","uid":"e5cddefd1d930eb71bc590588a1288b4","slug":"迭代器分类","date":"2022-02-05T05:49:00.000Z","updated":"2024-05-31T01:31:10.540Z","comments":true,"path":"api/articles/迭代器分类.json","keywords":null,"cover":"img/fx.png","text":"除了容器自定义的迭代器之外，标准库还提供了其他几种迭代器，包括插入迭代器，流迭代器，反向迭代器，移动迭代器。...","permalink":"/post/迭代器分类","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"泛型用法","slug":"泛型用法","count":3,"path":"api/categories/泛型用法.json"}],"tags":[{"name":"迭代器","slug":"迭代器","count":2,"path":"api/tags/迭代器.json"},{"name":"插入迭代器","slug":"插入迭代器","count":1,"path":"api/tags/插入迭代器.json"},{"name":"方向迭代器","slug":"方向迭代器","count":1,"path":"api/tags/方向迭代器.json"},{"name":"iostream迭代器","slug":"iostream迭代器","count":1,"path":"api/tags/iostream迭代器.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null},"next_post":{"title":"泛型算法","uid":"ae38a1dc51089423f709c36bdcb792e9","slug":"泛型算法","date":"2022-01-15T05:49:00.000Z","updated":"2024-05-23T07:07:57.304Z","comments":true,"path":"api/articles/泛型算法.json","keywords":null,"cover":"img/fx.png","text":"介绍STL库中的泛型算法。...","permalink":"/post/泛型算法","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"泛型用法","slug":"泛型用法","count":3,"path":"api/categories/泛型用法.json"}],"tags":[{"name":"算法","slug":"算法","count":2,"path":"api/tags/算法.json"},{"name":"泛型","slug":"泛型","count":2,"path":"api/tags/泛型.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null}}