{"title":"模版类的友元和折叠规则","uid":"a5369c7c25920ed05726c5cd9a2b6ec2","slug":"模板类的友元和折叠规则","date":"2022-03-28T16:49:00.000Z","updated":"2024-05-23T08:18:18.861Z","comments":true,"path":"api/articles/模板类的友元和折叠规则.json","keywords":null,"cover":"img/mo.jpg","content":"<h2 id=\"为模板类声明友元类\">为模板类声明友元类</h2>\n<p>有时我们需要A类访问模板类B的私有成员，但是不想其他类访问，就要在模板类B里为A类声明友元。比如我们想要实现一个BlobPtr类，让BlobPtr类成为Blob类的友元，这样BlobPtr类就可以访问Blob类了。对于Blob类的声明和定义在前文已经阐述<a href=\"https://llfc.club/articlepage?id=28Vv7hro3VVMPDepLTlLRLqYJhJ\">https://llfc.club/articlepage?id=28Vv7hro3VVMPDepLTlLRLqYJhJ</a>。 我们省略Blob类的详细声明,只为它添加友元类BlobPtr类，并且为他添加友元函数operator==</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Blob</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    typedef T value_type;</span><br><span class=\"line\">    typedef typename std::vector&lt;T&gt;::size_type size_type;</span><br><span class=\"line\">    // T类型的BlobPtr是T类型的Blob的友元类</span><br><span class=\"line\">    friend class BlobPtr&lt;T&gt;;</span><br><span class=\"line\">    //重载==运算符</span><br><span class=\"line\">    friend bool operator==(const Blob&lt;T&gt; &amp;, const Blob&lt;T&gt; &amp;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现友元类BlobPtr\">实现友元类BlobPtr</h2>\n<p>接下来我们实现友元类BlobPtr,先对其进行声明</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class BlobPtr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    BlobPtr() : curr(0) &#123;&#125;</span><br><span class=\"line\">    BlobPtr(Blob&lt;T&gt; &amp;a, size_t sz = 0) : wptr(a.data), curr(sz) &#123;&#125;</span><br><span class=\"line\">    //递增和递减</span><br><span class=\"line\">    BlobPtr &amp;operator++(); //前置运算符</span><br><span class=\"line\">                           // BlobPtr &amp;operator--(); //前置运算符--</span><br><span class=\"line\"></span><br><span class=\"line\">    BlobPtr &amp;operator++(int);</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    std::shared_ptr&lt;std::vector&lt;T&gt;&gt;</span><br><span class=\"line\">    check(std::size_t, const std::string &amp;) const;</span><br><span class=\"line\">    std::size_t curr; //数组中的当前位置</span><br><span class=\"line\">    //保存一个weak_ptr， 表示底层vector可能被销毁</span><br><span class=\"line\">    std::weak_ptr&lt;std::vector&lt;T&gt;&gt; wptr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在实现其定义,这里只举例实现一部分函数，其余的读者自己实现即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BlobPtr&lt;T&gt; &amp;BlobPtr&lt;T&gt;::operator++()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this-&gt;curr++;</span><br><span class=\"line\">    return *this;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">BlobPtr&lt;T&gt; &amp;BlobPtr&lt;T&gt;::operator++(int)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BlobPtr &amp;rt = *this;</span><br><span class=\"line\">    this-&gt;curr++;</span><br><span class=\"line\">    return rt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于友元函数operator == 的定义可以按照如下实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">bool operator==(const Blob&lt;T&gt; &amp;b1, const Blob&lt;T&gt; &amp;b2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (b1.size() &gt; b2.size())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (b1.siz() &lt; b2.size())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (unsigned int i = 0; i &lt; b1.size(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (b1.data[i] == b2.data[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return b1.data[i] &gt; b2.data[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>模板类的友元还有一些特殊的用法，如下，读者可以自己体会</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class Pal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class Pal2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class C</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // Pal&lt;C&gt;是C类的友元</span><br><span class=\"line\">    friend class Pal&lt;C&gt;;</span><br><span class=\"line\">    //所有类型的Pal2的类都是C的友元</span><br><span class=\"line\">    template &lt;typename T&gt;</span><br><span class=\"line\">    friend class Pal2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// c2本身是一个模板类</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class C2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //和C2同类型的Pal是C2的所有实例友元</span><br><span class=\"line\">    friend class Pal&lt;T&gt;;</span><br><span class=\"line\">    // Pal2的所有实例都是C2的所有实例友元</span><br><span class=\"line\">    template &lt;typename X&gt;</span><br><span class=\"line\">    friend class Pal2;</span><br><span class=\"line\">    // Pal3是一个普通类，他是C2的所有实例的友元</span><br><span class=\"line\">    friend class Pal3;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"定义模板类别名\">定义模板类别名</h2>\n<p>我们可以通过typedef和using等方式为一个模板类定义别名</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename Type&gt;</span><br><span class=\"line\">class Bar</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //将访问权限授予用来实例化Bar的类型</span><br><span class=\"line\">    friend Type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//定义模板类别名</span><br><span class=\"line\">typedef long long INT64;</span><br><span class=\"line\">//我们可以为实例好的模板类定义别名</span><br><span class=\"line\">typedef Bar&lt;int&gt; mytype;</span><br><span class=\"line\">// C11 可以为模板类定义别名</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">using twin = pair&lt;T, T&gt;;</span><br><span class=\"line\">// authors 是一个pair&lt;string, string&gt;</span><br><span class=\"line\">twin&lt;string&gt; authors;</span><br><span class=\"line\">// infos 是一个pair&lt;int, int&gt;类型</span><br><span class=\"line\">twin&lt;int&gt; infos;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">using partNo = pair&lt;T, unsigned&gt;;</span><br><span class=\"line\">// books是pair&lt;string, unsigned&gt;类型</span><br><span class=\"line\">partNo&lt;string&gt; books;</span><br></pre></td></tr></table></figure>\n<h2 id=\"类模板的静态成员\">类模板的静态成员</h2>\n<p>对于类模板的静态成员，其初始化要放在声明的.h文件中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//类模板的static成员</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class Foo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    static std::size_t count() &#123; return ctr; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    static std::size_t ctr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化放在和声明所在的同一个.h文件中</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">size_t Foo&lt;T&gt;::ctr = 0;</span><br></pre></td></tr></table></figure>\n<h2 id=\"模板类的作用域访问\">模板类的作用域访问</h2>\n<p>默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。 因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。 我们通过使用关键字typename来实现这一点：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 用typename 告知编译器T::value_type是一个类型</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">typename T::value_type top(const T &amp;c)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!c.empty())</span><br><span class=\"line\">        return c.back();</span><br><span class=\"line\">    else</span><br><span class=\"line\">        return typename T::value_type();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们定义了一个名为top的模板函数，通过T::value_type声明其返回类型，但是C++默认作用域下value_type是一个成员， 所以为了说明value_type是一个类型就需要用typename关键字做声明。</p>\n<h2 id=\"通用的函数对象\">通用的函数对象</h2>\n<p>我们可以通过模板类实现通用的仿函数，也就是实现通用的函数对象，我们先实现一个DebugDelete类，用来删除各种类型的指针对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//函数对象，给指定类型的指针执行析构</span><br><span class=\"line\">class DebugDelete</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    DebugDelete(std::ostream &amp;s = std::cerr) : os(s) &#123;&#125;</span><br><span class=\"line\">    //我们定义一个仿函数，参数是T*类型</span><br><span class=\"line\">    template &lt;typename T&gt;</span><br><span class=\"line\">    void operator()(T *p) const</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        os &lt;&lt; &quot;deleting unique_str&quot; &lt;&lt; std::endl;</span><br><span class=\"line\">        delete p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    std::ostream &amp;os;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>DebugDelete构造函数接纳一个输出流，用来在operator()调用时输出删除信息 接下来我们实现一个测试函数，用来说明DebugDelete的用法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_debugdel()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    double *p = new double;</span><br><span class=\"line\">    DebugDelete d;</span><br><span class=\"line\">    //调用DebugDelete的仿函数,delete p</span><br><span class=\"line\">    d(p);</span><br><span class=\"line\">    //析构多种类型</span><br><span class=\"line\">    int *np = new int;</span><br><span class=\"line\">    //构造DebugDelete对象后调用仿函数析构np</span><br><span class=\"line\">    DebugDelete()(np);</span><br><span class=\"line\">    //作为删除器析构智能指针</span><br><span class=\"line\">    // p 被delete时会执行DebugDelete的仿函数进行析构</span><br><span class=\"line\">    unique_ptr&lt;int, DebugDelete&gt; p3(new int, DebugDelete());</span><br><span class=\"line\">    // 用DebugDelete 的仿函数析构string的指针</span><br><span class=\"line\">    unique_ptr&lt;string, DebugDelete&gt; sp(new string, DebugDelete());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出DebugDelete可以用来给智能指针作删除器用。</p>\n<h2 id=\"尾置类型的推断\">尾置类型的推断</h2>\n<p>C11新标准中提出了尾置类型推断</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// func接受了一个int类型的实参，返回了一个指针，该指针指向一个含有10个整数的数组</span><br><span class=\"line\">auto func(int i) -&gt; int (*)[10];</span><br></pre></td></tr></table></figure>\n<p>利用这个特性，我们可以用在模板函数中，同样实现一个尾置类型推断函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//推断返回类型，通过尾置返回允许我们在参数列表之后的声明返回类型</span><br><span class=\"line\">template &lt;typename It&gt;</span><br><span class=\"line\">auto fcnrf(It beg, It end) -&gt; decltype(*beg)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //处理序列</span><br><span class=\"line\">    //返回迭代器beg指向的元素的引用</span><br><span class=\"line\">    return *beg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>fcnrf的返回类型时It指向元素的解引用(*beg)类型，通过decltype类型推断给出返回的类型。 我们也可以实现一个返回值类型的函数，去掉引用类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// remove_reference 是一个模板</span><br><span class=\"line\">// remove_reference&lt;decltype(*beg)&gt;::type</span><br><span class=\"line\">// type的类型就是beg指向元素的类型</span><br><span class=\"line\">// remove_reference&lt;int&amp;&gt;::type type就是int</span><br><span class=\"line\">// remove_reference&lt;string&amp;&gt;::type type就是string</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename It&gt;</span><br><span class=\"line\">auto fcncp(It beg, It end) -&gt; remove_reference&lt;decltype(*beg)&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //返回迭代器beg指向元素的copy</span><br><span class=\"line\">    return *beg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"引用折叠规则\">引用折叠规则</h2>\n<p>我们可以用模板定义一个左值引用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//接受左值引用的模板函数</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void f1(T &amp;t)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我们用模板类型定义一个右值引用时，传递给该类型的实参类型，会根据C++标准进行折叠。 我们先声明一个右值引用的模板函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//接受右值引用的模板函数</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void f2(T &amp;&amp;t)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们调用f2(42), T就被推断为int int i = 100; f2(i) T就被推断为int&amp; 进行参数展开参数就变为int&amp; &amp;&amp; 折叠后就变为int &amp; 所以我们可以做如下归纳： 当模板函数的实参是一个T类型的右值引用 1 传递给该参数的实参是一个右值时， T就是该右值类型 2 传递给该参数的实参是一个左值时， T就是该左值引用类型。</p>\n<p>//折叠规则 //X&amp;&amp; ,X&amp;&amp;&amp; 都会被折叠为X&amp; //X&amp;&amp; &amp;&amp; 会被折叠为X&amp;&amp; 所以根据这个规律，我们可以实现一个类似于stl的move操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;typename T&gt;</span><br><span class=\"line\">typename remove_reference&lt;T&gt;::type &amp;&amp; my_move(T&amp;&amp; t)&#123;</span><br><span class=\"line\">    return static_cast&lt;typename remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们在函数中作如下调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_tempmove()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i = 100;</span><br><span class=\"line\">    my_move(i);</span><br><span class=\"line\">    //推断规则</span><br><span class=\"line\">    /*</span><br><span class=\"line\">    1  T被推断为int &amp;</span><br><span class=\"line\">    2  remove_reference&lt;int &amp;&gt;的type成员是int</span><br><span class=\"line\">    3  my_move 的返回类型是int&amp;&amp;</span><br><span class=\"line\">    4  推断t类型为int&amp; &amp;&amp; 通过折叠规则t为int&amp;类型</span><br><span class=\"line\">    5  最后这个表达式变为 int &amp;&amp; my_move(int &amp;t)</span><br><span class=\"line\">    */</span><br><span class=\"line\"></span><br><span class=\"line\">    auto rb = my_move(43);</span><br><span class=\"line\">    //推断规则</span><br><span class=\"line\">    /*</span><br><span class=\"line\">    1  T被推断为int</span><br><span class=\"line\">    2  remove_reference&lt;int&gt;的type成员是int</span><br><span class=\"line\">    3  my_move 的返回类型为int&amp;&amp;</span><br><span class=\"line\">    4  my_move 的参数t类型为int &amp;&amp;</span><br><span class=\"line\">    5  最后这个表达式变为 int &amp;&amp; my_move(int &amp;&amp; t)</span><br><span class=\"line\">    */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\">总结</h2>\n<p>这篇文章介绍了模板参数类型的折叠规则和友元类的声明和使用。 视频链接<a href=\"https://www.bilibili.com/video/BV1cF41177hK?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9\">https://www.bilibili.com/video/BV1cF41177hK?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9</a> 源码链接 <a href=\"https://gitee.com/secondtonone1/cpplearn\">https://gitee.com/secondtonone1/cpplearn</a></p>\n","feature":null,"text":"有时我们需要A类访问模板类B的私有成员，但是不想其他类访问，就要在模板类B里为A类声明友元。...","permalink":"/post/模板类的友元和折叠规则","photos":[],"count_time":{"symbolsCount":"7.2k","symbolsTime":"7 mins."},"categories":[{"name":"C++模版","slug":"C-模版","count":4,"path":"api/categories/C-模版.json"}],"tags":[{"name":"模版","slug":"模版","count":4,"path":"api/tags/模版.json"},{"name":"友元类","slug":"友元类","count":1,"path":"api/tags/友元类.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%A3%B0%E6%98%8E%E5%8F%8B%E5%85%83%E7%B1%BB\"><span class=\"toc-text\">为模板类声明友元类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%8F%8B%E5%85%83%E7%B1%BBBlobPtr\"><span class=\"toc-text\">实现友元类BlobPtr</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%88%AB%E5%90%8D\"><span class=\"toc-text\">定义模板类别名</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98\"><span class=\"toc-text\">类模板的静态成员</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">模板类的作用域访问</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%9A%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">通用的函数对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%BE%E7%BD%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8E%A8%E6%96%AD\"><span class=\"toc-text\">尾置类型的推断</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0%E8%A7%84%E5%88%99\"><span class=\"toc-text\">引用折叠规则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"foward原样转发","uid":"7840d4003f29222bf6cd12a2077991b7","slug":"forward原样转发","date":"2022-04-08T11:49:00.000Z","updated":"2024-05-23T08:27:33.771Z","comments":true,"path":"api/articles/forward原样转发.json","keywords":null,"cover":"img/mo.jpg","text":"前文我们实现了一个my_move函数，用来模拟stl的move操作，实现去引用的功能。其内部的原理就是通过remove_reference实现去引用操作。...","permalink":"/post/forward原样转发","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"C++模版","slug":"C-模版","count":4,"path":"api/categories/C-模版.json"}],"tags":[{"name":"原样转发","slug":"原样转发","count":1,"path":"api/tags/原样转发.json"},{"name":"模版","slug":"模版","count":4,"path":"api/tags/模版.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null},"next_post":{"title":"lambda表达式","uid":"85522d683e84dc82b51c41943dc59db8","slug":"lambda表达式","date":"2022-03-21T22:49:00.000Z","updated":"2024-05-31T03:08:41.325Z","comments":true,"path":"api/articles/lambda表达式.json","keywords":null,"cover":"img/c01.jpg","text":"lambda表达式又称为匿名表达式，是C11提出的新语法。[]存储lambda表达式要捕获的值，()内的参数为形参，可供外部调用传值...","permalink":"/post/lambda表达式","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"C++高级","slug":"C-高级","count":9,"path":"api/categories/C-高级.json"}],"tags":[{"name":"lambda表达式","slug":"lambda表达式","count":2,"path":"api/tags/lambda表达式.json"},{"name":"bind操作","slug":"bind操作","count":1,"path":"api/tags/bind操作.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null}}