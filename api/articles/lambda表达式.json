{"title":"lambda表达式","uid":"85522d683e84dc82b51c41943dc59db8","slug":"lambda表达式","date":"2022-03-21T22:49:00.000Z","updated":"2024-05-31T03:08:41.325Z","comments":true,"path":"api/articles/lambda表达式.json","keywords":null,"cover":"img/c01.jpg","content":"<h2 id=\"lambda表达式\">lambda表达式</h2>\n<p>lambda表达式又称为匿名表达式，是C11提出的新语法。[]存储lambda表达式要捕获的值，()内的参数为形参，可供外部调用传值。lambda表达式可以直接调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1  匿名调用</span><br><span class=\"line\">   [](string name)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       cout &lt;&lt; &quot;this is anonymous&quot; &lt;&lt; endl;</span><br><span class=\"line\">       cout &lt;&lt; &quot;hello &quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class=\"line\">   &#125;(&quot;zack&quot;);</span><br></pre></td></tr></table></figure>\n<p>上述代码定义了一个匿名函数后直接调用。我们可以通过auto初始化一个变量存储lambda表达式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 2 通过auto赋值</span><br><span class=\"line\">   auto fname = [](string name)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       cout &lt;&lt; &quot;this is auto  &quot; &lt;&lt; endl;</span><br><span class=\"line\">       cout &lt;&lt; &quot;hello &quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   fname(&quot;Rolin&quot;);</span><br></pre></td></tr></table></figure>\n<p>通过auto定义fname，然后存储了lambda表达式，之后调用fname即可。也可以通过函数指针的方式接受lambda表达式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef void (*P_NameFunc)(string name);</span><br><span class=\"line\">// 3 函数指针</span><br><span class=\"line\">P_NameFunc fname2 = [](string name)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;this is P_NameFunc &quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;hello &quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">fname2(&quot;Vivo&quot;);</span><br></pre></td></tr></table></figure>\n<p>P_NameFunc定义了fname2函数指针接受了lambda表达式。也可以通过function对象接受lambda表达式，function类是C11新增的语法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 4 function</span><br><span class=\"line\">    function&lt;void(string)&gt; funcName;</span><br><span class=\"line\">    funcName = [](string name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;this is function &quot; &lt;&lt; endl;</span><br><span class=\"line\">        cout &lt;&lt; &quot;hello &quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    funcName(&quot;Uncle Wang&quot;);</span><br></pre></td></tr></table></figure>\n<p>用一个function对象接受了lambda表达式，同样可以调用该function对象funcName达到调用lambda的效果。</p>\n<h2 id=\"谈谈lambda的捕获\">谈谈lambda的捕获</h2>\n<p>1 值捕获</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age = 33;</span><br><span class=\"line\">string name = &quot;zack&quot;;</span><br><span class=\"line\">int score = 100;</span><br><span class=\"line\">string job = &quot;softengineer&quot;;</span><br><span class=\"line\">//值捕获</span><br><span class=\"line\">[age, name](string name_)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; &quot; name is &quot; &lt;&lt; name &lt;&lt; &quot; self-name is &quot; &lt;&lt; name_ &lt;&lt; endl;</span><br><span class=\"line\">&#125;(&quot;Novia&quot;);</span><br></pre></td></tr></table></figure>\n<p>上述lambda表达式捕获了age和name，是以值的方式来捕获的。所以无法在lambda表达式内部修改age和name的值，如果修改age和name，编译器会报错，提示无法修改const常量，因为age和name是以值的方式被捕获的。 2 引用捕获</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age = 33;</span><br><span class=\"line\">string name = &quot;zack&quot;;</span><br><span class=\"line\">int score = 100;</span><br><span class=\"line\">string job = &quot;softengineer&quot;;</span><br><span class=\"line\">[&amp;age, &amp;name](string name_)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; &quot; name is &quot; &lt;&lt; name &lt;&lt; &quot; self-name is &quot; &lt;&lt; name_ &lt;&lt; endl;</span><br><span class=\"line\">    name = &quot;Xiao Li&quot;;</span><br><span class=\"line\">    age = 18;</span><br><span class=\"line\">&#125;(&quot;Novia&quot;);</span><br></pre></td></tr></table></figure>\n<p>[]里age和name前边添加了&amp;，此时age和name是以引用方式捕获的。所以可以在lambda表达式中修改age和name的值。 C++的lambda表达式虽然可以捕获局部变量的引用，达到类似闭包的效果，但不是真的闭包，golang和python等语言通过闭包捕获局部变量后可以增加局部变量的声明周期，C++无法做到这一点，所以下面的调用会出现崩溃。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;function&lt;void(string)&gt;&gt; vec_Funcs;</span><br><span class=\"line\">void use_lambda2()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int age = 33;</span><br><span class=\"line\">    string name = &quot;zack&quot;;</span><br><span class=\"line\">    int score = 100;</span><br><span class=\"line\">    string job = &quot;softengineer&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    vec_Funcs.push_back([age, name](string name_)</span><br><span class=\"line\">                        &#123;   cout &lt;&lt; &quot;this is value catch &quot; &lt;&lt; endl;</span><br><span class=\"line\">                            cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; &quot; name is &quot; &lt;&lt; name &lt;&lt; &quot; self-name is &quot; &lt;&lt; name_ &lt;&lt; endl; &#125;);</span><br><span class=\"line\">    //危险，不要捕获局部变量的引用</span><br><span class=\"line\">    vec_Funcs.push_back([&amp;age, &amp;name](string name_)</span><br><span class=\"line\">                        &#123;   cout &lt;&lt; &quot;this is referenc catch&quot; &lt;&lt; endl;</span><br><span class=\"line\">                            cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; &quot; name is &quot; &lt;&lt; name &lt;&lt; &quot; self-name is &quot; &lt;&lt; name_ &lt;&lt; endl; &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void use_lambda3()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (auto f : vec_Funcs)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        f(&quot;zack&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    use_lambda2();</span><br><span class=\"line\">    use_lambda3();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>use_lambda2中将lambda表达式存储在function类型的vector里，当use_lambda2结束后，里边的局部变量都被释放了，而vector中的lambda表达式还存储着局部变量的引用，在调用use_lambda3时调用lambda表达式，此时访问局部变量已经被释放了，所以导致程序崩溃。 3 全部用值捕获，name用引用捕获</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age = 33;</span><br><span class=\"line\">string name = &quot;zack&quot;;</span><br><span class=\"line\">int score = 100;</span><br><span class=\"line\">string job = &quot;softengineer&quot;;</span><br><span class=\"line\">[=, &amp;name]()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; &quot; name is &quot; &lt;&lt; name &lt;&lt; &quot; score is &quot; &lt;&lt; score &lt;&lt; &quot; job is &quot; &lt;&lt; job &lt;&lt; endl;</span><br><span class=\"line\">    name = &quot;Cui Hua&quot;;</span><br><span class=\"line\">&#125;();</span><br></pre></td></tr></table></figure>\n<p>通过=表示所有变量都以值的方式捕获，如果希望某个变量以引用方式捕获则单独在这个变量前加&amp;。 4 全部用引用捕获，只有name用值捕获</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age = 33;</span><br><span class=\"line\">string name = &quot;zack&quot;;</span><br><span class=\"line\">int score = 100;</span><br><span class=\"line\">string job = &quot;softengineer&quot;;</span><br><span class=\"line\">[&amp;, name]()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; &quot; name is &quot; &lt;&lt; name &lt;&lt; &quot; score is &quot; &lt;&lt; score &lt;&lt; &quot; job is &quot; &lt;&lt; job &lt;&lt; endl;</span><br><span class=\"line\">&#125;();</span><br></pre></td></tr></table></figure>\n<p>通过&amp;方式表示所有变量都已引用方式捕获，如果希望某个变量以值方式捕获则单独在这个变量前加=。</p>\n<h2 id=\"万能的function\">万能的function</h2>\n<p>我们可以用function存储形参和返回值相同的一类函数指针，可调用对象，lambda表达式等。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_function()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    list&lt;function&lt;void(string)&gt;&gt; list_Funcs;</span><br><span class=\"line\">    //存储函数对象</span><br><span class=\"line\">    list_Funcs.push_back(FuncObj());</span><br><span class=\"line\">    //存储lambda表达式</span><br><span class=\"line\">    list_Funcs.push_back([](string str)</span><br><span class=\"line\">                         &#123; cout &lt;&lt; &quot;this is lambda call &quot; &lt;&lt; str &lt;&lt; endl; &#125;);</span><br><span class=\"line\">    //存储全局函数</span><br><span class=\"line\">    list_Funcs.push_back(globalFun);</span><br><span class=\"line\"></span><br><span class=\"line\">    for (const auto &amp;f : list_Funcs)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        f(&quot;hello zack&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"bind操作\">bind操作</h2>\n<p>C11同样提供了bind操作，将原函数的几个参数通过bind绑定传值，返回一个新的可调用对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//绑定全局函数</span><br><span class=\"line\">auto newfun1 = bind(globalFun2, placeholders::_1, placeholders::_2, 98, &quot;worker&quot;);</span><br><span class=\"line\">//相当于调用globalFun2(&quot;Lily&quot;,22, 98,&quot;worker&quot;);</span><br><span class=\"line\">newfun1(&quot;Lily&quot;, 22);</span><br><span class=\"line\">//多传参数没有用，相当于调用globalFun2(&quot;Lucy&quot;,28, 98,&quot;worker&quot;);</span><br><span class=\"line\">newfun1(&quot;Lucy&quot;, 28, 100, &quot;doctor&quot;);</span><br><span class=\"line\">auto newfun2 = bind(globalFun2, &quot;zack&quot;, placeholders::_1, 100, placeholders::_2);</span><br><span class=\"line\">//相当于调用globalFun2(&quot;zack&quot;,33,100,&quot;engineer&quot;);</span><br><span class=\"line\">newfun2(33, &quot;engineer&quot;);</span><br><span class=\"line\">auto newfun3 = bind(globalFun2, &quot;zack&quot;, placeholders::_2, 100, placeholders::_1);</span><br><span class=\"line\">newfun3(&quot;coder&quot;, 33);</span><br></pre></td></tr></table></figure>\n<p>placeholders表示占位符，_1表示新生成函数的第一个参数, _2表示新生成函数的第二个参数，将这些参数传递给原函数达到占位的效果，原函数的其余参数通过bind绑定固定值。 接下来定义类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class BindTestClass</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    BindTestClass(int num_, string name_) : num(num_), name(name_) &#123;&#125;</span><br><span class=\"line\">    static void StaticFun(const string &amp;str, int age);</span><br><span class=\"line\">    void MemberFun(const string &amp;job, int score);</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    int num;</span><br><span class=\"line\">    string name;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>实现静态函数和成员函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void BindTestClass::StaticFun(const string &amp;str, int age)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;this is static function&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;name is &quot; &lt;&lt; str &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;age is &quot; &lt;&lt; age &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void BindTestClass::MemberFun(const string &amp;job, int score)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;this is member function&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;name is &quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;age is &quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;job is &quot; &lt;&lt; job &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;score is &quot; &lt;&lt; score &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们通过bind绑定静态成员函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//绑定类的静态成员函数,加不加&amp;都可以</span><br><span class=\"line\">// auto staticbind = bind(BindTestClass::StaticFun, placeholders::_1, 33);</span><br><span class=\"line\">auto staticbind = bind(&amp;BindTestClass::StaticFun, placeholders::_1, 33);</span><br><span class=\"line\">staticbind(&quot;zack&quot;);</span><br></pre></td></tr></table></figure>\n<p>新生成的staticbind函数可以直接传递一个参数zack就完成了调用。接下来用bind绑定成员函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BindTestClass bindTestClass(33, &quot;zack&quot;);</span><br><span class=\"line\">// 绑定类的成员函数,一定要传递对象给bind的第二个参数，可以是类对象，也可以是类对象的指针</span><br><span class=\"line\">// 如果要修改类成员，必须传递类对象的指针</span><br><span class=\"line\">auto memberbind = bind(&amp;BindTestClass::MemberFun, &amp;bindTestClass, placeholders::_1, placeholders::_2);</span><br><span class=\"line\">memberbind(&quot;coder&quot;, 100);</span><br><span class=\"line\"></span><br><span class=\"line\">auto memberbind2 = bind(&amp;BindTestClass::MemberFun, placeholders::_3, placeholders::_1, placeholders::_2);</span><br><span class=\"line\">memberbind2(&quot;coder&quot;, 100, &amp;bindTestClass);</span><br><span class=\"line\">//绑定类成员时，对象必须取地址</span><br><span class=\"line\">auto numbind = bind(&amp;BindTestClass::num, placeholders::_1);</span><br><span class=\"line\">std::cout &lt;&lt; numbind(bindTestClass) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<p>当然也可以直接用function对象接受bind返回的结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// function接受bind返回的函数</span><br><span class=\"line\">function&lt;void(int, string)&gt; funcbind = bind(globalFun2, &quot;zack&quot;, placeholders::_1, 100, placeholders::_2);</span><br><span class=\"line\">funcbind(33, &quot;engineer&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// function接受bind 成员函数</span><br><span class=\"line\">function&lt;void(string, int)&gt; funcbind2 = bind(&amp;BindTestClass::MemberFun, &amp;bindTestClass, placeholders::_1, placeholders::_2);</span><br><span class=\"line\">funcbind2(&quot;docker&quot;, 100);</span><br><span class=\"line\"></span><br><span class=\"line\">function&lt;void(string, int, BindTestClass *)&gt; funcbind3 = bind(&amp;BindTestClass::MemberFun, placeholders::_3, placeholders::_1, placeholders::_2);</span><br><span class=\"line\">funcbind3(&quot;driver&quot;, 100, &amp;bindTestClass);</span><br><span class=\"line\"></span><br><span class=\"line\">// function 直接接受成员函数,function的模板列表里第一个参数是类对象引用</span><br><span class=\"line\">function&lt;void(BindTestClass &amp;, const string &amp;, int)&gt; functomem = BindTestClass::MemberFun;</span><br><span class=\"line\">functomem(bindTestClass, &quot;functomem&quot;, 88);</span><br><span class=\"line\"></span><br><span class=\"line\">// function 绑定类的静态成员函数</span><br><span class=\"line\">function&lt;void(const string &amp;)&gt; funbindstatic = bind(&amp;BindTestClass::StaticFun, placeholders::_1, 33);</span><br><span class=\"line\">funbindstatic(&quot;Rolis&quot;);</span><br></pre></td></tr></table></figure>\n<p>lambda和bind的使用就介绍到这里 源码链接：<a href=\"https://gitee.com/secondtonone1/cpplearn\">https://gitee.com/secondtonone1/cpplearn</a> 视频链接: <a href=\"https://www.bilibili.com/video/BV15S4y1Y7no\">https://www.bilibili.com/video/BV15S4y1Y7no</a></p>\n","feature":null,"text":"lambda表达式又称为匿名表达式，是C11提出的新语法。[]存储lambda表达式要捕获的值，()内的参数为形参，可供外部调用传值...","permalink":"/post/lambda表达式","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"C++高级","slug":"C-高级","count":9,"path":"api/categories/C-高级.json"}],"tags":[{"name":"lambda表达式","slug":"lambda表达式","count":2,"path":"api/tags/lambda表达式.json"},{"name":"bind操作","slug":"bind操作","count":1,"path":"api/tags/bind操作.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">lambda表达式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B0%88%E8%B0%88lambda%E7%9A%84%E6%8D%95%E8%8E%B7\"><span class=\"toc-text\">谈谈lambda的捕获</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%87%E8%83%BD%E7%9A%84function\"><span class=\"toc-text\">万能的function</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bind%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">bind操作</span></a></li></ol>","author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"模版类的友元和折叠规则","uid":"a5369c7c25920ed05726c5cd9a2b6ec2","slug":"模板类的友元和折叠规则","date":"2022-03-28T16:49:00.000Z","updated":"2024-05-23T08:18:18.861Z","comments":true,"path":"api/articles/模板类的友元和折叠规则.json","keywords":null,"cover":"img/mo.jpg","text":"有时我们需要A类访问模板类B的私有成员，但是不想其他类访问，就要在模板类B里为A类声明友元。...","permalink":"/post/模板类的友元和折叠规则","photos":[],"count_time":{"symbolsCount":"7.2k","symbolsTime":"7 mins."},"categories":[{"name":"C++模版","slug":"C-模版","count":4,"path":"api/categories/C-模版.json"}],"tags":[{"name":"模版","slug":"模版","count":4,"path":"api/tags/模版.json"},{"name":"友元类","slug":"友元类","count":1,"path":"api/tags/友元类.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null},"next_post":{"title":"动态内存管理示例","uid":"6d811383cc30559af72f7dba87a5b6e3","slug":"动态内存管理示例","date":"2022-03-14T19:49:00.000Z","updated":"2024-05-23T07:42:59.155Z","comments":true,"path":"api/articles/动态内存管理示例.json","keywords":null,"cover":"img/c01.jpg","text":"之前我们讲述过动态内存的开辟，可以通过new, malloc，以及alloc等方式，本文通过介绍alloc方式，构造一个StrVec类...","permalink":"/post/动态内存管理示例","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"C++高级","slug":"C-高级","count":9,"path":"api/categories/C-高级.json"}],"tags":[{"name":"内存管理","slug":"内存管理","count":4,"path":"api/tags/内存管理.json"},{"name":"拷贝构造","slug":"拷贝构造","count":1,"path":"api/tags/拷贝构造.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null}}