{"title":"迭代器分类","uid":"e5cddefd1d930eb71bc590588a1288b4","slug":"迭代器分类","date":"2022-02-05T05:49:00.000Z","updated":"2024-05-31T01:31:10.540Z","comments":true,"path":"api/articles/迭代器分类.json","keywords":null,"cover":"img/fx.png","content":"<p>除了容器自定义的迭代器之外，标准库还提供了其他几种迭代器，包括插入迭代器，流迭代器，反向迭代器，移动迭代器。</p>\n<h2 id=\"插入迭代器\">插入迭代器</h2>\n<p>迭代器被绑定到一个容器上，可用来向容器插入元素。插入迭代器包括back_inserter, front_inserter, inserter三种。 back_inserter绑定到容器后，对该迭代器赋值，就执行了类似于push_back的操作，前提是该容器要支持push_back。 front_inserter绑定到容器后，对该迭代器赋值，就执行了类似于push_front的操作，前提是该容器支持push_front。 inserter创建一个使用insert的迭代器，此函数接受第二个参数必须是一个指向给定容器的迭代器，元素被插入到给定迭代器所表示的元素之前。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_inserter()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    list&lt;int&gt; list1 = &#123;1, 2, 3, 4&#125;;</span><br><span class=\"line\">    list&lt;int&gt; list2, list3, list4;</span><br><span class=\"line\">    copy(list1.begin(), list1.end(), front_inserter(list2));</span><br><span class=\"line\">    copy(list1.begin(), list1.end(), back_inserter(list3));</span><br><span class=\"line\">    copy(list1.begin(), list1.end(), inserter(list4, list4.begin()));</span><br><span class=\"line\"></span><br><span class=\"line\">    for_each(list2.begin(), list2.end(), [](const int &amp;i)</span><br><span class=\"line\">             &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;);</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    for_each(list3.begin(), list3.end(), [](const int &amp;i)</span><br><span class=\"line\">             &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;);</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    for_each(list4.begin(), list4.end(), [](const int &amp;i)</span><br><span class=\"line\">             &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;);</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4 3 2 1</span><br><span class=\"line\">1 2 3 4</span><br><span class=\"line\">1 2 3 4</span><br></pre></td></tr></table></figure>\n<h2 id=\"iostream迭代器\">iostream迭代器</h2>\n<p>istream_iterator 读取输入流，ostream_iterator 向一个输出流写数据。 这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。 通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。 我们先看看输入流的操作:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_istreamiter()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //输入流迭代器</span><br><span class=\"line\">    istream_iterator&lt;int&gt; in_int(cin);</span><br><span class=\"line\">    //迭代器终止标记</span><br><span class=\"line\">    istream_iterator&lt;int&gt; in_eof;</span><br><span class=\"line\">    vector&lt;int&gt; in_vec;</span><br><span class=\"line\">    while (in_int != in_eof)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        in_vec.push_back(*in_int++);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for_each(in_vec.begin(), in_vec.end(), [](const int &amp;i)</span><br><span class=\"line\">             &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;);</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码创建了输入流迭代器in_int，绑定了cin。 同时生成了一个输入流的结尾迭代器in_eof，in_eof未绑定任何输入流，所以是输入流的终止。 通过循环将输入流数据写入in_vec中。 再看看输出流的操作:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_ostreamiter()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vector&lt;int&gt; in_vec = &#123;1, 3, 4, 2, 5, 6, 7, 9&#125;;</span><br><span class=\"line\">    ostream_iterator&lt;int&gt; out_in(cout, &quot; &quot;);</span><br><span class=\"line\">    for (auto data : in_vec)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        *out_in++ = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出流迭代器out_in和cout绑定，并且为每一个输出的元素设置了空格间隔。 通过向*out_in赋值达到向cout写入数据的目的，同时out_in++保证了迭代器的后移。</p>\n<h2 id=\"反向迭代器\">反向迭代器</h2>\n<p>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个元素；递减一个迭代器（–it）会移动到下一个元素 cbegin和cend表示正向迭代器，crbegin和crend表示反向迭代器,如下图 <a href=\"https://cdn.llfc.club/1641885505%281%29.jpg\"><img src=\"https://cdn.llfc.club/1641885505%281%29.jpg\" alt=\"https://cdn.llfc.club/1641885505(1).jpg\"></a> 我们通过反向迭代器逆序打印原容器中的数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_reverseiter()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vector&lt;int&gt; in_vec = &#123;1, 3, 4, 2, 5, 6, 7, 9&#125;;</span><br><span class=\"line\">    for (auto rit = in_vec.crbegin(); rit != in_vec.crend(); rit++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; *rit &lt;&lt; &quot; &quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序输出9 7 6 5 2 4 3 1 我们知道sort默认规则是从小到大，如果我们想实现从大到小，可以利用反向迭代器完成</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort(vec.rbegin(), vec.rend());</span><br></pre></td></tr></table></figure>\n<p>反向迭代器遍历是从后往前，这一点也会造成一些不必要的问题</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string line = &quot;FIRST,MIDDLE,LAST&quot;;</span><br><span class=\"line\">auto rcomma = find(line.crbegin(), line.crend(), &#x27;,&#x27;);</span><br><span class=\"line\">cout &lt;&lt; string(line.crbegin(), rcomma) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<p>上述代码会找到最后一个逗号，获取crbegin和rcomma之间的数据实际是TSAL,也就是说反向迭代器遍历是反向的。 标准库提供了一个将反向迭代器转化为正向迭代器的方法base()</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//通过base将反向迭代器转化为正向的</span><br><span class=\"line\">cout &lt;&lt; string(rcomma.base(), line.cend()) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<p>程序输出LAST 大家可以看一下正向迭代器和反向迭代器的关系图 <a href=\"https://cdn.llfc.club/1641887218.jpg\"><img src=\"https://cdn.llfc.club/1641887218.jpg\" alt=\"https://cdn.llfc.club/1641887218.jpg\"></a></p>\n","feature":null,"text":"除了容器自定义的迭代器之外，标准库还提供了其他几种迭代器，包括插入迭代器，流迭代器，反向迭代器，移动迭代器。...","permalink":"/post/迭代器分类","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"泛型用法","slug":"泛型用法","count":3,"path":"api/categories/泛型用法.json"}],"tags":[{"name":"迭代器","slug":"迭代器","count":2,"path":"api/tags/迭代器.json"},{"name":"插入迭代器","slug":"插入迭代器","count":1,"path":"api/tags/插入迭代器.json"},{"name":"方向迭代器","slug":"方向迭代器","count":1,"path":"api/tags/方向迭代器.json"},{"name":"iostream迭代器","slug":"iostream迭代器","count":1,"path":"api/tags/iostream迭代器.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">插入迭代器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#iostream%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">iostream迭代器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">反向迭代器</span></a></li></ol>","author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"shared_ptr","uid":"a6d831861235c2eb17093e31fa78d0c7","slug":"shared_ptr","date":"2022-02-14T02:49:00.000Z","updated":"2024-05-23T07:20:46.310Z","comments":true,"path":"api/articles/shared_ptr.json","keywords":null,"cover":"img/point.png","text":"C++提供了对指针操作的方法，当我们用new开辟指定类型的空间后，就生成了一个指针。...","permalink":"/post/shared_ptr","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"智能指针","slug":"智能指针","count":4,"path":"api/categories/智能指针.json"}],"tags":[{"name":"指针","slug":"指针","count":2,"path":"api/tags/指针.json"},{"name":"shared_ptr","slug":"shared-ptr","count":1,"path":"api/tags/shared-ptr.json"},{"name":"reset","slug":"reset","count":1,"path":"api/tags/reset.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null},"next_post":{"title":"泛型定制","uid":"72f8e112b71c8b55e9acbece39e8eb93","slug":"泛型定制","date":"2022-01-25T05:49:00.000Z","updated":"2024-05-23T07:10:49.990Z","comments":true,"path":"api/articles/泛型定制.json","keywords":null,"cover":"img/fx.png","text":"默认情况下，泛型算法还实现了另外一个版本，就是接受一个额外的参数。...","permalink":"/post/泛型定制","photos":[],"count_time":{"symbolsCount":"9.8k","symbolsTime":"9 mins."},"categories":[{"name":"泛型用法","slug":"泛型用法","count":3,"path":"api/categories/泛型用法.json"}],"tags":[{"name":"lambda表达式","slug":"lambda表达式","count":2,"path":"api/tags/lambda表达式.json"},{"name":"泛型","slug":"泛型","count":2,"path":"api/tags/泛型.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null}}