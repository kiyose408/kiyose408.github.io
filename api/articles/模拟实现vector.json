{"title":"模拟实现vector","uid":"5ac0cfc2a03b63f31f1f39881eb54b11","slug":"模拟实现vector","date":"2022-04-16T14:49:00.000Z","updated":"2024-05-23T08:28:33.332Z","comments":true,"path":"api/articles/模拟实现vector.json","keywords":null,"cover":"img/mo.jpg","content":"<h2 id=\"模拟vector\"><a href=\"#模拟vector\" class=\"headerlink\" title=\"模拟vector\"></a>模拟vector</h2><p>我们可以通过模板实现类似vector的类。我们实现一个StrVecTemp类，其内部通过allocator开辟空间，存储的类型用T来表示，T是模板类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class StrVecTemp</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    StrVecTemp() : elements(nullptr), first_free(nullptr),</span><br><span class=\"line\">                   cap(nullptr) &#123;&#125;</span><br><span class=\"line\">    //拷贝构造函数</span><br><span class=\"line\">    StrVecTemp(const StrVecTemp &amp;);</span><br><span class=\"line\">    //拷贝赋值运算符</span><br><span class=\"line\">    StrVecTemp &amp;operator=(const StrVecTemp &amp;);</span><br><span class=\"line\">    //移动构造函数</span><br><span class=\"line\">    StrVecTemp(StrVecTemp &amp;&amp;src) noexcept : elements(src.elements),</span><br><span class=\"line\">                                            first_free(src.first_free), cap(src.cap)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //将源数据置空</span><br><span class=\"line\">        src.elements = src.first_free = src.cap = nullptr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    template &lt;class... Args&gt;</span><br><span class=\"line\">    void emplace_back(Args &amp;&amp;...args);</span><br><span class=\"line\"></span><br><span class=\"line\">    //析构函数</span><br><span class=\"line\">    ~StrVecTemp();</span><br><span class=\"line\">    //拷贝元素</span><br><span class=\"line\">    void push_back(const T &amp;);</span><br><span class=\"line\">    //抛出元素</span><br><span class=\"line\">    void pop_back(T &amp;s);</span><br><span class=\"line\">    //返回元素个数</span><br><span class=\"line\">    size_t size() const &#123; return first_free - elements; &#125;</span><br><span class=\"line\">    //返回capacity返回容量</span><br><span class=\"line\">    size_t capacity() const &#123; return cap - elements; &#125;</span><br><span class=\"line\">    //返回首元素的指针</span><br><span class=\"line\">    T *begin() const</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return elements;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //返回第一个空闲元素指针</span><br><span class=\"line\">    T *end() const</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return first_free;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    //判断容量不足靠皮新空间</span><br><span class=\"line\">    void chk_n_alloc()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (size() == capacity())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            reallocate();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //重新开辟空间</span><br><span class=\"line\">    void reallocate();</span><br><span class=\"line\">    // copy指定范围的元素到新的内存中</span><br><span class=\"line\">    std::pair&lt;T *, T *&gt; alloc_n_copy(const T *, const T *);</span><br><span class=\"line\">    //释放空间</span><br><span class=\"line\">    void free();</span><br><span class=\"line\">    //数组首元素的指针</span><br><span class=\"line\">    T *elements;</span><br><span class=\"line\">    //指向数组第一个空闲元素的指针</span><br><span class=\"line\">    T *first_free;</span><br><span class=\"line\">    //指向数组尾后位置的指针</span><br><span class=\"line\">    T *cap;</span><br><span class=\"line\">    //初始化alloc用来分配空间</span><br><span class=\"line\">    static std::allocator&lt;T&gt; alloc;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">std::allocator&lt;T&gt; StrVecTemp&lt;T&gt;::alloc;</span><br></pre></td></tr></table></figure>\n\n<p>alloc在使用前要在类外初始化，因为是模板类，所以放在.h中初始化即可。 接下来我们要实现根据迭代器开始和结束的区间copy旧元素到新的空间里</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//实现区间copy</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">std::pair&lt;T *, T *&gt; StrVecTemp&lt;T&gt;::alloc_n_copy(const T *b, const T *e)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    auto newdata = alloc.allocate(e - b);</span><br><span class=\"line\">    //用旧的数据初始化新的空间</span><br><span class=\"line\">    auto first_free = uninitialized_copy(b, e, newdata);</span><br><span class=\"line\">    return &#123;newdata, first_free&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现copy构造</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//实现拷贝构造函数</span><br><span class=\"line\">template &lt;class T&gt;</span><br><span class=\"line\">StrVecTemp&lt;T&gt;::StrVecTemp(const StrVecTemp &amp;strVec)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    auto rsp = alloc_n_copy(strVec.begin(), strVec.end());</span><br><span class=\"line\">    //利用pair类型更新elements, cap, first_free</span><br><span class=\"line\">    elements = rsp.first;</span><br><span class=\"line\">    first_free = rsp.second;</span><br><span class=\"line\">    cap = rsp.second;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现copy赋值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//拷贝赋值运算符</span><br><span class=\"line\">template &lt;class T&gt;</span><br><span class=\"line\">StrVecTemp&lt;T&gt; &amp;StrVecTemp&lt;T&gt;::operator=(const StrVecTemp &amp;strVec)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (this == &amp;strVec)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //如果不是自赋值，就将形参copy给自己</span><br><span class=\"line\">    auto rsp = alloc_n_copy(strVec.begin(), strVec.end());</span><br><span class=\"line\">    elements = rsp.first;</span><br><span class=\"line\">    first_free = rsp.second;</span><br><span class=\"line\">    cap = rsp.second;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>析构函数要先销毁数据再回收内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//析构函数</span><br><span class=\"line\">template &lt;class T&gt;</span><br><span class=\"line\">StrVecTemp&lt;T&gt;::~StrVecTemp()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //判断elements是否为空</span><br><span class=\"line\">    if (elements == nullptr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //缓存第一个有效元素的地址</span><br><span class=\"line\">    auto dest = elements;</span><br><span class=\"line\">    //循环析构</span><br><span class=\"line\">    for (size_t i = 0; i &lt; size(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //析构每一个元素</span><br><span class=\"line\">        alloc.destroy(dest++);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //再回收内存</span><br><span class=\"line\">    alloc.deallocate(elements, cap - elements);</span><br><span class=\"line\">    elements = nullptr;</span><br><span class=\"line\">    cap = nullptr;</span><br><span class=\"line\">    first_free = nullptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重新开辟空间</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class T&gt;</span><br><span class=\"line\">void StrVecTemp&lt;T&gt;::reallocate()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    T *newdata = nullptr;</span><br><span class=\"line\">    //数组为空的情况</span><br><span class=\"line\">    if (elements == nullptr || cap == nullptr || first_free == nullptr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        newdata = alloc.allocate(1);</span><br><span class=\"line\">        elements = newdata;</span><br><span class=\"line\">        first_free = newdata;</span><br><span class=\"line\">        // cap指向数组尾元素的下一个位置</span><br><span class=\"line\">        cap = newdata + 1;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //原数据不为空，则扩充size两倍大小</span><br><span class=\"line\">    newdata = alloc.allocate(size() * 2);</span><br><span class=\"line\">    //新内存空闲位置</span><br><span class=\"line\">    auto dest = newdata;</span><br><span class=\"line\">    //就内存的有效位置</span><br><span class=\"line\">    auto src = elements;</span><br><span class=\"line\">    //通过移动操作将旧数据放到新内存中</span><br><span class=\"line\">    for (size_t i = 0; i != size(); ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        alloc.construct(dest++, std::move(*src++));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //移动完旧数据后一定要删除</span><br><span class=\"line\">    free();</span><br><span class=\"line\">    //更新数据位置</span><br><span class=\"line\">    elements = newdata;</span><br><span class=\"line\">    first_free = dest;</span><br><span class=\"line\">    cap = newdata + size() * 2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的函数用到了free函数，我们自己实现一个free</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void StrVecTemp&lt;T&gt;::free()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //先判断elements是否为空</span><br><span class=\"line\">    if (elements == nullptr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    auto dest = elements;</span><br><span class=\"line\">    //遍历析构每一个对象</span><br><span class=\"line\">    for (size_t i = 0; i &lt; size(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // destroy 会析构每一个元素</span><br><span class=\"line\">        alloc.destroy(dest++);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //再整体回收内存</span><br><span class=\"line\">    alloc.deallocate(elements, cap - elements);</span><br><span class=\"line\">    elements = nullptr;</span><br><span class=\"line\">    cap = nullptr;</span><br><span class=\"line\">    first_free = nullptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>压入元素和弹出元素</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//拷贝元素</span><br><span class=\"line\">template &lt;class T&gt;</span><br><span class=\"line\">void StrVecTemp&lt;T&gt;::push_back(const T &amp;t)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    chk_n_alloc();</span><br><span class=\"line\">    alloc.construct(first_free++, t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//抛出元素</span><br><span class=\"line\">template &lt;class T&gt;</span><br><span class=\"line\">void StrVecTemp&lt;T&gt;::pop_back(T &amp;s)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //先判断是否为空</span><br><span class=\"line\">    if (first_free == nullptr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //判断size为1</span><br><span class=\"line\">    if (size() == 1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        s = *elements;</span><br><span class=\"line\">        alloc.destroy(elements);</span><br><span class=\"line\">        first_free = nullptr;</span><br><span class=\"line\">        elements = nullptr;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    s = *(--first_free);</span><br><span class=\"line\">    alloc.destroy(first_free);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来要实现emplace_back，因为emplace_back支持多种构造函数的参数，所以要用模板参数列表的方式定义该函数。 模板参数列表和形参列表都要用参数包的方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;class T&gt;</span><br><span class=\"line\">template &lt;class... Args&gt;</span><br><span class=\"line\">void StrVecTemp&lt;T&gt;::emplace_back(Args &amp;&amp;...args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    chk_n_alloc();</span><br><span class=\"line\">    alloc.construct(first_free++, forward&lt;Args&gt;(args)...);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Args是模板参数包，args是参数列表。因为construct的参数可能为右值引用，所以要用forward将原参数列表类型原样转发。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// forward既扩展了模板参数包Args，又扩展了函数参数包args</span><br><span class=\"line\">// std::forward&lt;Args&gt;(args)... 等价于std::forward&lt;Ti&gt;(ti)</span><br><span class=\"line\"></span><br><span class=\"line\">//比如传递给emplace_back(10,&#x27;c&#x27;);</span><br><span class=\"line\">//相当于调用 alloc.construct(first_free++, forward&lt;int&gt;(10), forward&lt;char&gt;(&#x27;c&#x27;))</span><br><span class=\"line\">//调用的就是插入cccccccccc</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文模拟实现了vector的功能。 视频链接<a href=\"https://www.bilibili.com/video/BV1ES4y187Yc/?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9\">https://www.bilibili.com/video/BV1Et4y1p73a/?vd_source&#x3D;8be9e83424c2ed2c9b2a3ed1d01385e9</a> 源码链接 <a href=\"https://gitee.com/secondtonone1/cpplearn\">https://gitee.com/secondtonone1/cpplearn</a></p>\n","feature":null,"text":"我们可以通过模板实现类似vector的类。我们实现一个StrVecTemp类，其内部通过allocator开辟空间...","permalink":"/post/模拟实现vector","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"C++模版","slug":"C-模版","count":4,"path":"api/categories/C-模版.json"}],"tags":[{"name":"模版","slug":"模版","count":4,"path":"api/tags/模版.json"},{"name":"模拟","slug":"模拟","count":1,"path":"api/tags/模拟.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%8B%9Fvector\"><span class=\"toc-text\">模拟vector</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"模版特例化","uid":"698bdaa973d597a4a390a291dbaefc44","slug":"模版特例化","date":"2022-04-21T15:49:00.000Z","updated":"2024-05-23T08:26:22.610Z","comments":true,"path":"api/articles/模版特例化.json","keywords":null,"cover":"img/mo.jpg","text":"模板特例化主要是用于在模板特定情况下的一些特殊定义...","permalink":"/post/模版特例化","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"C++模版","slug":"C-模版","count":4,"path":"api/categories/C-模版.json"}],"tags":[{"name":"模版","slug":"模版","count":4,"path":"api/tags/模版.json"},{"name":"特例化","slug":"特例化","count":1,"path":"api/tags/特例化.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null},"next_post":{"title":"foward原样转发","uid":"7840d4003f29222bf6cd12a2077991b7","slug":"forward原样转发","date":"2022-04-08T11:49:00.000Z","updated":"2024-05-23T08:27:33.771Z","comments":true,"path":"api/articles/forward原样转发.json","keywords":null,"cover":"img/mo.jpg","text":"前文我们实现了一个my_move函数，用来模拟stl的move操作，实现去引用的功能。其内部的原理就是通过remove_reference实现去引用操作。...","permalink":"/post/forward原样转发","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"C++模版","slug":"C-模版","count":4,"path":"api/categories/C-模版.json"}],"tags":[{"name":"原样转发","slug":"原样转发","count":1,"path":"api/tags/原样转发.json"},{"name":"模版","slug":"模版","count":4,"path":"api/tags/模版.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null}}