{"title":"foward原样转发","uid":"7840d4003f29222bf6cd12a2077991b7","slug":"forward原样转发","date":"2022-04-08T11:49:00.000Z","updated":"2024-05-23T08:27:33.771Z","comments":true,"path":"api/articles/forward原样转发.json","keywords":null,"cover":"img/mo.jpg","content":"<h2 id=\"原样转发的意义\"><a href=\"#原样转发的意义\" class=\"headerlink\" title=\"原样转发的意义\"></a>原样转发的意义</h2><p>前文我们实现了一个my_move函数，用来模拟stl的move操作，实现去引用的功能。其内部的原理就是通过remove_reference实现去引用操作。 有时我们也需要保留原类型的左值或者右值属性，进行原样转发，此时就要用forward实现转发功能。 我们先定义一个模板函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename F, typename T1, typename T2&gt;</span><br><span class=\"line\">void flip1(F f, T1 t1, T2 t2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    f(t2, t1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>flip1内部调用了函数f 我们写一个函数测试</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">void ftemp(int v1, int &amp;v2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; v1 &lt;&lt; &quot; &quot; &lt;&lt; ++v2 &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void use_ftemp()&#123;</span><br><span class=\"line\">    int j = 100;</span><br><span class=\"line\">    int i = 99;</span><br><span class=\"line\">    flip1(ftemp, j, 42);</span><br><span class=\"line\">    cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过打印发现i和j的值没有变化，因为ftemp的v2参数虽然是引用，但是是flip1的形参t1的引用 t1只是形参，修改t1并不能影响外边的实参j。 想要达到修改实参的目的，需要将flip1的参数修改为引用，我们先实现修改后的版本flip2</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename F, typename T1, typename T2&gt;</span><br><span class=\"line\">void flip2(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    f(t2, t1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们定义了一个flip2函数，t1和t2分别是右值引用类型。接下来用一个测试函数进行测试</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int j = 100;</span><br><span class=\"line\">int i = 99;</span><br><span class=\"line\">flip2(ftemp, j, 42);</span><br><span class=\"line\">cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<p>这次我们发现j被修改了，因为flip2的t1参数类型为T1的右值引用，当把实参j赋值给flip2时，T1变为int&amp;, t1的类型就是int&amp; &amp;&amp;，通过折叠t1变为int&amp;类型。这样t1就和实参j绑定了，在flip2内部修改t1，就达到了修改j的目的。 但是flip2同样存在一个问题，如果flip2的第一个参数f，如果f是一个接受右值引用参数的函数，会出现编译错误。 为说明这一点，我们实现一个接纳模板参数右值引用类型的函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void gtemp(int &amp;&amp;i, int &amp;j)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时如果我们将gtemp作为参数传递给flip2会报错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int j = 100;</span><br><span class=\"line\">int i = 99;</span><br><span class=\"line\">// flip2(gtemp, j, 42) 会报错</span><br><span class=\"line\">// 因为42作为右值纯递给flip2，t2会被折叠为int&amp;类型</span><br><span class=\"line\">// t2传递给gtemp第一个参数时，int&amp;&amp;无法绑定int&amp;类型</span><br><span class=\"line\">//flip2(gtemp, i, 42);</span><br><span class=\"line\">cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class=\"line\">```t</span><br><span class=\"line\">当我们将42传递给flip2第二个参数时，T2被实例化为int类型，t2就变为int &amp;&amp; 类型，通过折叠t2变为int&amp;类型。</span><br><span class=\"line\">t2作为参数传递给gtemp的第一个参数时会报错，</span><br><span class=\"line\">cannot bind rvalue reference of type &#x27;int&amp;&amp;&#x27; to lvalue of type &#x27;int&#x27;</span><br><span class=\"line\">因为t2是一个左值，右值无法绑定该左值。</span><br><span class=\"line\"></span><br><span class=\"line\">上面的错误可以简化为</span><br><span class=\"line\">``` cpp</span><br><span class=\"line\">int i = 100;</span><br><span class=\"line\">int&amp;&amp; m = 200;</span><br><span class=\"line\">int&amp;&amp; k =  m;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码仍然会报错，无法将k这个右值引用绑定到m这个左值上。 解决的办法很简单</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 100;</span><br><span class=\"line\">int&amp;&amp; m = 200;</span><br><span class=\"line\">int&amp;&amp; k = int(m);</span><br></pre></td></tr></table></figure>\n\n<p>通过int强制类型转换，这是一个表达式得出的就是右值。当然也可以通过如下方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 100;</span><br><span class=\"line\">int&amp;&amp; m = 200;</span><br><span class=\"line\">int&amp;&amp; k = std::move(m);</span><br></pre></td></tr></table></figure>\n\n<p>总之就是通过表达式将m转化为右值即可。所以大家要清楚的是及时m是一个int&amp;&amp;类型，但是它本身是一个左值。 综上所述，上面问题的解决的办法就是实现一个flip函数，内部实现对T2，T1类型的原样转发。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename F, typename T1, typename T2&gt;</span><br><span class=\"line\">void flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过forward将t2类型转化为和T2类型一样的类型，也就是int的右值类型，接下来的调用就不会出问题了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_ftemp()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int j = 100;</span><br><span class=\"line\">    int i = 99;</span><br><span class=\"line\">    flip(gtemp, i, 42);</span><br><span class=\"line\">    cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot; j is &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模板的可变参数\"><a href=\"#模板的可变参数\" class=\"headerlink\" title=\"模板的可变参数\"></a>模板的可变参数</h2><p>模板同样支持可变参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//可变参数的函数模板</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">ostream &amp;print(ostream &amp;os, const T &amp;t)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return os &lt;&lt; t; //输出最后一个元素</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T, typename... Args&gt;</span><br><span class=\"line\">ostream &amp;print(ostream &amp;os, const T &amp;t, const Args &amp;...rest)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    os &lt;&lt; t &lt;&lt; &quot;, &quot;;</span><br><span class=\"line\">    return print(os, rest...);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Args是可变的模板参数包， 然后再用Args定义rest变量，这是一个可变参数列表。 我们的模板函数print内部调用stl的print函数，通过对rest…实现展开操作。 调用过程可按如下的方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_printtemp()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i = 100;</span><br><span class=\"line\">    string s = &quot;hello zack!!!&quot;;</span><br><span class=\"line\">    print(cout, i, s, 42);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一次调用print实际是调用的可变参数的print，之后才调用没有可变参数的print函数。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文介绍了模板类型的原样转发，以及多模板参数列表的使用。 视频链接<a href=\"https://www.bilibili.com/video/BV1ES4y187Yc/?vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9\">https://www.bilibili.com/video/BV1ES4y187Yc/?vd_source&#x3D;8be9e83424c2ed2c9b2a3ed1d01385e9</a> 源码链接 <a href=\"https://gitee.com/secondtonone1/cpplearn\">https://gitee.com/secondtonone1/cpplearn</a></p>\n","feature":null,"text":"前文我们实现了一个my_move函数，用来模拟stl的move操作，实现去引用的功能。其内部的原理就是通过remove_reference实现去引用操作。...","permalink":"/post/forward原样转发","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"C++模版","slug":"C-模版","count":4,"path":"api/categories/C-模版.json"}],"tags":[{"name":"原样转发","slug":"原样转发","count":1,"path":"api/tags/原样转发.json"},{"name":"模版","slug":"模版","count":4,"path":"api/tags/模版.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E6%A0%B7%E8%BD%AC%E5%8F%91%E7%9A%84%E6%84%8F%E4%B9%89\"><span class=\"toc-text\">原样转发的意义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">模板的可变参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"模拟实现vector","uid":"5ac0cfc2a03b63f31f1f39881eb54b11","slug":"模拟实现vector","date":"2022-04-16T14:49:00.000Z","updated":"2024-05-23T08:28:33.332Z","comments":true,"path":"api/articles/模拟实现vector.json","keywords":null,"cover":"img/mo.jpg","text":"我们可以通过模板实现类似vector的类。我们实现一个StrVecTemp类，其内部通过allocator开辟空间...","permalink":"/post/模拟实现vector","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"C++模版","slug":"C-模版","count":4,"path":"api/categories/C-模版.json"}],"tags":[{"name":"模版","slug":"模版","count":4,"path":"api/tags/模版.json"},{"name":"模拟","slug":"模拟","count":1,"path":"api/tags/模拟.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null},"next_post":{"title":"模版类的友元和折叠规则","uid":"a5369c7c25920ed05726c5cd9a2b6ec2","slug":"模板类的友元和折叠规则","date":"2022-03-28T16:49:00.000Z","updated":"2024-05-23T08:18:18.861Z","comments":true,"path":"api/articles/模板类的友元和折叠规则.json","keywords":null,"cover":"img/mo.jpg","text":"有时我们需要A类访问模板类B的私有成员，但是不想其他类访问，就要在模板类B里为A类声明友元。...","permalink":"/post/模板类的友元和折叠规则","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"C++模版","slug":"C-模版","count":4,"path":"api/categories/C-模版.json"}],"tags":[{"name":"模版","slug":"模版","count":4,"path":"api/tags/模版.json"},{"name":"友元类","slug":"友元类","count":1,"path":"api/tags/友元类.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null}}