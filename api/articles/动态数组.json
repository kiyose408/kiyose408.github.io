{"title":"动态数组","uid":"adc37eeabf3d5d5cb2363096a2fd87f2","slug":"动态数组","date":"2022-03-02T15:49:00.000Z","updated":"2024-05-23T07:21:56.736Z","comments":true,"path":"api/articles/动态数组.json","keywords":null,"cover":"img/point.png","content":"<p>C++语言和标准库提供了两种一次分配一个对象数组的方法。C++语言定义了另一种new表达式语法，可以分配并初始化一个对象数组。标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。</p>\n<h2 id=\"new和数组\"><a href=\"#new和数组\" class=\"headerlink\" title=\"new和数组\"></a>new和数组</h2><p>为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目。在下例中，new分配要求数量的对象并（假定分配成功后）返回指向第一个对象的指针：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int get_size_new()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return 42;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void new_array()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int *p_array = new int[get_size_new()]();</span><br><span class=\"line\">    for (int i = 0; i &lt; get_size_new(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; *(p_array + i) &lt;&lt; &quot; &quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    delete[] p_array;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在main函数中调用new_array会输出42个0,因为new 分配的数组初始值都为0。 为了释放动态数组，我们使用一种特殊形式的delete——在指针前加上一个空方括号对. 方括号中的大小必须是整型，但不必是常量。也可以用一个表示数组类型的类型别名，来分配一个数组，这样，new表达式中就不需要方括号了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void new_array()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //定义数组类型</span><br><span class=\"line\">    typedef int array_type[10];</span><br><span class=\"line\">    //动态开辟数组空间</span><br><span class=\"line\">    int *p_array = new (array_type);</span><br><span class=\"line\">    delete[] p_array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然我们通常称<code>new T[]</code>分配的内存为“动态数组”，但这种叫法某种程度上有些误导。 当用new分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。 即使我们使用类型别名定义了一个数组类型，new也不会分配一个数组类型的对象。new返回的是一个元素类型的指针。 由于分配的内存并不是一个数组类型，因此不能对动态数组调用begin或end。 要记住我们所说的动态数组并不是数组类型，这是很重要的。 可以通过{}初始化动态数组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void new_array()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //通过&#123;&#125;初始化动态数组</span><br><span class=\"line\">    int *p_array = new int[10]&#123;1, 2, 3, 4&#125;;</span><br><span class=\"line\">    //释放动态数组</span><br><span class=\"line\">    delete[] p_array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果{}初始化列表小于数组长度，则默认补充空值，int补充0，string补充空字符串。 动态分配一个大小为0的数组是合法的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void new_array()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int n = 0;</span><br><span class=\"line\">    //开辟一个大小为0的数组</span><br><span class=\"line\">    int *p_array = new int[n];</span><br><span class=\"line\">    for (int *p = p_array; p != n + p_array; p++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; *p &lt;&lt; &quot; &quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    delete[] p_array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当n为0时，开辟了一个长度为0的动态数组，因为循环条件p !&#x3D; n+p_array，所以不会进入循环。 当我们用new分配一个大小为0的数组时，new返回一个合法的非空指针。此指针保证与new返回的其他任何指针都不相同。 对于零长度的数组来说，此指针就像尾后指针一样，我们可以像使用尾后迭代器一样使用这个指针。 可以用此指针进行比较操作，就像上面循环代码中那样。可以向此指针加上（或从此指针减去）0，也可以从此指针减去自身从而得到0。但此指针不能解引用——毕竟它不指向任何元素。</p>\n<h2 id=\"智能指针和动态数组\"><a href=\"#智能指针和动态数组\" class=\"headerlink\" title=\"智能指针和动态数组\"></a>智能指针和动态数组</h2><p>标准库提供了一个可以管理new分配的数组的unique_ptr版本。为了用一个unique_ptr管理动态数组，我们必须在对象类型后面跟一对空方括号：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void unique_array()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //开辟一个20个整形的动态数组，用unique_ptr管理它。</span><br><span class=\"line\">    auto unarray = unique_ptr&lt;int[]&gt;(new int[20]);</span><br><span class=\"line\">    //释放这个动态数组</span><br><span class=\"line\">    unarray.release();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类型说明符中的方括号<code>&lt;int[]&gt;</code>指出up指向一个int数组而不是一个int。由于unarray指向一个数组，当unarray销毁它管理的指针时，会自动使用delete[]。 当一个unique_ptr指向一个数组时，我们可以使用下标运算符来访问数组中的元素：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void unique_array()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //开辟一个20个整形的动态数组，用unique_ptr管理它。</span><br><span class=\"line\">    auto unarray = unique_ptr&lt;int[]&gt;(new int[20]);</span><br><span class=\"line\"></span><br><span class=\"line\">    //可以通过下标访问数组元素</span><br><span class=\"line\">    for (size_t i = 0; i &lt; 10; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        unarray[i] = 1024;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //释放这个动态数组</span><br><span class=\"line\">    unarray.release();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>shared_ptr也可以管理动态数组，这一点在C++ primer 第5版里没有提及，但是我自己测试好用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void shared_array()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 开辟一个5个整形的动态数组，用shared_ptr管理它</span><br><span class=\"line\">    auto sharray = shared_ptr&lt;int[]&gt;(new int[5]&#123;1, 2, 3, 4, 5&#125;);</span><br><span class=\"line\">    for (int i = 0; i &lt; 5; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; sharray[i] &lt;&lt; &quot; &quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sharray.reset();</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>C++ primer 第5版推荐的用法如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_shared_array()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    shared_ptr&lt;int&gt; sharray = shared_ptr&lt;int&gt;(new int[5], [](int *p)</span><br><span class=\"line\">                                              &#123; delete[] p; &#125;);</span><br><span class=\"line\">    sharray.reset();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上例中，shared_ptr管理一个动态数组并提供了删除器。</p>\n<h2 id=\"allocator类\"><a href=\"#allocator类\" class=\"headerlink\" title=\"allocator类\"></a>allocator类</h2><p>当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作（同时付出一定开销）。</p>\n<p>类似vector，allocator是一个模板。为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。 当一个allocator对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_allocator()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    allocator&lt;string&gt; alloc;</span><br><span class=\"line\">    // allocator分配5个string类型对象的空间</span><br><span class=\"line\">    // 这些空间未构造</span><br><span class=\"line\">    auto const p = alloc.allocate(5);</span><br><span class=\"line\">    //销毁开辟的空间</span><br><span class=\"line\">    alloc.deallocate(p, 5);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码用allocator构造alloc对象，说明开辟的空间是为string对象准备的，然后调用allocate开辟空间，但是这些空间不能直接使用，需要调用构造函数才能使用，我们用allocator类的construct来构造对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_allocator()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    allocator&lt;string&gt; alloc;</span><br><span class=\"line\">    // allocator分配5个string类型对象的空间</span><br><span class=\"line\">    // 这些空间未构造</span><br><span class=\"line\">    auto p = alloc.allocate(5);</span><br><span class=\"line\">    auto q = p;</span><br><span class=\"line\">    string str = &quot;c&quot;;</span><br><span class=\"line\">    for (; q != p + 5; q++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //构造字符串，每次字符串增加c字符</span><br><span class=\"line\">        alloc.construct(q, str);</span><br><span class=\"line\">        str += &quot;c&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // //打印构造的字符串列表</span><br><span class=\"line\">    for (q = p; q != p + 5; q++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; *q &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //销毁开辟的空间</span><br><span class=\"line\">    alloc.deallocate(p, 5);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>循环中通过construct为每个q指向的空间构造string对象，对象的内容就是str的内容，str会随着循环每次增加c，所以上面的代码输出如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c</span><br><span class=\"line\">cc</span><br><span class=\"line\">ccc</span><br><span class=\"line\">cccc</span><br><span class=\"line\">ccccc</span><br></pre></td></tr></table></figure>\n\n<p>另外stl也提供了一些拷贝和填充内存的算法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_allocator()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vector&lt;int&gt; ivec = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class=\"line\">    allocator&lt;int&gt; alloc;</span><br><span class=\"line\">    //开辟2倍ivec大小的空间</span><br><span class=\"line\">    auto p = alloc.allocate(ivec.size() * 2);</span><br><span class=\"line\">    //将ivec的内容copy至alloc开辟的空间里</span><br><span class=\"line\">    //返回q指向剩余未构造的内存空间的起始地址</span><br><span class=\"line\">    auto q = uninitialized_copy(ivec.begin(), ivec.end(), p);</span><br><span class=\"line\">    //将剩余元素初始化为42</span><br><span class=\"line\">    uninitialized_fill_n(q, ivec.size(), 42);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过uninitialized_copy将ivec元素拷贝到p指向的空间，同样完成了构造。 uninitialized_fill_n将剩余ivec大小未构造的空间全部初始化为42。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文介绍了动态数组开辟的方法，利用new关键字可以开辟动态数组，利用delete[]可以回收数组。 也实现了通过shared_ptr和unique_ptr等智能指针管理动态数组的方案。 最后通过列举allocator的一些方法，展示了如何实现开辟空间和构造对象分离的方式动态构造对象。 源码连接 <a href=\"https://gitee.com/secondtonone1/cpplearn\">https://gitee.com/secondtonone1/cpplearn</a> 想系统学习更多C++知识,可点击下方链接。 <a href=\"https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/23uSgIjfVfmwfhNGMprDFxL0uKL\">C++基础</a></p>\n","feature":null,"text":"C++语言和标准库提供了两种一次分配一个对象数组的方法。C++语言定义了另一种new表达式语法...","permalink":"/post/动态数组","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"智能指针","slug":"智能指针","count":4,"path":"api/categories/智能指针.json"}],"tags":[{"name":"智能指针","slug":"智能指针","count":2,"path":"api/tags/智能指针.json"},{"name":"new和数组","slug":"new和数组","count":1,"path":"api/tags/new和数组.json"},{"name":"动态数组","slug":"动态数组","count":1,"path":"api/tags/动态数组.json"},{"name":"allocator类","slug":"allocator类","count":1,"path":"api/tags/allocator类.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#new%E5%92%8C%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">new和数组</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">智能指针和动态数组</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#allocator%E7%B1%BB\"><span class=\"toc-text\">allocator类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"再谈单例模式","uid":"d9200ea647e7412ece3be1905aeabe7d","slug":"再谈单例模式","date":"2022-03-08T16:49:00.000Z","updated":"2024-06-11T17:57:28.623Z","comments":true,"path":"api/articles/再谈单例模式.json","keywords":null,"cover":"img/point.png","text":"本文介绍C++单例模式的集中实现方式，以及利弊...","permalink":"/post/再谈单例模式","photos":[],"count_time":{"symbolsCount":"9.9k","symbolsTime":"9 mins."},"categories":[{"name":"智能指针","slug":"智能指针","count":4,"path":"api/categories/智能指针.json"}],"tags":[{"name":"单例模式","slug":"单例模式","count":1,"path":"api/tags/单例模式.json"},{"name":"智能指针","slug":"智能指针","count":2,"path":"api/tags/智能指针.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null},"next_post":{"title":"_unique_ptr和weak_ptr","uid":"cccb789278337c954bd0aaca0affbce9","slug":"unique_ptr和weak_ptr","date":"2022-02-24T14:49:00.000Z","updated":"2024-05-23T07:20:38.608Z","comments":true,"path":"api/articles/unique_ptr和weak_ptr.json","keywords":null,"cover":"img/point.png","text":"unique_ptr和shared_ptr不同，unique_ptr不允许所指向的内容被其他指针共享，所以unique_ptr是不允许拷贝构造和赋值的。。...","permalink":"/post/unique_ptr和weak_ptr","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"智能指针","slug":"智能指针","count":4,"path":"api/categories/智能指针.json"}],"tags":[{"name":"指针","slug":"指针","count":2,"path":"api/tags/指针.json"},{"name":"unique_ptr","slug":"unique-ptr","count":1,"path":"api/tags/unique-ptr.json"},{"name":"weak_ptr","slug":"weak-ptr","count":1,"path":"api/tags/weak-ptr.json"},{"name":"删除器","slug":"删除器","count":1,"path":"api/tags/删除器.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null}}