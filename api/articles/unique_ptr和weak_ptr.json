{"title":"_unique_ptr和weak_ptr","uid":"cccb789278337c954bd0aaca0affbce9","slug":"unique_ptr和weak_ptr","date":"2022-02-24T14:49:00.000Z","updated":"2024-05-23T07:20:38.608Z","comments":true,"path":"api/articles/unique_ptr和weak_ptr.json","keywords":null,"cover":"img/point.png","content":"<h2 id=\"unique-ptr\"><a href=\"#unique-ptr\" class=\"headerlink\" title=\"unique_ptr\"></a>unique_ptr</h2><p>unique_ptr和shared_ptr不同，unique_ptr不允许所指向的内容被其他指针共享，所以unique_ptr是不允许拷贝构造和赋值的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_uniqueptr()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //指向double类型的unique指针</span><br><span class=\"line\">    unique_ptr&lt;double&gt; udptr;</span><br><span class=\"line\">    //一个指向int类型的unique指针</span><br><span class=\"line\">    unique_ptr&lt;int&gt; uiptr(new int(42));</span><br><span class=\"line\">    // unique不支持copy</span><br><span class=\"line\">    // unique_ptr&lt;int&gt; uiptr2(uiptr);</span><br><span class=\"line\">    // unique不支持赋值</span><br><span class=\"line\">    // unique_ptr&lt;int&gt; uiptr3 = uiptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然我们不能拷贝或赋值unique_ptr，但可以通过调用release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_uniqueptr()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //定义一个upstr</span><br><span class=\"line\">    unique_ptr&lt;string&gt; upstr(new string(&quot;hello zack&quot;));</span><br><span class=\"line\">    // upstr.release()返回其内置指针，并将upstr置空</span><br><span class=\"line\">    // 用upstr返回的内置指针初始化了upstr2</span><br><span class=\"line\">    unique_ptr&lt;string&gt; upstr2(upstr.release());</span><br><span class=\"line\">    unique_ptr&lt;string&gt; upstr3(new string(&quot;hello world&quot;));</span><br><span class=\"line\">    //将upstr3的内置指针转移给upstr2</span><br><span class=\"line\">    // upstr2放弃原来的内置指针，指向upstr3返回的内置指针。</span><br><span class=\"line\">    upstr2.reset(upstr3.release());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>unique_ptr有一个成员方法就是release，release可以返回unique_ptr的内置指针，并将unique_ptr置为空。 上述代码将upstr的内置指针转移给upstr2了。同样的道理，通过reset操作, upstr2将upstr3的内置指针绑定了。 release()操作提供了返回unique_ptr的内置指针的方法，但要注意release过后unique_ptr被置空，那返回的内置指针要么手动释放，要么交给其他的智能指针管理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_uniqueptr()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //定义一个upstr</span><br><span class=\"line\">    unique_ptr&lt;string&gt; upstr(new string(&quot;hello zack&quot;));</span><br><span class=\"line\">    //获取upstr的内置指针</span><br><span class=\"line\">    string *inerp = upstr.release();</span><br><span class=\"line\">    //因为此时upstr已经通过release交出内置指针使用权</span><br><span class=\"line\">    //所以要手动释放内置指针的内存</span><br><span class=\"line\">    delete inerp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr。 最常见的例子是从函数返回一个unique_ptr：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unique_ptr&lt;int&gt; clone_unique(int a)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return unique_ptr&lt;int&gt;(new int(a));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void use_uniqueptr()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int a = 1024;</span><br><span class=\"line\">    unique_ptr&lt;int&gt; mp = clone_unique(a);</span><br><span class=\"line\">    cout &lt;&lt; *mp &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除器\"><a href=\"#删除器\" class=\"headerlink\" title=\"删除器\"></a>删除器</h2><p>类似shared_ptr，我们可以为unique_ptr指定删除器，但与之不同的是，为unique_ptr指定删除器时要在尖括号里指定删除器类型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//p 指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象</span><br><span class=\"line\">//它会调用一个名为fcn的delT类型对象 </span><br><span class=\"line\">unique_ptr&lt;objT, delT&gt; p(new objT, fcn);</span><br></pre></td></tr></table></figure>\n\n<p>作为一个更具体的例子，我们这样演示,先定义一个unique_deleter</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void unique_deleter(int *p)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;this is unique deleter&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;inner pointer data is &quot; &lt;&lt; *p &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再基于删除器定义一个unique_ptr</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_uniqueptr()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    unique_ptr&lt;int, decltype(unique_deleter) *&gt; mp(new int(1024), unique_deleter);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们在主函数调用use_uniqueptr会输出如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this is unique deleter</span><br><span class=\"line\">inner pointer data is 1024</span><br></pre></td></tr></table></figure>\n\n<p>在本例中我们使用了decltype来指明函数指针类型。由于decltype返回一个函数类型，所以我们必须添加一个＊来指出我们正在使用该类型的一个指针。</p>\n<h2 id=\"weak-ptr\"><a href=\"#weak-ptr\" class=\"headerlink\" title=\"weak_ptr\"></a>weak_ptr</h2><p>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。 将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。 一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。 即使有weak_ptr指向对象，对象也还是会被释放，因此，weak_ptr的名字抓住了这种智能指针“弱”共享对象的特点。 weak_ptr同样包括reset()，use_count()等方法。 与shared_ptr不同的是，weak_ptr提供expired()方法，该方法在use_count为0时返回true, 否则返回false。所以可以通过expired方法去判断weak_ptr的内置指针是否被释放。 weak_ptr通过lock()方法返回一个shared_ptr，shared_ptr内置指针指向的空间和weak_ptr内置指针指向相同。由于weak_ptr的弱共享特点，其内置指针可能被回收，所以当expired为true时， lock()返回一个空的shared_ptr，否则返回一个shared_ptr，该shared_ptr的内置指针与weak_ptr的内置指针指向相同。 我们通过如下几个例子阐述weak_ptr的特性 1 不增加shared_ptr的引用计数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_weakptr()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //构造shared_ptr</span><br><span class=\"line\">    auto psint = make_shared&lt;int&gt;(1024);</span><br><span class=\"line\">    //用shared_ptr构造weak_ptr</span><br><span class=\"line\">    weak_ptr&lt;int&gt; pwint(psint);</span><br><span class=\"line\">    //打印shared_ptr的引用计数</span><br><span class=\"line\">    cout &lt;&lt; &quot;shared_ptr use count is &quot; &lt;&lt; psint.use_count() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码输出shared_ptr use count is 1 因为weak_ptr不占用引用计数。 2 通过expired判断内置指针是否被释放</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weak_ptr&lt;int&gt; clone_weakptr(int num)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    shared_ptr&lt;int&gt; psint(new int(num));</span><br><span class=\"line\">    return weak_ptr&lt;int&gt;(psint);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void use_weakptr()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    auto wptr = clone_weakptr(1024);</span><br><span class=\"line\">    if (wptr.expired())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;wptr inner pointer has been deleted&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;wptr inner pointer data is &quot; &lt;&lt; *(wptr.lock()) &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在主函数中调用use_weakptr将会输出”wptr inner pointer has been deleted”。 因为clone_weakptr返回的weak_ptr引用了局部变量psint，psint随着函数clone_weakptr结束而释放，所以wptr.expired()返回true 3 通过lock生成shared_ptr</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void use_weakptr()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    shared_ptr&lt;int&gt; psint(new int(1022));</span><br><span class=\"line\">    //也可以通过赋值，将shared_ptr赋值给weak_ptr</span><br><span class=\"line\">    weak_ptr&lt;int&gt; pwint = psint;</span><br><span class=\"line\">    //通过weak_ptr生成shared_ptr</span><br><span class=\"line\">    shared_ptr&lt;int&gt; psint2 = pwint.lock();</span><br><span class=\"line\">    cout &lt;&lt; &quot;psint use count is &quot; &lt;&lt; psint.use_count() &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;psint2 use count is &quot; &lt;&lt; psint2.use_count() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到通过赋值初始化pwint，pwint.lock()返回另一个shared_ptr，这样两个shared_ptr引用计数相同，都为2. 源码连接 <a href=\"https://gitee.com/secondtonone1/cpplearn\">https://gitee.com/secondtonone1/cpplearn</a> 想系统学习更多C++知识,可点击下方链接。 <a href=\"https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/23uSgIjfVfmwfhNGMprDFxL0uKL\">C++基础</a></p>\n","feature":null,"text":"unique_ptr和shared_ptr不同，unique_ptr不允许所指向的内容被其他指针共享，所以unique_ptr是不允许拷贝构造和赋值的。。...","permalink":"/post/unique_ptr和weak_ptr","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"智能指针","slug":"智能指针","count":4,"path":"api/categories/智能指针.json"}],"tags":[{"name":"指针","slug":"指针","count":2,"path":"api/tags/指针.json"},{"name":"unique_ptr","slug":"unique-ptr","count":1,"path":"api/tags/unique-ptr.json"},{"name":"weak_ptr","slug":"weak-ptr","count":1,"path":"api/tags/weak-ptr.json"},{"name":"删除器","slug":"删除器","count":1,"path":"api/tags/删除器.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#unique-ptr\"><span class=\"toc-text\">unique_ptr</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E5%99%A8\"><span class=\"toc-text\">删除器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#weak-ptr\"><span class=\"toc-text\">weak_ptr</span></a></li></ol>","author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"动态数组","uid":"adc37eeabf3d5d5cb2363096a2fd87f2","slug":"动态数组","date":"2022-03-02T15:49:00.000Z","updated":"2024-05-23T07:21:56.736Z","comments":true,"path":"api/articles/动态数组.json","keywords":null,"cover":"img/point.png","text":"C++语言和标准库提供了两种一次分配一个对象数组的方法。C++语言定义了另一种new表达式语法...","permalink":"/post/动态数组","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"智能指针","slug":"智能指针","count":4,"path":"api/categories/智能指针.json"}],"tags":[{"name":"智能指针","slug":"智能指针","count":2,"path":"api/tags/智能指针.json"},{"name":"new和数组","slug":"new和数组","count":1,"path":"api/tags/new和数组.json"},{"name":"动态数组","slug":"动态数组","count":1,"path":"api/tags/动态数组.json"},{"name":"allocator类","slug":"allocator类","count":1,"path":"api/tags/allocator类.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null},"next_post":{"title":"如何使用Gitbook搭建自己的笔记网站","uid":"414c4f40ff95d974f69d0698f4a5c5a7","slug":"如何使用Gitbook搭建自己的笔记网站","date":"2022-02-19T04:00:00.000Z","updated":"2024-06-03T03:50:25.008Z","comments":true,"path":"api/articles/如何使用Gitbook搭建自己的笔记网站.json","keywords":null,"cover":"img/web.jpg","text":"使用GitBook搭建自己的笔记网站或知识库可以分为几个基本步骤。...","permalink":"/post/如何使用Gitbook搭建自己的笔记网站","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"实用教程","slug":"实用教程","count":7,"path":"api/categories/实用教程.json"}],"tags":[{"name":"网站搭建","slug":"网站搭建","count":2,"path":"api/tags/网站搭建.json"},{"name":"实用教程","slug":"实用教程","count":2,"path":"api/tags/实用教程.json"},{"name":"Gitbook","slug":"Gitbook","count":1,"path":"api/tags/Gitbook.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":true}}