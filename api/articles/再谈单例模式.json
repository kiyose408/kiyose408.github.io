{"title":"再谈单例模式","uid":"d9200ea647e7412ece3be1905aeabe7d","slug":"再谈单例模式","date":"2022-03-08T16:49:00.000Z","updated":"2024-06-11T17:57:28.623Z","comments":true,"path":"api/articles/再谈单例模式.json","keywords":null,"cover":"img/point.png","content":"<p>本文介绍C++单例模式的集中实现方式，以及利弊</p>\n<h2 id=\"局部静态变量方式\"><a href=\"#局部静态变量方式\" class=\"headerlink\" title=\"局部静态变量方式\"></a>局部静态变量方式</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//通过静态成员变量实现单例</span><br><span class=\"line\">//懒汉式</span><br><span class=\"line\">class Single2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    Single2()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Single2(const Single2 &amp;) = delete;</span><br><span class=\"line\">    Single2 &amp;operator=(const Single2 &amp;) = delete;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    static Single2 &amp;GetInst()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        static Single2 single;</span><br><span class=\"line\">        return single;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码通过局部静态成员single实现单例类，原理就是函数的局部静态变量生命周期随着进程结束而结束。上述代码通过懒汉式的方式实现。 调用如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void test_single2()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //多线程情况下可能存在问题</span><br><span class=\"line\">    cout &lt;&lt; &quot;s1 addr is &quot; &lt;&lt; &amp;Single2::GetInst() &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;s2 addr is &quot; &lt;&lt; &amp;Single2::GetInst() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序输出如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sp1  is  0x1304b10</span><br><span class=\"line\">sp2  is  0x1304b10</span><br></pre></td></tr></table></figure>\n\n<p>确实生成了唯一实例，上述单例模式存在隐患，对于多线程方式生成的实例可能时多个。</p>\n<h2 id=\"静态成员变量指针方式\"><a href=\"#静态成员变量指针方式\" class=\"headerlink\" title=\"静态成员变量指针方式\"></a>静态成员变量指针方式</h2><p>可以定义一个类的静态成员变量，用来控制实现单例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//饿汉式</span><br><span class=\"line\">class Single2Hungry</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    Single2Hungry()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Single2Hungry(const Single2Hungry &amp;) = delete;</span><br><span class=\"line\">    Single2Hungry &amp;operator=(const Single2Hungry &amp;) = delete;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    static Single2Hungry *GetInst()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (single == nullptr)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            single = new Single2Hungry();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return single;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    static Single2Hungry *single;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这么做的一个好处是我们可以通过饿汉式的方式避免线程安全问题</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//饿汉式初始化</span><br><span class=\"line\">Single2Hungry *Single2Hungry::single = Single2Hungry::GetInst();</span><br><span class=\"line\">void thread_func_s2(int i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;this is thread &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;inst is &quot; &lt;&lt; Single2Hungry::GetInst() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void test_single2hungry()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;s1 addr is &quot; &lt;&lt; Single2Hungry::GetInst() &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;s2 addr is &quot; &lt;&lt; Single2Hungry::GetInst() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (int i = 0; i &lt; 3; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        thread tid(thread_func_s2, i);</span><br><span class=\"line\">        tid.join();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    test_single2hungry()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序输出如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s1 addr is 0x1e4b00</span><br><span class=\"line\">s2 addr is 0x1e4b00</span><br><span class=\"line\">this is thread 0</span><br><span class=\"line\">inst is 0x1e4b00</span><br><span class=\"line\">this is thread 1</span><br><span class=\"line\">inst is 0x1e4b00</span><br><span class=\"line\">this is thread 2</span><br><span class=\"line\">inst is 0x1e4b00</span><br></pre></td></tr></table></figure>\n\n<p>可见无论单线程还是多线程模式下，通过静态成员变量的指针实现的单例类都是唯一的。饿汉式是在程序启动时就进行单例的初始化，这种方式也可以通过懒汉式调用，无论饿汉式还是懒汉式都存在一个问题，就是什么时候释放内存？多线程情况下，释放内存就很难了，还有二次释放内存的风险。 我们定义一个单例类并用懒汉式方式调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//懒汉式指针</span><br><span class=\"line\">//即使创建指针类型也存在问题</span><br><span class=\"line\">class SinglePointer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    SinglePointer()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    SinglePointer(const SinglePointer &amp;) = delete;</span><br><span class=\"line\">    SinglePointer &amp;operator=(const SinglePointer &amp;) = delete;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    static SinglePointer *GetInst()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (single != nullptr)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return single;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        s_mutex.lock();</span><br><span class=\"line\">        if (single != nullptr)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s_mutex.unlock();</span><br><span class=\"line\">            return single;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        single = new SinglePointer();</span><br><span class=\"line\">        s_mutex.unlock();</span><br><span class=\"line\">        return single;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    static SinglePointer *single;</span><br><span class=\"line\">    static mutex s_mutex;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在cpp文件里初始化静态成员,并定义一个测试函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//懒汉式</span><br><span class=\"line\">//在类的cpp文件定义static变量</span><br><span class=\"line\">SinglePointer *SinglePointer::single = nullptr;</span><br><span class=\"line\">std::mutex SinglePointer::s_mutex;</span><br><span class=\"line\"></span><br><span class=\"line\">void thread_func_lazy(int i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;this is lazy thread &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;inst is &quot; &lt;&lt; SinglePointer::GetInst() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void test_singlelazy()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (int i = 0; i &lt; 3; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        thread tid(thread_func_lazy, i);</span><br><span class=\"line\">        tid.join();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //何时释放new的对象？造成内存泄漏</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    test_singlelazy();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数输出如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this is lazy thread 0</span><br><span class=\"line\">inst is 0xbc1700</span><br><span class=\"line\">this is lazy thread 1</span><br><span class=\"line\">inst is 0xbc1700</span><br><span class=\"line\">this is lazy thread 2</span><br><span class=\"line\">inst is 0xbc1700</span><br></pre></td></tr></table></figure>\n\n<p>此时生成的单例对象的内存空间还没回收，这是个问题，另外如果多线程情况下多次delete也会造成崩溃。</p>\n<h2 id=\"智能指针方式\"><a href=\"#智能指针方式\" class=\"headerlink\" title=\"智能指针方式\"></a>智能指针方式</h2><p>可以利用智能指针自动回收内存的机制设计单例类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//利用智能指针解决释放问题</span><br><span class=\"line\">class SingleAuto</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    SingleAuto()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    SingleAuto(const SingleAuto &amp;) = delete;</span><br><span class=\"line\">    SingleAuto &amp;operator=(const SingleAuto &amp;) = delete;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    ~SingleAuto()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;single auto delete success &quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static std::shared_ptr&lt;SingleAuto&gt; GetInst()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (single != nullptr)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return single;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        s_mutex.lock();</span><br><span class=\"line\">        if (single != nullptr)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s_mutex.unlock();</span><br><span class=\"line\">            return single;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        single = std::shared_ptr&lt;SingleAuto&gt;(new SingleAuto);</span><br><span class=\"line\">        s_mutex.unlock();</span><br><span class=\"line\">        return single;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    static std::shared_ptr&lt;SingleAuto&gt; single;</span><br><span class=\"line\">    static mutex s_mutex;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>SingleAuto的GetInst返回std::shared_ptr类型的变量single。因为single是静态成员变量，所以会在进程结束时被回收。智能指针被回收时会调用内置指针类型的析构函数，从而完成内存的回收。 在主函数调用如下测试函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 智能指针方式</span><br><span class=\"line\">std::shared_ptr&lt;SingleAuto&gt; SingleAuto::single = nullptr;</span><br><span class=\"line\">mutex SingleAuto::s_mutex;</span><br><span class=\"line\">void test_singleauto()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    auto sp1 = SingleAuto::GetInst();</span><br><span class=\"line\">    auto sp2 = SingleAuto::GetInst();</span><br><span class=\"line\">    cout &lt;&lt; &quot;sp1  is  &quot; &lt;&lt; sp1 &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;sp2  is  &quot; &lt;&lt; sp2 &lt;&lt; endl;</span><br><span class=\"line\">    //此时存在隐患，可以手动删除裸指针，造成崩溃</span><br><span class=\"line\">    // delete sp1.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    test_singleauto();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序输出如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sp1  is  0x1174f30</span><br><span class=\"line\">sp2  is  0x1174f30</span><br></pre></td></tr></table></figure>\n\n<p>智能指针方式不存在内存泄漏，但是有一个隐患就是单例类的析构函数时public的，如果被人手动调用会存在崩溃问题，比如将上边test_singleauto中的注释打开，程序会崩溃。</p>\n<h2 id=\"辅助类智能指针单例模式\"><a href=\"#辅助类智能指针单例模式\" class=\"headerlink\" title=\"辅助类智能指针单例模式\"></a>辅助类智能指针单例模式</h2><p>智能指针在构造的时候可以指定删除器，所以可以传递一个辅助类或者辅助函数帮助智能指针回收内存时调用我们指定的析构函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// safe deletor</span><br><span class=\"line\">//防止外界delete</span><br><span class=\"line\">//声明辅助类</span><br><span class=\"line\">//该类定义仿函数调用SingleAutoSafe析构函数</span><br><span class=\"line\">//不可以提前声明SafeDeletor，编译时会提示incomplete type</span><br><span class=\"line\">// class SafeDeletor;</span><br><span class=\"line\">//所以要提前定义辅助类</span><br><span class=\"line\">class SingleAutoSafe;</span><br><span class=\"line\">class SafeDeletor</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void operator()(SingleAutoSafe *sf)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;this is safe deleter operator()&quot; &lt;&lt; endl;</span><br><span class=\"line\">        delete sf;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class SingleAutoSafe</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    SingleAutoSafe() &#123;&#125;</span><br><span class=\"line\">    ~SingleAutoSafe()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;this is single auto safe deletor&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SingleAutoSafe(const SingleAutoSafe &amp;) = delete;</span><br><span class=\"line\">    SingleAutoSafe &amp;operator=(const SingleAutoSafe &amp;) = delete;</span><br><span class=\"line\">    //定义友元类，通过友元类调用该类析构函数</span><br><span class=\"line\">    friend class SafeDeletor;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    static std::shared_ptr&lt;SingleAutoSafe&gt; GetInst()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (single != nullptr)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return single;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        s_mutex.lock();</span><br><span class=\"line\">        if (single != nullptr)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s_mutex.unlock();</span><br><span class=\"line\">            return single;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //额外指定删除器</span><br><span class=\"line\">        single = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe, SafeDeletor());</span><br><span class=\"line\">        //也可以指定删除函数</span><br><span class=\"line\">        // single = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe, SafeDelFunc);</span><br><span class=\"line\">        s_mutex.unlock();</span><br><span class=\"line\">        return single;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    static std::shared_ptr&lt;SingleAutoSafe&gt; single;</span><br><span class=\"line\">    static mutex s_mutex;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>SafeDeletor要写在SingleAutoSafe上边，并且SafeDeletor要声明为SingleAutoSafe类的友元类，这样就可以访问SingleAutoSafe的析构函数了。 我们在构造single时制定了SafeDeletor(),single在回收时，会调用SingleAutoSafe的仿函数，从而完成内存的销毁。 并且SingleAutoSafe的析构函数为私有的无法被外界手动调用了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//智能指针初始化为nullptr</span><br><span class=\"line\">std::shared_ptr&lt;SingleAutoSafe&gt; SingleAutoSafe::single = nullptr;</span><br><span class=\"line\">mutex SingleAutoSafe::s_mutex;</span><br><span class=\"line\"></span><br><span class=\"line\">void test_singleautosafe()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    auto sp1 = SingleAutoSafe::GetInst();</span><br><span class=\"line\">    auto sp2 = SingleAutoSafe::GetInst();</span><br><span class=\"line\">    cout &lt;&lt; &quot;sp1  is  &quot; &lt;&lt; sp1 &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;sp2  is  &quot; &lt;&lt; sp2 &lt;&lt; endl;</span><br><span class=\"line\">    //此时无法访问析构函数，非常安全</span><br><span class=\"line\">    // delete sp1.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    test_singleautosafe();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序输出如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sp1  is  0x1264f30</span><br><span class=\"line\">sp2  is  0x1264f30</span><br></pre></td></tr></table></figure>\n\n<p>通过辅助类调用单例类的析构函数保证了内存释放的安全性和唯一性。这种方式时生产中常用的。如果将test_singleautosafe函数的注释打开，手动delete sp1.get()编译阶段就会报错，达到了代码安全的目的。因为析构被设置为私有函数了。</p>\n<h2 id=\"通用的单例模板类\"><a href=\"#通用的单例模板类\" class=\"headerlink\" title=\"通用的单例模板类\"></a>通用的单例模板类</h2><p>我们可以通过声明单例的模板类，然后继承这个单例模板类的所有类就是单例类了。达到泛型编程提高效率的目的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">class Single_T</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">    Single_T() = default;</span><br><span class=\"line\">    Single_T(const Single_T&lt;T&gt; &amp;st) = delete;</span><br><span class=\"line\">    Single_T &amp;operator=(const Single_T&lt;T&gt; &amp;st) = delete;</span><br><span class=\"line\">    ~Single_T()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;this is auto safe template destruct&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    static std::shared_ptr&lt;T&gt; GetInst()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (single != nullptr)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return single;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        s_mutex.lock();</span><br><span class=\"line\">        if (single != nullptr)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s_mutex.unlock();</span><br><span class=\"line\">            return single;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //额外指定删除器</span><br><span class=\"line\">        single = std::shared_ptr&lt;T&gt;(new T, SafeDeletor_T&lt;T&gt;());</span><br><span class=\"line\">        //也可以指定删除函数</span><br><span class=\"line\">        // single = std::shared_ptr&lt;SingleAutoSafe&gt;(new SingleAutoSafe, SafeDelFunc);</span><br><span class=\"line\">        s_mutex.unlock();</span><br><span class=\"line\">        return single;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    static std::shared_ptr&lt;T&gt; single;</span><br><span class=\"line\">    static mutex s_mutex;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">//模板类的static成员要放在h文件里初始化</span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">std::shared_ptr&lt;T&gt; Single_T&lt;T&gt;::single = nullptr;</span><br><span class=\"line\"></span><br><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">mutex Single_T&lt;T&gt;::s_mutex;</span><br></pre></td></tr></table></figure>\n\n<p>我们定义一个网络的单例类，继承上述模板类即可，并将构造和析构设置为私有，同时设置友元保证自己的析构和构造可以被友元类调用.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//通过继承方式实现网络模块单例</span><br><span class=\"line\">class SingleNet : public Single_T&lt;SingleNet&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    SingleNet() = default;</span><br><span class=\"line\">    SingleNet(const SingleNet &amp;) = delete;</span><br><span class=\"line\">    SingleNet &amp;operator=(const SingleNet &amp;) = delete;</span><br><span class=\"line\">    ~SingleNet() = default;</span><br><span class=\"line\">    friend class SafeDeletor_T&lt;SingleNet&gt;;</span><br><span class=\"line\">    friend class Single_T&lt;SingleNet&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在主函数中调用如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void test_singlenet()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    auto sp1 = SingleNet::GetInst();</span><br><span class=\"line\">    auto sp2 = SingleNet::GetInst();</span><br><span class=\"line\">    cout &lt;&lt; &quot;sp1  is  &quot; &lt;&lt; sp1 &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;sp2  is  &quot; &lt;&lt; sp2 &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序输出如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sp1  is  0x1164f30</span><br><span class=\"line\">sp2  is  0x1164f30</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文介绍了一些面试常见问题 源码链接 <a href=\"https://gitee.com/secondtonone1/cpplearn\">https://gitee.com/secondtonone1/cpplearn</a> 想系统学习更多C++知识,可点击下方链接。 <a href=\"https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/24H7mZgZw57zCqGoULERZ2mQWOM\">C++基础</a></p>\n","feature":null,"text":"本文介绍C++单例模式的集中实现方式，以及利弊...","permalink":"/post/再谈单例模式","photos":[],"count_time":{"symbolsCount":"9.9k","symbolsTime":"9 mins."},"categories":[{"name":"智能指针","slug":"智能指针","count":4,"path":"api/categories/智能指针.json"}],"tags":[{"name":"单例模式","slug":"单例模式","count":1,"path":"api/tags/单例模式.json"},{"name":"智能指针","slug":"智能指针","count":2,"path":"api/tags/智能指针.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">局部静态变量方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%8C%87%E9%92%88%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">静态成员变量指针方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">智能指针方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BE%85%E5%8A%A9%E7%B1%BB%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">辅助类智能指针单例模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%9A%E7%94%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E6%9D%BF%E7%B1%BB\"><span class=\"toc-text\">通用的单例模板类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"动态内存管理示例","uid":"6d811383cc30559af72f7dba87a5b6e3","slug":"动态内存管理示例","date":"2022-03-14T19:49:00.000Z","updated":"2024-06-11T17:57:20.308Z","comments":true,"path":"api/articles/动态内存管理示例.json","keywords":null,"cover":"img/c01.jpg","text":"之前我们讲述过动态内存的开辟，可以通过new, malloc，以及alloc等方式，本文通过介绍alloc方式，构造一个StrVec类...","permalink":"/post/动态内存管理示例","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"C++高级","slug":"C-高级","count":9,"path":"api/categories/C-高级.json"}],"tags":[{"name":"内存管理","slug":"内存管理","count":4,"path":"api/tags/内存管理.json"},{"name":"拷贝构造","slug":"拷贝构造","count":1,"path":"api/tags/拷贝构造.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null},"next_post":{"title":"动态数组","uid":"adc37eeabf3d5d5cb2363096a2fd87f2","slug":"动态数组","date":"2022-03-02T15:49:00.000Z","updated":"2024-07-19T22:00:30.231Z","comments":true,"path":"api/articles/动态数组.json","keywords":null,"cover":"img/point.png","text":"C++语言和标准库提供了两种一次分配一个对象数组的方法。C++语言定义了另一种new表达式语法...","permalink":"/post/动态数组","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"智能指针","slug":"智能指针","count":4,"path":"api/categories/智能指针.json"}],"tags":[{"name":"智能指针","slug":"智能指针","count":2,"path":"api/tags/智能指针.json"},{"name":"new和数组","slug":"new和数组","count":1,"path":"api/tags/new和数组.json"},{"name":"动态数组","slug":"动态数组","count":1,"path":"api/tags/动态数组.json"},{"name":"allocator类","slug":"allocator类","count":1,"path":"api/tags/allocator类.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null}}