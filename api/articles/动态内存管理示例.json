{"title":"动态内存管理示例","uid":"6d811383cc30559af72f7dba87a5b6e3","slug":"动态内存管理示例","date":"2022-03-14T19:49:00.000Z","updated":"2024-05-23T07:42:59.155Z","comments":true,"path":"api/articles/动态内存管理示例.json","keywords":null,"cover":"img/c01.jpg","content":"<h2 id=\"动态内存管理\"><a href=\"#动态内存管理\" class=\"headerlink\" title=\"动态内存管理\"></a>动态内存管理</h2><p>之前我们讲述过动态内存的开辟，可以通过new, malloc，以及alloc等方式，本文通过介绍alloc方式，构造一个StrVec类，这个类的功能类似于一个vector，实现字符串的管理，其中包含push一个字符串，动态扩容，析构，回收内存等操作。</p>\n<h2 id=\"StrVec类实现细节\"><a href=\"#StrVec类实现细节\" class=\"headerlink\" title=\"StrVec类实现细节\"></a>StrVec类实现细节</h2><p>StrVec类实现如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class StrVec</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    //无参构造函数</span><br><span class=\"line\">    StrVec() : elements(nullptr), first_free(nullptr),</span><br><span class=\"line\">               cap(nullptr) &#123;&#125;</span><br><span class=\"line\">    //拷贝构造函数</span><br><span class=\"line\">    StrVec(const StrVec &amp;);</span><br><span class=\"line\">    //拷贝赋值运算符</span><br><span class=\"line\">    StrVec &amp;operator=(const StrVec &amp;);</span><br><span class=\"line\">    //析构函数</span><br><span class=\"line\">    ~StrVec();</span><br><span class=\"line\">    //拷贝元素</span><br><span class=\"line\">    void push_back(const std::string &amp;);</span><br><span class=\"line\">    //返回元素个数</span><br><span class=\"line\">    size_t size() const &#123; return first_free - elements; &#125;</span><br><span class=\"line\">    //返回总容量</span><br><span class=\"line\">    size_t capacity() const &#123; return cap - elements; &#125;</span><br><span class=\"line\">    //返回首元素地址</span><br><span class=\"line\">    std::string *begin() const</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return elements;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //返回第一个空闲元素地址</span><br><span class=\"line\">    //也是最后一个有效元素的下一个位置</span><br><span class=\"line\">    std::string *end() const</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return first_free;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    //判断容量不足开辟新空间</span><br><span class=\"line\">    void chk_n_alloc()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (size() == capacity())</span><br><span class=\"line\">            reallocate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //重新开辟空间</span><br><span class=\"line\">    void reallocate();</span><br><span class=\"line\">    // copy指定范围的元素到新的内存中</span><br><span class=\"line\">    std::pair&lt;std::string *, std::string *&gt; alloc_n_copy(</span><br><span class=\"line\">        const std::string *, const std::string *);</span><br><span class=\"line\">    //释放空间</span><br><span class=\"line\">    void free();</span><br><span class=\"line\">    //数组首元素的指针</span><br><span class=\"line\">    std::string *elements;</span><br><span class=\"line\">    //指向数组第一个空闲元素的指针</span><br><span class=\"line\">    std::string *first_free;</span><br><span class=\"line\">    //指向数组尾后位置的指针</span><br><span class=\"line\">    std::string *cap;</span><br><span class=\"line\">    //构造string类型allocator静态成员</span><br><span class=\"line\">    static std::allocator&lt;std::string&gt; alloc;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>1 elements成员，该成员指向StrVec内部数组空间的第一个元素 2 first_free成员指向第一个空闲元素，也就是有效元素的下一个元素，该元素开辟空间但未构造。 3 cap 指向最后一个元素的下一个位置。 4 alloc为静态成员，主要负责string类型数组的开辟工作。 5 无参构造函数将三个指针初始化为空，并且默认够早了alloc。 6 alloc_n_copy私有函数的功能是将一段区域的数据copy到新的空间， 并且返回新开辟的空间地址以及第一个空闲元素的地址(第一个未构造元素的地址)。 7 chk_n_alloc私有函数检测数组大小是否达到容量，如果达到则调用reallocate重新开辟空间。 8 reallocate重新开辟空间 9 capacity返回总容量 10 size返回元素个数 11 push_back 将元素放入开辟的类似于数组的连续空间中。 12 begin返回首元素地址 13 end返回第一个空闲元素地址,也是最后一个有效元素的下一个位置 无论我们实现push操作还是拷贝构造操作，都要实现realloc，当空间不足时要开辟空间将旧数据移动到新的数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//重新开辟空间</span><br><span class=\"line\">void StrVec::reallocate()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    string *newdata = nullptr;</span><br><span class=\"line\">    //数组为空的情况</span><br><span class=\"line\">    if (elements == nullptr || cap == nullptr || first_free == nullptr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        newdata = alloc.allocate(1);</span><br><span class=\"line\">        // elements和first_free都指向首元素</span><br><span class=\"line\">        elements = newdata;</span><br><span class=\"line\">        first_free = newdata;</span><br><span class=\"line\">        // cap指向数组尾元素的下一个位置。</span><br><span class=\"line\">        cap = newdata + 1;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //不为空则扩充两倍空间</span><br><span class=\"line\">    newdata = alloc.allocate(size() * 2);</span><br><span class=\"line\">    //新内存空闲位置</span><br><span class=\"line\">    auto dest = newdata;</span><br><span class=\"line\">    //旧内存有效位置</span><br><span class=\"line\">    auto src = elements;</span><br><span class=\"line\">    //通过移动操作将旧数据放到新内存中</span><br><span class=\"line\">    for (size_t i = 0; i != size(); ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        alloc.construct(dest++, std::move(*src++));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //移动后旧内存数据无效，一定要删除</span><br><span class=\"line\">    free();</span><br><span class=\"line\">    //更新数据位置</span><br><span class=\"line\">    elements = newdata;</span><br><span class=\"line\">    //更新第一个空闲位置</span><br><span class=\"line\">    first_free = dest;</span><br><span class=\"line\">    //更新容量</span><br><span class=\"line\">    cap = elements + size() * 2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>reallocate函数内部判断是否为刚初始化指针却没开辟空间的空数组，如果是则开辟1个大小的空间。 否则则开辟原有空间的两倍，将旧数据移动到新空间，采用了std::move操作，这么做减少拷贝造成的性能开销。 move之后原数据就无效了，所以要调用私有函数free()进行释放。我们实现该free操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//释放操作</span><br><span class=\"line\">void StrVec::free()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //判断elements是否为空</span><br><span class=\"line\">    if (elements == nullptr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    auto dest = elements;</span><br><span class=\"line\">    //要先遍历析构每一个对象</span><br><span class=\"line\">    for (size_t i = 0; i &lt; size(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // destroy会调用每一个元素的析构函数</span><br><span class=\"line\">        alloc.destroy(dest++);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //再整体回收内存</span><br><span class=\"line\">    alloc.deallocate(elements, cap - elements);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先通过遍历destroy销毁内存，从而调用string的析构函数，最后在deallocate回收内存。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// copy指定范围的元素到新的内存中,返回新元素的地址和第一个空闲元素地址的pair</span><br><span class=\"line\">std::pair&lt;std::string *, std::string *&gt; StrVec::alloc_n_copy(</span><br><span class=\"line\">    const std::string *b, const std::string *e)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    auto newdata = alloc.allocate(e - b);</span><br><span class=\"line\">    //将原数据用来初始化新空间</span><br><span class=\"line\">    auto first_free = uninitialized_copy(b, e, newdata);</span><br><span class=\"line\">    return &#123;newdata, first_free&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样利用alloc_n_copy，我们就可以实现拷贝构造和拷贝赋值了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//拷贝构造函数</span><br><span class=\"line\">StrVec::StrVec(const StrVec &amp;strtmp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //将形参数据拷贝给自己</span><br><span class=\"line\">    auto rsp = alloc_n_copy(strtmp.begin(), strtmp.end());</span><br><span class=\"line\">    //更新elements, cap，first_free</span><br><span class=\"line\">    elements = rsp.first;</span><br><span class=\"line\">    first_free = rsp.second;</span><br><span class=\"line\">    cap = rsp.second;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是拷贝赋值要注意一点，就是自赋值的情况，所以我们提前判断是否为自赋值，如不是则进行和拷贝构造相同的操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//拷贝赋值运算符</span><br><span class=\"line\">StrVec &amp;StrVec::operator=(const StrVec &amp;strtmp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //防止自赋值</span><br><span class=\"line\">    if (this == &amp;strtmp)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return *this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //将形参数据拷贝给自己</span><br><span class=\"line\">    auto rsp = alloc_n_copy(strtmp.begin(), strtmp.end());</span><br><span class=\"line\">    //更新elements, cap，first_free</span><br><span class=\"line\">    elements = rsp.first;</span><br><span class=\"line\">    first_free = rsp.second;</span><br><span class=\"line\">    cap = rsp.second;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以利用free实现析构函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//析构</span><br><span class=\"line\">StrVec::~StrVec()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    free();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们实现push_back，将指定字符串添加到数组空间,以及抛出元素</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//添加元素</span><br><span class=\"line\">void StrVec::push_back(const std::string &amp;s)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    chk_n_alloc();</span><br><span class=\"line\">    alloc.construct(first_free++, s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//抛出元素</span><br><span class=\"line\">void StrVec::pop_back(std::string &amp;s)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (first_free == nullptr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (size() == 1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        s = *elements;</span><br><span class=\"line\">        alloc.destroy(elements);</span><br><span class=\"line\">        first_free = nullptr;</span><br><span class=\"line\">        elements = nullptr;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    s = *(--first_free);</span><br><span class=\"line\">    alloc.destroy(first_free);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来实现测试函数，测试上述操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void test_strvec()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    auto str1 = StrVec();</span><br><span class=\"line\">    str1.push_back(&quot;hello zack&quot;);</span><br><span class=\"line\">    StrVec str2(str1);</span><br><span class=\"line\">    str2.push_back(&quot;hello rolin&quot;);</span><br><span class=\"line\">    StrVec str3 = str1;</span><br><span class=\"line\">    string strtmp;</span><br><span class=\"line\">    str3.pop_back(strtmp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在主函数调用上面test_strvec，运行稳定。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文通过allocator实现了一个类似于vector的类，管理string变量。演示了拷贝构造，拷贝赋值要注意的事项，同时演示了如何手动开辟内存并管理内存空间。 源码链接 <a href=\"https://gitee.com/secondtonone1/cpplearn\">https://gitee.com/secondtonone1/cpplearn</a> 想系统学习更多C++知识,可点击下方链接。 <a href=\"https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/24H7mZgZw57zCqGoULERZ2mQWOM\">C++基础</a></p>\n","feature":null,"text":"之前我们讲述过动态内存的开辟，可以通过new, malloc，以及alloc等方式，本文通过介绍alloc方式，构造一个StrVec类...","permalink":"/post/动态内存管理示例","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"C++高级","slug":"C-高级","count":9,"path":"api/categories/C-高级.json"}],"tags":[{"name":"内存管理","slug":"内存管理","count":4,"path":"api/tags/内存管理.json"},{"name":"拷贝构造","slug":"拷贝构造","count":1,"path":"api/tags/拷贝构造.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">动态内存管理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#StrVec%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82\"><span class=\"toc-text\">StrVec类实现细节</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"lambda表达式","uid":"85522d683e84dc82b51c41943dc59db8","slug":"lambda表达式","date":"2022-03-21T22:49:00.000Z","updated":"2024-05-31T03:08:41.325Z","comments":true,"path":"api/articles/lambda表达式.json","keywords":null,"cover":"img/c01.jpg","text":"lambda表达式又称为匿名表达式，是C11提出的新语法。[]存储lambda表达式要捕获的值，()内的参数为形参，可供外部调用传值...","permalink":"/post/lambda表达式","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"C++高级","slug":"C-高级","count":9,"path":"api/categories/C-高级.json"}],"tags":[{"name":"lambda表达式","slug":"lambda表达式","count":2,"path":"api/tags/lambda表达式.json"},{"name":"bind操作","slug":"bind操作","count":1,"path":"api/tags/bind操作.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null},"next_post":{"title":"再谈单例模式","uid":"d9200ea647e7412ece3be1905aeabe7d","slug":"再谈单例模式","date":"2022-03-08T16:49:00.000Z","updated":"2024-05-23T07:23:00.982Z","comments":true,"path":"api/articles/再谈单例模式.json","keywords":null,"cover":"img/point.png","text":"本文介绍C++单例模式的集中实现方式，以及利弊...","permalink":"/post/再谈单例模式","photos":[],"count_time":{"symbolsCount":"9.9k","symbolsTime":"9 mins."},"categories":[{"name":"智能指针","slug":"智能指针","count":4,"path":"api/categories/智能指针.json"}],"tags":[{"name":"单例模式","slug":"单例模式","count":1,"path":"api/tags/单例模式.json"},{"name":"智能指针","slug":"智能指针","count":2,"path":"api/tags/智能指针.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null}}