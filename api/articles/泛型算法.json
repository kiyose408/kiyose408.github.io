{"title":"泛型算法","uid":"ae38a1dc51089423f709c36bdcb792e9","slug":"泛型算法","date":"2022-01-15T05:49:00.000Z","updated":"2024-05-23T07:07:57.304Z","comments":true,"path":"api/articles/泛型算法.json","keywords":null,"cover":"img/fx.png","content":"<h2 id=\"泛型算法\"><a href=\"#泛型算法\" class=\"headerlink\" title=\"泛型算法\"></a>泛型算法</h2><p>泛型算法是STL库里面定义的一些算法,这些算法可以用一个接口操作各种数据类型,因此成为泛型算法。大多算法定义在头文件algorithm和numeric中。意思就是可以用一个接口操作各种类型的算法就是泛型算法。 泛型算法分为两类，一类是只读算法，一类是修改原有容器的算法。 只读算法包括find(查找),accumulate(累加)等。 修改算法包括replace(替换),fill(填充)等。</p>\n<h2 id=\"accumulate\"><a href=\"#accumulate\" class=\"headerlink\" title=\"accumulate\"></a>accumulate</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int&gt; nvec = &#123;1, 2, 3, 4, 5, 6, 7&#125;;</span><br><span class=\"line\">//调用accumulate累加，sum的初始值为0，累加结果写入sum</span><br><span class=\"line\">auto sum = accumulate(nvec.begin(), nvec.end(), 0);</span><br><span class=\"line\">cout &lt;&lt; &quot;sum is &quot; &lt;&lt; sum &lt;&lt; endl;</span><br><span class=\"line\">list&lt;string&gt; strlist = &#123;&quot;hello&quot;, &quot;zack&quot;, &quot;good&quot;, &quot;idea&quot;&#125;;</span><br><span class=\"line\">string stradd = accumulate(strlist.begin(), strlist.end(), string(&quot;&quot;));</span><br><span class=\"line\">cout &lt;&lt; &quot;str add result is &quot; &lt;&lt; stradd &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<p>accumulate将第三个参数作为求和起点，这蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。在上例中，vec中的元素可以是int，或者是double、long long或任何其他可以加到int上的类型。由于string定义了+运算符，所以我们可以通过调用accumulate来将vector中所有string元素连接起来. 程序输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum is 28</span><br><span class=\"line\">str add result is hellozackgoodidea</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"equal\"><a href=\"#equal\" class=\"headerlink\" title=\"equal\"></a>equal</h2><p>泛型算法中有操作两个序列的算法，比如equal就是比较两个序列中元素是否有相等的值，如果第一个序列中每个元素与第二个序列中的元素都相等，则返回true，否则返回false。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool bequa = equal(strlist.begin(), strlist.end(), strlist2.begin());</span><br><span class=\"line\">   if (bequa)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       cout &lt;&lt; &quot;strlist is equal to strlist2&quot; &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   else</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       cout &lt;&lt; &quot;strlist is not equal to strlist2&quot; &lt;&lt; endl;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码比较了strlist和strlist2，切记strlist2的长度要大于等于strlist，否则程序会出现问题。那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。</p>\n<h2 id=\"fill\"><a href=\"#fill\" class=\"headerlink\" title=\"fill\"></a>fill</h2><p>可以通过fill算法修改容器的值,算法fill接受一对迭代器表示一个范围，还接受一个值作为第三个参数。fill将给定的这个值赋予输入序列中的每个元素。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int&gt; nvec2 = &#123;1, 2, 3, 4&#125;;</span><br><span class=\"line\">//将nvec2中所有元素设置为0</span><br><span class=\"line\">fill(nvec2.begin(), nvec2.end(), 0);</span><br><span class=\"line\">//将nvec2中前半部分设置为10</span><br><span class=\"line\">fill(nvec2.begin(), nvec2.begin() + nvec2.size() / 2, 10);</span><br></pre></td></tr></table></figure>\n\n<p>类似的还有fill_n函数，该函数接受一个单迭代器，一个计数值和一个值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int&gt; vec;</span><br><span class=\"line\">fill_n(vec.begin(), vec.size(), 0);</span><br></pre></td></tr></table></figure>\n\n<p>如下调用fill会导致程序崩溃，因为vec3大小为0，而fill要向vec3写入10个0，会造成越界崩溃。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//空向量</span><br><span class=\"line\">vector&lt;int&gt; vec3;</span><br><span class=\"line\">// 灾难，修改vec3中的10个不存在元素</span><br><span class=\"line\">fill_n(vec3.begin(),10,0);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"back-inserter\"><a href=\"#back-inserter\" class=\"headerlink\" title=\"back_inserter\"></a>back_inserter</h2><p>fill_n如果传递的个数大于容器的大小会造成崩溃，为了防止类似的问题，stl引入了back_inserter。back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//空vector</span><br><span class=\"line\">vector&lt;int&gt; nvec4;</span><br><span class=\"line\">// back_inserter绑定nvec4并返回迭代器</span><br><span class=\"line\">auto iter = back_inserter(nvec4);</span><br><span class=\"line\">//对迭代器的赋值就是对nvec插入元素</span><br><span class=\"line\">*iter = 2;</span><br><span class=\"line\">*iter = 4;</span><br><span class=\"line\">for (auto it = nvec4.begin(); it != nvec4.end(); it++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序依次打印输出2, 4 我们常常使用back_inserter来创建一个迭代器，作为算法的目的位置来使用。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//空vector</span><br><span class=\"line\">vector&lt;int&gt; nvec5;</span><br><span class=\"line\">// back_inserter绑定nvec5并返回迭代器</span><br><span class=\"line\">auto iter5 = back_inserter(nvec5);</span><br><span class=\"line\">//添加10个元素写入nvec5</span><br><span class=\"line\">fill_n(iter5, 10, 0);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"copy\"><a href=\"#copy\" class=\"headerlink\" title=\"copy\"></a>copy</h2><p>拷贝（copy）算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给copy的目的序列至少要包含与输入序列一样多的元素。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a1[] = &#123;0, 1, 2, 3, 4, 5, 6&#125;;</span><br><span class=\"line\">constexpr int nszie = sizeof(a1) / sizeof(int);</span><br><span class=\"line\">int a2[nszie];</span><br><span class=\"line\">//将a1内容copy到a2中</span><br><span class=\"line\">copy(begin(a1), end(a1), a2);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace\"></a>replace</h2><p>我们可以通过replace替换原容器中的某个值为设定的新值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int&gt; nvec6 = &#123;1, 2, 3, 4&#125;;</span><br><span class=\"line\">//将nvec6中所有元素为3的设置为32</span><br><span class=\"line\">replace(nvec6.begin(), nvec6.end(), 3, 32);</span><br></pre></td></tr></table></figure>\n\n<p>如果保留原容器数据，可以通过back_inserter绑定一个新的容器，然后用replace_copy完成拷贝和替换操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//原始数据列表</span><br><span class=\"line\">list&lt;int&gt; ilist = &#123;0, 1, 2, 3, 4, 5&#125;;</span><br><span class=\"line\">//空向量</span><br><span class=\"line\">vector&lt;int&gt; rcpvec;</span><br><span class=\"line\">//将ilist中的数据copy到rcpvec里，但是将其中的0替换为42</span><br><span class=\"line\">replace_copy(ilist.begin(), ilist.end(), back_inserter(rcpvec), 0, 42);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"unique和sort\"><a href=\"#unique和sort\" class=\"headerlink\" title=\"unique和sort\"></a>unique和sort</h2><p>我们实现一个功能，将vector中的单词排序并且去除其中重复的单词。 我们可以用sort函数先将vector中的单词排序，然后用unique去除重复的单词，unique返回不重复的最后一个元素的迭代器，unique保证容器中前n个元素是不重复的，n+1个开始就是重复的，所以我们用erase再删除n+1个元素以后的内容就可以了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;string&gt; words = &#123;&quot;good&quot;, &quot;idea&quot;, &quot;zack&quot;, &quot;lucy&quot;, &quot;good&quot;, &quot;idea&quot;&#125;;</span><br><span class=\"line\">//先将words中的词语排序</span><br><span class=\"line\">sort(words.begin(), words.end());</span><br><span class=\"line\">// unique会移动元素，将不重复的元素放在前边，重复的放在后边</span><br><span class=\"line\">// unique返回不重复的最后一个元素的位置</span><br><span class=\"line\">const auto uniqueiter = unique(words.begin(), words.end());</span><br><span class=\"line\">//调用erase将重复的元素删除</span><br><span class=\"line\">words.erase(uniqueiter, words.end());</span><br></pre></td></tr></table></figure>\n\n<p>打印输出words可以看到words变为{good , idea , lucy , zack}</p>\n","feature":null,"text":"介绍STL库中的泛型算法。...","permalink":"/post/泛型算法","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"泛型用法","slug":"泛型用法","count":3,"path":"api/categories/泛型用法.json"}],"tags":[{"name":"算法","slug":"算法","count":2,"path":"api/tags/算法.json"},{"name":"泛型","slug":"泛型","count":2,"path":"api/tags/泛型.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">泛型算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#accumulate\"><span class=\"toc-text\">accumulate</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#equal\"><span class=\"toc-text\">equal</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#fill\"><span class=\"toc-text\">fill</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#back-inserter\"><span class=\"toc-text\">back_inserter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#copy\"><span class=\"toc-text\">copy</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#replace\"><span class=\"toc-text\">replace</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#unique%E5%92%8Csort\"><span class=\"toc-text\">unique和sort</span></a></li></ol>","author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"泛型定制","uid":"72f8e112b71c8b55e9acbece39e8eb93","slug":"泛型定制","date":"2022-01-25T05:49:00.000Z","updated":"2024-07-19T22:00:31.574Z","comments":true,"path":"api/articles/泛型定制.json","keywords":null,"cover":"img/fx.png","text":"默认情况下，泛型算法还实现了另外一个版本，就是接受一个额外的参数。...","permalink":"/post/泛型定制","photos":[],"count_time":{"symbolsCount":"9.9k","symbolsTime":"9 mins."},"categories":[{"name":"泛型用法","slug":"泛型用法","count":3,"path":"api/categories/泛型用法.json"}],"tags":[{"name":"lambda表达式","slug":"lambda表达式","count":2,"path":"api/tags/lambda表达式.json"},{"name":"泛型","slug":"泛型","count":2,"path":"api/tags/泛型.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null},"next_post":{"title":"软件测试基础","uid":"30d74a927cb679b680169d9bb1c056fd","slug":"软件测试_基础篇","date":"2021-12-30T05:49:00.000Z","updated":"2024-06-11T18:00:25.303Z","comments":true,"path":"api/articles/软件测试_基础篇.json","keywords":null,"cover":"img/rc.png","text":"介绍关于软件测试的基础部分:接口测试...","permalink":"/post/软件测试_基础篇","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"软件测试","slug":"软件测试","count":1,"path":"api/categories/软件测试.json"}],"tags":[{"name":"软件测试","slug":"软件测试","count":1,"path":"api/tags/软件测试.json"},{"name":"接口测试","slug":"接口测试","count":1,"path":"api/tags/接口测试.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null}}