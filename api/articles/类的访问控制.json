{"title":"类的访问控制","uid":"aa58dd8d3b218c61e8320d0bbec359ae","slug":"类的访问控制","date":"2021-06-17T10:49:36.000Z","updated":"2024-05-21T12:42:58.267Z","comments":true,"path":"api/articles/类的访问控制.json","keywords":null,"cover":"img/C++.jpg","content":"<h1 id=\"私有和公有\"><a href=\"#私有和公有\" class=\"headerlink\" title=\"私有和公有\"></a>私有和公有</h1><p>一个类里有方法和成员变量，public关键字标识后，public下的方法和变量都变为<strong>公有函数</strong>。private关键字标识后，private关键字下的方法和成员变量都变为<strong>私有</strong>。默认情况下，如果<strong>不声明public</strong>，class中所有的方法和成员都是<strong>私有的</strong>。如果<strong>不声明private</strong>, struct中所有的方法和成员都是<strong>公有的</strong>。</p>\n<h1 id=\"友元\"><a href=\"#友元\" class=\"headerlink\" title=\"友元\"></a>友元</h1><p>上一篇，我们将print，read等非<code>Sales_data</code>类的全局函数声明为<code>Sales_data</code>类的友元函数，所以print，read可以访问<code>Sales_data</code>类的私有成员。这里再次回忆一下<code>Sales_data</code>类。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sales_data</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//通过default实现默认构造</span></span><br><span class=\"line\">    <span class=\"comment\">// Sales_data() = default;</span></span><br><span class=\"line\">    <span class=\"comment\">//显示实现默认构造</span></span><br><span class=\"line\">    <span class=\"built_in\">Sales_data</span>() : <span class=\"built_in\">bookNo</span>(<span class=\"string\">&quot;&quot;</span>), <span class=\"built_in\">units_sold</span>(<span class=\"number\">0</span>), <span class=\"built_in\">revenue</span>(<span class=\"number\">0.0</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// copy构造，根据Sales_data类型对象构造一个新对象</span></span><br><span class=\"line\">    <span class=\"built_in\">Sales_data</span>(<span class=\"type\">const</span> Sales_data &amp;sa);</span><br><span class=\"line\">    <span class=\"built_in\">Sales_data</span>(<span class=\"type\">const</span> std::string &amp;s) : <span class=\"built_in\">bookNo</span>(s) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">Sales_data</span>(<span class=\"type\">const</span> std::string &amp;s, <span class=\"type\">unsigned</span> n, <span class=\"type\">double</span> p)</span><br><span class=\"line\">        : <span class=\"built_in\">bookNo</span>(s), <span class=\"built_in\">units_sold</span>(n), <span class=\"built_in\">revenue</span>(p * n) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">Sales_data</span>(std::istream &amp;is);</span><br><span class=\"line\">    <span class=\"comment\">//返回图书号</span></span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">isbn</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> bookNo; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取平均单价</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">avg_price</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//将一个Sales_data对象合并到当前类对象</span></span><br><span class=\"line\">    <span class=\"function\">Sales_data &amp;<span class=\"title\">combine</span><span class=\"params\">(<span class=\"type\">const</span> Sales_data &amp;)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> std::ostream &amp;<span class=\"title\">print</span><span class=\"params\">(std::ostream &amp;, <span class=\"type\">const</span> Sales_data &amp;)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> std::istream &amp;<span class=\"title\">read</span><span class=\"params\">(std::istream &amp;, Sales_data &amp;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//图书编号</span></span><br><span class=\"line\">    std::string bookNo;</span><br><span class=\"line\">    <span class=\"comment\">//销量</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> units_sold = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//收入</span></span><br><span class=\"line\">    <span class=\"type\">double</span> revenue = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>封装有两个重要的优点： </p>\n<ul>\n<li>确保用户代码不会无意间破坏封装对象的状态。 </li>\n<li>被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。</li>\n</ul>\n<h1 id=\"友元的声明\"><a href=\"#友元的声明\" class=\"headerlink\" title=\"友元的声明\"></a>友元的声明</h1><p>友元的声明仅仅<strong>指定了访问的权限</strong>，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）。因此，我们的Sales_data头文件应该为read、print和add提供独立的声明（除了类内部的友元声明之外）。所以我在Sales_data类的头文件里声明了这些函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Sales_data的非成员接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> Sales_data <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">const</span> Sales_data &amp;, <span class=\"type\">const</span> Sales_data &amp;)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> std::ostream &amp;<span class=\"title\">print</span><span class=\"params\">(std::ostream &amp;, <span class=\"type\">const</span> Sales_data &amp;)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> std::istream &amp;<span class=\"title\">read</span><span class=\"params\">(std::istream &amp;, Sales_data &amp;)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"隐藏类型定义\"><a href=\"#隐藏类型定义\" class=\"headerlink\" title=\"隐藏类型定义\"></a>隐藏类型定义</h1><p>我们可以在类中定义一种新的类型，这种类型对于外部是隐藏内部实现的，外部不知道该类型是什么。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Screen</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::string::size_type pos;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    pos cursor = <span class=\"number\">0</span>;</span><br><span class=\"line\">    pos height = <span class=\"number\">0</span>, width = <span class=\"number\">0</span>;</span><br><span class=\"line\">    std::string contents;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>用来定义类型的成员必须先定义后使用，这一点与普通成员有所区别，具体原因将在7.4.1节（C++PrimerPlus第254页）解释。因此，类型成员通常出现在类开始的地方。</p>\n<h1 id=\"inline成员函数\"><a href=\"#inline成员函数\" class=\"headerlink\" title=\"inline成员函数\"></a>inline成员函数</h1><p>所谓内联函数就是在编译时展开，减少运行时开销的一种手段，可以通过inline关键字声明，也可以在类的cpp文件里定义函数时前面指明inline，当然一个类的成员函数在类的头文件实现了，那它也是内联函数，我们完善Screen类，用以下三种方式实现内联函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Screen</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::string::size_type pos;</span><br><span class=\"line\">    <span class=\"comment\">//因为Screen有另一个构造函数</span></span><br><span class=\"line\">    <span class=\"comment\">//所以要实现一个默认构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Screen</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cursor被初始化为0</span></span><br><span class=\"line\">    <span class=\"built_in\">Screen</span>(pos ht, pos wd, <span class=\"type\">char</span> c) : <span class=\"built_in\">height</span>(ht), <span class=\"built_in\">width</span>(wd), <span class=\"built_in\">contents</span>(ht * wd, c) &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">//读取光标处字符</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">char</span> <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//隐式内联</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> contents[cursor];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//显示内联</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">char</span> <span class=\"title\">get</span><span class=\"params\">(pos ht, pos wd)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//能在之后被设为内联</span></span><br><span class=\"line\">    <span class=\"function\">Screen &amp;<span class=\"title\">move</span><span class=\"params\">(pos r, pos c)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    pos cursor = <span class=\"number\">0</span>;</span><br><span class=\"line\">    pos height = <span class=\"number\">0</span>, width = <span class=\"number\">0</span>;</span><br><span class=\"line\">    std::string contents;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以在<strong>类的内部</strong>把inline作为声明的一部分<strong>显式地声明成员函数</strong>，同样的，也能在<strong>类的外部</strong>用inline关键字<strong>修饰函数的定义</strong>：虽然我们无须在声明和定义的地方同时说明inline，但这么做其实是合法的。不过，最好只在类外部定义的地方说明inline，这样可以使类更容易理解。</p>\n<h1 id=\"重载成员函数\"><a href=\"#重载成员函数\" class=\"headerlink\" title=\"重载成员函数\"></a>重载成员函数</h1><p>类的成员函数同样支持重载。只要函数名相同，参数列表不同即可。</p>\n<h1 id=\"mutable属性\"><a href=\"#mutable属性\" class=\"headerlink\" title=\"mutable属性\"></a>mutable属性</h1><p>如果一个成员变量被指明mutable属性，则无论对象是否为const，无论成员函数是否为const，该成员变量都可以被修改。 我们给Screen定义一个mutable成员变量access_ctr，以及一个const成员函数some_member，并在该函数中修改access_ctr变量。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Screen</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::string::size_type pos;</span><br><span class=\"line\">    <span class=\"comment\">//因为Screen有另一个构造函数</span></span><br><span class=\"line\">    <span class=\"comment\">//所以要实现一个默认构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Screen</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"comment\">// cursor被初始化为0</span></span><br><span class=\"line\">    <span class=\"built_in\">Screen</span>(pos ht, pos wd, <span class=\"type\">char</span> c) : <span class=\"built_in\">height</span>(ht), <span class=\"built_in\">width</span>(wd), <span class=\"built_in\">contents</span>(ht * wd, c) &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">//读取光标处字符</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">char</span> <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//隐式内联</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> contents[cursor];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//显示内联</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">char</span> <span class=\"title\">get</span><span class=\"params\">(pos ht, pos wd)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//能在之后被设为内联</span></span><br><span class=\"line\">    <span class=\"function\">Screen &amp;<span class=\"title\">move</span><span class=\"params\">(pos r, pos c)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">some_member</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    pos cursor = <span class=\"number\">0</span>;</span><br><span class=\"line\">    pos height = <span class=\"number\">0</span>, width = <span class=\"number\">0</span>;</span><br><span class=\"line\">    std::string contents;</span><br><span class=\"line\">    <span class=\"comment\">//即使在一个const对象里access_ctr也可被修改</span></span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> <span class=\"type\">size_t</span> access_ctr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>实现some_member的一个成员变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Screen::some_member</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; <span class=\"comment\">//在const函数中也可以修改access_ctr</span></span><br><span class=\"line\">    ++access_ctr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"链式调用\"><a href=\"#链式调用\" class=\"headerlink\" title=\"链式调用\"></a>链式调用</h1><p>当我们通过成员函数内部返回*this，也就是类对象本身，则可以继续链式调用其内部的成员函数，比如我们通过重载实现两个set函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Screen &amp;<span class=\"title\">Screen::set</span><span class=\"params\">(<span class=\"type\">char</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    contents[cursor] = c;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">Screen &amp;<span class=\"title\">Screen::set</span><span class=\"params\">(pos r, pos col, <span class=\"type\">char</span> ch)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//给定位置设置新值</span></span><br><span class=\"line\">    contents[r * width + col] = ch;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>链式调用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Screen::pos row = <span class=\"number\">3</span>;</span><br><span class=\"line\">Screen::pos col = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"function\">Screen <span class=\"title\">screen</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"string\">&#x27;c&#x27;</span>)</span></span>;</span><br><span class=\"line\">screen.<span class=\"built_in\">move</span>(<span class=\"number\">2</span>, <span class=\"number\">3</span>).<span class=\"built_in\">set</span>(<span class=\"string\">&#x27;#&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>从const成员返回的*this是常量指针,如果我们实现一个display的const函数，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">const</span> Screen &amp;<span class=\"title\">Screen::display</span><span class=\"params\">(ostream &amp;os)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    os &lt;&lt; <span class=\"string\">&quot;width is &quot;</span> &lt;&lt; width &lt;&lt; <span class=\"string\">&quot; &quot;</span></span><br><span class=\"line\">       &lt;&lt; <span class=\"string\">&quot;height is &quot;</span> &lt;&lt; height &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果按照如下链式调用编译器将报错,因为display返回const Screen&amp; 类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">screen.<span class=\"built_in\">display</span>(cout).<span class=\"built_in\">move</span>(<span class=\"number\">2</span>, <span class=\"number\">3</span>).<span class=\"built_in\">set</span>(<span class=\"string\">&#x27;#&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>所以我们可以通过重载实现链式调用，实现一个返回const Screen &amp;类型的display函数和一个Screen &amp;类型的display函数, 这两个display函数内部调用do_display函数，因为const函数只能调用const函数，所以我们先实现display函数，他是一个const函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Screen::do_display</span><span class=\"params\">(ostream &amp;os)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    os &lt;&lt; <span class=\"string\">&quot;width is &quot;</span> &lt;&lt; width &lt;&lt; <span class=\"string\">&quot; &quot;</span></span><br><span class=\"line\">       &lt;&lt; <span class=\"string\">&quot;height is &quot;</span> &lt;&lt; height &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再实现两个重载的display函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">const</span> Screen &amp;<span class=\"title\">Screen::display</span><span class=\"params\">(ostream &amp;os)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">do_display</span>(os);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Screen &amp;<span class=\"title\">Screen::display</span><span class=\"params\">(ostream &amp;os)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">do_display</span>(os);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样编译器就会根据类型动态选择display的版本</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Screen <span class=\"title\">screen</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"string\">&#x27;c&#x27;</span>)</span></span>;</span><br><span class=\"line\">screen.<span class=\"built_in\">display</span>(cout).<span class=\"built_in\">move</span>(<span class=\"number\">2</span>, <span class=\"number\">3</span>).<span class=\"built_in\">set</span>(<span class=\"string\">&#x27;#&#x27;</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">const</span> Screen <span class=\"title\">cscreen</span><span class=\"params\">(<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"string\">&#x27; &#x27;</span>)</span></span>;</span><br><span class=\"line\">cscreen.<span class=\"built_in\">display</span>(cout);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"类类型和声明\"><a href=\"#类类型和声明\" class=\"headerlink\" title=\"类类型和声明\"></a>类类型和声明</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">First</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> memi;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getMem</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Second</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> memi;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getMem</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如上我们定义了两个类型，下面的赋值会报错，因为类内的成员虽然一致，但是不同的类就是不同的类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">First obj1;</span><br><span class=\"line\"><span class=\"comment\">//编译报错，obj1和obj2不是一个类型</span></span><br><span class=\"line\"> Second obj2 = obj1;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以不定义类，先进行类的声明</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Bags</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这种声明有时被称作前向声明（forward declaration），它向程序中引入了名字Screen并且指明Bags是一种类类型。对于类型Bags来说，在它声明之后定义之前是一个不完全类型（incomplete type），也就是说，此时我们已知Bags是一个类类型，但是不清楚它到底包含哪些成员。</p>\n<p>不完全类型只能在非常有限的情景下使用： 可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。</p>\n<p>直到类被定义之后数据成员才能被声明成这种类类型。我们必须首先完成类的定义，然后编译器才能知道存储该数据成员需要多少空间。 因为只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。 然而，一旦一个类的名字出现后，它就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Link_screen</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Screen window;</span><br><span class=\"line\">    Link_screen *next;</span><br><span class=\"line\">    Link_screen *prev;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"友元类和成员函数\"><a href=\"#友元类和成员函数\" class=\"headerlink\" title=\"友元类和成员函数\"></a>友元类和成员函数</h1><p>可以将一个类A声明为另一个类B的友元，则A类对象可以访问B类对象的私有成员。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Screen</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// Window_mgr可以访问Screen类的私有部分</span></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Window_mgr</span>;</span><br><span class=\"line\">    <span class=\"comment\">//Screen类的其他部分......</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Window_mgr类可以访问Screen类的私有成员，通过class前向声明了Window_mgr类。 接下来我们定义Window_mgr类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Window_mgr</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//窗口中每个屏幕的编号</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> ScreenIndex = std::vector&lt;Screen&gt;::size_type;</span><br><span class=\"line\">    <span class=\"comment\">//按照编号将指定的Screen重置为空白</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">clear</span><span class=\"params\">(ScreenIndex)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::vector&lt;Screen&gt; screens&#123;<span class=\"built_in\">Screen</span>(<span class=\"number\">24</span>, <span class=\"number\">80</span>, <span class=\"string\">&#x27; &#x27;</span>)&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Window_mgr::clear</span><span class=\"params\">(ScreenIndex i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// s是一个Screen的引用，指向我们想清空的屏幕</span></span><br><span class=\"line\">    Screen &amp;s = screens[i];</span><br><span class=\"line\">    <span class=\"comment\">//清空屏幕</span></span><br><span class=\"line\">    s.contents = <span class=\"built_in\">string</span>(s.height * s.width, <span class=\"string\">&#x27; &#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也可以让成员函数作为友元</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Screen</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// Window_mgr可以访问Screen类的私有部分</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"type\">void</span> <span class=\"title\">Window_mgr::clear</span><span class=\"params\">(ScreenIndex)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//Screen类的其他部分......</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>· 首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。 · 接下来定义Screen，包括对于clear的友元声明。 · 最后定义clear，此时它才可以使用Screen的成员。</p>\n<p>类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中</p>\n","feature":null,"text":"介绍通过关键字来控制类的访问权限，以及拓展到成员函数的访问权限。...","permalink":"/post/类的访问控制","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"类的认识","slug":"类的认识","count":2,"path":"api/categories/类的认识.json"}],"tags":[{"name":"C++","slug":"C","count":18,"path":"api/tags/C.json"},{"name":"成员函数","slug":"成员函数","count":2,"path":"api/tags/成员函数.json"},{"name":"友元","slug":"友元","count":1,"path":"api/tags/友元.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%A7%81%E6%9C%89%E5%92%8C%E5%85%AC%E6%9C%89\"><span class=\"toc-text\">私有和公有</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%8B%E5%85%83\"><span class=\"toc-text\">友元</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%8B%E5%85%83%E7%9A%84%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">友元的声明</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9A%90%E8%97%8F%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">隐藏类型定义</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#inline%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">inline成员函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%BD%BD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">重载成员函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#mutable%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">mutable属性</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">链式调用</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">类类型和声明</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%8B%E5%85%83%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">友元类和成员函数</span></a></li></ol>","author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"STL常用容器1","uid":"d3af54b11f2dd7ea1cd5b0bad6f3d323","slug":"STL常用容器_1","date":"2021-06-27T10:49:00.000Z","updated":"2024-05-21T12:43:42.095Z","comments":true,"path":"api/articles/STL常用容器_1.json","keywords":null,"cover":"img/STL.jpg","text":"String，vector，deque....","permalink":"/post/STL常用容器_1","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"24 mins."},"categories":[{"name":"STL","slug":"STL","count":5,"path":"api/categories/STL.json"}],"tags":[{"name":"vector","slug":"vector","count":2,"path":"api/tags/vector.json"},{"name":"STL","slug":"STL","count":5,"path":"api/tags/STL.json"},{"name":"String","slug":"String","count":1,"path":"api/tags/String.json"},{"name":"deque","slug":"deque","count":1,"path":"api/tags/deque.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null},"next_post":{"title":"类和对象","uid":"f7867369ce6c59c22c6335141c563f0b","slug":"类和对象","date":"2021-06-07T02:15:58.000Z","updated":"2024-05-21T12:42:45.405Z","comments":true,"path":"api/articles/类和对象.json","keywords":null,"cover":"img/C++.jpg","text":"介绍类的使用以及成员函数和构造函数。...","permalink":"/post/类和对象","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"类的认识","slug":"类的认识","count":2,"path":"api/categories/类的认识.json"}],"tags":[{"name":"C++","slug":"C","count":18,"path":"api/tags/C.json"},{"name":"类和对象","slug":"类和对象","count":1,"path":"api/tags/类和对象.json"},{"name":"成员函数","slug":"成员函数","count":2,"path":"api/tags/成员函数.json"},{"name":"构造函数","slug":"构造函数","count":2,"path":"api/tags/构造函数.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null}}