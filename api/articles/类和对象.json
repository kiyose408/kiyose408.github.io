{"title":"类和对象","uid":"f7867369ce6c59c22c6335141c563f0b","slug":"类和对象","date":"2021-06-01T02:15:58.000Z","updated":"2024-05-18T18:57:05.707Z","comments":true,"path":"api/articles/类和对象.json","keywords":null,"cover":"img/C++.jpg","content":"<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><p>:::tip<br>我们要设计一个<code>Sales_data</code>类来反映图书的销售情况，它把书籍的销售数据抽象化。就像“鸟”类可以用来描述鹦鹉或麻雀这类对象，“Sales_data”类则用来表示具体的图书销售记录。通过创建<code>Sales_data</code>对象并输入相关数据，系统能够自动统计该书的销售量和总收入。简而言之，<code>Sales_data</code>类是图书录入系统中用于高效管理销售信息的核心组件。<br>如果我们实现Sales_data类，外部调用是这样的<br>:::</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dealSales</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化汇总的Sales_data对象</span></span><br><span class=\"line\">    Sales_data total;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 读取第一条销售记录</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">read</span>(std::cin, total))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用于暂存每条新读取的销售记录</span></span><br><span class=\"line\">        Sales_data trans;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 循环读取后续销售记录</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"built_in\">read</span>(std::cin, trans))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 检查当前记录与已汇总记录的ISBN是否一致</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (total.<span class=\"built_in\">isbn</span>() == trans.<span class=\"built_in\">isbn</span>())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 若一致，则合并当前记录到总记录中</span></span><br><span class=\"line\">                total.<span class=\"built_in\">combine</span>(trans);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 若不一致，输出当前累计的销售数据，并开始新的累加周期</span></span><br><span class=\"line\">                <span class=\"built_in\">print</span>(std::cout, total) &lt;&lt; std::endl;</span><br><span class=\"line\">                <span class=\"comment\">// 将当前记录设为新的累加起点</span></span><br><span class=\"line\">                total = trans;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 输出最后一个或唯一一个汇总周期的销售数据</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(std::cout, total) &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 若无数据可读，则提示错误</span></span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;No sales data input detected.&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在我们的图书销售管理系统中，<code>Sales_data</code>类被精心设计以封装与图书销售记录相关的操作，具体包括关键的接口功能：</p>\n<ul>\n<li><p><strong>ISBN 查询成员函数</strong> (<code>isbn()</code>): 此成员函数允许用户获取某个<code>Sales_data</code>对象所代表图书的ISBN编号，便于识别和分类不同的图书记录。</p>\n</li>\n<li><p><strong>合并销售数据成员函数</strong> (<code>combine()</code>): 该功能使得一个<code>Sales_data</code>对象能够累积另一个相同ISBN图书的销售数据，这对于统计特定图书的总体销售情况极为重要。</p>\n</li>\n<li><p><strong>加法运算函数</strong> (<code>add()</code>): 提供了一个静态方法或友元函数形式的加法操作，能够直接将两个<code>Sales_data</code>对象相加，计算合并后的销售总量和总收入，简化多记录处理流程。</p>\n</li>\n<li><p><strong>读取数据成员函数</strong> (<code>read()</code>): 该成员负责从输入流（如标准输入<code>std::cin</code>）读取销售记录数据，并根据格式填充到<code>Sales_data</code>对象中，增强了程序的交互性和灵活性。</p>\n</li>\n<li><p><strong>打印输出成员函数</strong> (<code>print()</code>): 允许将<code>Sales_data</code>对象的内容格式化输出到指定的输出流（如<code>std::cout</code>），方便查看和记录销售统计数据，提高了系统的可审计性和透明度。</p>\n</li>\n</ul>\n<p>基于以上设计原则定义的<code>Sales_data</code>类，不仅能够高效地管理单本图书的销售信息，还能轻松整合并分析整个图书目录的销售概况，为图书录入系统提供了强大的数据处理支持。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __CLASS_H__</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __CLASS_H__</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sales_data</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//通过default实现默认构造</span></span><br><span class=\"line\">    <span class=\"comment\">// Sales_data() = default;</span></span><br><span class=\"line\">    <span class=\"comment\">//显示实现默认构造</span></span><br><span class=\"line\">    <span class=\"built_in\">Sales_data</span>() : <span class=\"built_in\">bookNo</span>(<span class=\"string\">&quot;&quot;</span>), <span class=\"built_in\">units_sold</span>(<span class=\"number\">0</span>), <span class=\"built_in\">revenue</span>(<span class=\"number\">0.0</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// copy构造，根据Sales_data类型对象构造一个新对象</span></span><br><span class=\"line\">    <span class=\"built_in\">Sales_data</span>(<span class=\"type\">const</span> Sales_data &amp;sa);</span><br><span class=\"line\">    <span class=\"comment\">//返回图书号</span></span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">isbn</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> bookNo; &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取平均单价</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">avg_price</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//将一个Sales_data对象合并到当前类对象</span></span><br><span class=\"line\">    <span class=\"function\">Sales_data &amp;<span class=\"title\">combine</span><span class=\"params\">(<span class=\"type\">const</span> Sales_data &amp;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//图书编号</span></span><br><span class=\"line\">    std::string bookNo;</span><br><span class=\"line\">    <span class=\"comment\">//销量</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> units_sold = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//收入</span></span><br><span class=\"line\">    <span class=\"type\">double</span> revenue = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// Sales_data的非成员接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> Sales_data <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">const</span> Sales_data &amp;, <span class=\"type\">const</span> Sales_data &amp;)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> std::ostream &amp;<span class=\"title\">print</span><span class=\"params\">(std::ostream &amp;, <span class=\"type\">const</span> Sales_data &amp;)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> std::istream &amp;<span class=\"title\">read</span><span class=\"params\">(std::istream &amp;, Sales_data &amp;)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title\">dealSales</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>接下来我们逐个部分介绍</p>\n<h1 id=\"成员函数\"><a href=\"#成员函数\" class=\"headerlink\" title=\"成员函数\"></a>成员函数</h1><p>在Sales_data类中，isbn成员函数扮演着至关重要的角色，它直接反映出类实例所关联的图书ISBN号。此函数之所以能访问bookNo成员，得益于C++中成员函数对this指针的隐式使用。当调用如a.isbn()时，this自动指向调用该函数的Sales_data对象a，从而允许间接访问a的bookNo属性。</p>\n<p>关于this指针的特性：</p>\n<blockquote>\n<p>类型与限制：在非const成员函数中，this是一个指向调用对象的非常量版本的常量指针(Sales_data *const)，确保指针本身不可修改，但可通过解引用来修改对象状态。在const成员函数中，this变为指向常量对象的指针(const Sales_data *const)，意味着既不能改变this指针自身，也不能通过它修改对象的状态，确保了常量成员函数的纯只读性质。</p>\n</blockquote>\n<p>常量成员函数的意义在于，它们能被常量对象或者通过常量引用&#x2F;指针访问的对象安全调用，保证了数据的不可变性，增加了函数使用的灵活性和安全性。</p>\n<p>至于成员函数的实现细节：</p>\n<blockquote>\n<p>编译器处理流程：首先，编译器处理类的成员声明，随后才是成员函数的具体定义。这意味着成员函数可以在声明后定义，且能自由引用类内的其他成员，不受定义顺序限制，如isbn访问bookNo。<br>外部定义规则：若成员函数在类外定义，需严格遵循其在类内声明的签名，包括返回类型、参数列表及函数名，并在必要时明确const限定符以匹配const成员函数的声明。函数定义前还需冠以类名，以表明其所属关系，如Sales_data::isbn() const {…}。</p>\n</blockquote>\n<p>综上所述，通过精确控制成员函数的const属性和合理利用this指针，Sales_data类实现了对图书数据的高效且安全的操作，无论是直接访问属性还是通过复杂的业务逻辑如数据合并与统计。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Sales_data::avg_price</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (units_sold)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> revenue / units_sold;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义返回this对象的combine函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Sales_data &amp;<span class=\"title\">Sales_data::combine</span><span class=\"params\">(<span class=\"type\">const</span> Sales_data &amp;sa)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;units_sold += sa.units_sold;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;revenue += sa.revenue;</span><br><span class=\"line\">    <span class=\"comment\">//返回调用该函数的对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>核心亮点在于</strong>该函数的<strong>返回类型与返回语句</strong>，这两个方面尤为值得关注。在设计函数时，若其功能紧密贴近某内置运算符，我们应确保该函数行为与该运算符保持高度<strong>一致</strong>。具体而言，借鉴内置<strong>赋值运算符</strong>的逻辑，其特性在于将左侧运算对象作为<strong>左值</strong>返回。因此，在自定义类似功能时，也应遵循这一机制，以增强代码的<strong>自然性和可预测性</strong>。</p>\n<h1 id=\"类相关非成员函数\"><a href=\"#类相关非成员函数\" class=\"headerlink\" title=\"类相关非成员函数\"></a>类相关非成员函数</h1><p>非成员函数的<strong>定义方式</strong>遵循常规函数的规则，关键在于巧妙地<strong>分离声明与定义</strong>。当面临这样一个场景：某函数虽在逻辑上隶属某类但未置于类内部实现时，最佳实践是将此函数与类的<strong>声明</strong>（而非实际<strong>定义</strong>）置于<strong>同一头文件</strong>中。如此一来，用户只需包含这单一文件，便能无缝访问类接口的所有组成部分，极大提升了代码的<strong>整合性</strong>与<strong>易用性</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::ostream &amp;<span class=\"title\">print</span><span class=\"params\">(std::ostream &amp;os, <span class=\"type\">const</span> Sales_data &amp;item)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    os &lt;&lt; item.<span class=\"built_in\">isbn</span>() &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class=\"string\">&quot; &quot;</span></span><br><span class=\"line\">       &lt;&lt; item.revenue &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; item.<span class=\"built_in\">avg_price</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> os;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::istream &amp;<span class=\"title\">read</span><span class=\"params\">(std::istream &amp;is, Sales_data &amp;item)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> price = <span class=\"number\">0</span>;</span><br><span class=\"line\">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> is;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在此情况下，编译过程将会遇到错误提示，根本原因在于尝试从<strong>非成员函数</strong>内部直接访问了<strong>类对象的私有成员</strong>。由于<code>Sales_data</code>类通过<code>private</code>关键字将其成员变量严格设定为私有，这自然而然地限制了外部非成员函数的直接触及。为了解决这一权限冲突，合理的策略是在类的<strong>声明部分</strong>明智地引入<strong>友元函数</strong>声明。此举有效授予该函数特殊权限，使其能够越过通常的访问限制，顺畅地与<code>Sales_data</code>类的私有成员进行交互。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">friend</span> std::ostream &amp;<span class=\"title\">print</span><span class=\"params\">(std::ostream &amp;, <span class=\"type\">const</span> Sales_data &amp;)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">friend</span> std::istream &amp;<span class=\"title\">read</span><span class=\"params\">(std::istream &amp;, Sales_data &amp;)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>这样print和read声明为Sales_item类的友元函数，就代表其能访问Sales_item类的私有成员了。 接下来我们同样定义add函数.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Sales_data <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">const</span> Sales_data &amp;sa1, <span class=\"type\">const</span> Sales_data &amp;sa2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Sales_data total = sa1;</span><br><span class=\"line\">    total.<span class=\"built_in\">combine</span>(sa2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>鉴于<code>combine</code>函数已被设为<code>public</code>，这意味着它对外部可见并可被直接调用，因此无需将<code>add</code>函数特别指定为<code>Sales_item</code>类的<strong>友元函数</strong>。</p>\n<p>在此过程中，新创建了一个<code>Sales_data</code>类型的对象<code>total</code>，旨在积累两笔交易信息之和。通过使用<code>sa1</code>的<strong>复制构造函数</strong>初始化<code>total</code>，实质上是深拷贝了<code>sa1</code>的所有数据成员——包括<code>bookNo</code>、<code>units_sold</code>及<code>revenue</code>至<code>total</code>，实现了两者状态的一致性。</p>\n<p>随后，通过调用<code>total.combine(sa2)</code>方法，将<code>sa2</code>的销售单位数(<code>units_sold</code>)和收入(<code>revenue</code>)累积至<code>total</code>中。此步骤高效合并了两笔交易数据。</p>\n<p>最终，函数返回<code>total</code>的一个副本，确保了原始数据的完整性与函数的无副作用特性。值得注意的是，这一系列操作背后的机制凸显了<strong>复制构造函数</strong>的重要性——它负责在创建新对象时正确复制原有对象的状态，故实现一个稳健的<code>Sales_data</code>类<strong>复制构造函数</strong>显得尤为重要。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sales_data::<span class=\"built_in\">Sales_data</span>(<span class=\"type\">const</span> Sales_data &amp;sa)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;bookNo = sa.bookNo;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;revenue = sa.revenue;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;units_sold = sa.units_sold;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h1><p>构造函数，以其与类名相同的命名方式，是类初始化不可或缺的一部分。其特性总结如下：</p>\n<ul>\n<li><strong>无返回类型</strong>：构造函数独特之处在于不声明返回类型，而其他成员函数则需明确返回类型。</li>\n<li><strong>参数与函数体</strong>：构造函数支持参数列表和函数体定义，灵活性与普通函数相似，可为空。</li>\n<li><strong>重载与区分</strong>：类可包含多个构造函数，依据参数类型或数量的不同实现重载，与普通函数重载原则一致。</li>\n<li><strong>非const特性</strong>：构造函数不能被标记为const，因初始化阶段可能修改对象状态，即使对象最终为const。</li>\n<li><strong>const对象初始化</strong>：构造函数在const对象创建期间可执行写操作，直至初始化完毕对象变为不可变。</li>\n<li><strong>默认构造函数</strong>：自动提供无参构造，即默认构造函数，除非类中已有其它构造函数定义。</li>\n<li><strong>合成默认构造</strong>：缺少显式定义时，编译器介入生成合成默认构造函数，遵循特定初始化规则：<ul>\n<li><strong>利用类内初始值</strong>：优先采用成员变量定义时的初始值进行初始化。</li>\n<li><strong>默认值初始化</strong>：若无类内初始值，则成员按各自类型的默认规则初始化（如数值型为0，指针为nullptr）。</li>\n</ul>\n</li>\n</ul>\n<p>综上所述，构造函数的设计直接关系到类实例化时的状态初始化，编译器通过一系列明确的规则保障了这一过程的自动化与一致性，特别是对于未明确指定构造逻辑的情况。</p>\n<p>我的理解：<br>当你没有显式地为类定义任何构造函数时，C++ 编译器会自动生成一个默认构造函数。这个默认构造函数会按照以下规则初始化类的数据成员：</p>\n<ol>\n<li><p><strong>如果有类内初始值</strong>: 数据成员会使用在类声明中提供的初始值来初始化。例如，如果你在类声明中为 <code>revenue</code> 成员变量指定了默认值 <code>0.0</code>，为 <code>units_sold</code> 指定 <code>0</code>，这些值就会被用来初始化新创建的对象的相应成员。</p>\n</li>\n<li><p><strong>如果没有类内初始值</strong>: 对于没有明确给出初始值的成员，编译器将执行默认初始化。对于基本数据类型的成员（如 <code>int</code>, <code>double</code>），这通常意味着将其初始化为 <code>0</code> 或 <code>0.0</code>；对于指针类型，初始化为 <code>nullptr</code>；对于类类型成员，则递归应用这些规则。对于像 <code>std::string</code> 这样的类类型（假设 <code>bookNo</code> 是一个 <code>std::string</code> 成员），如果没有提供初始值，它将被默认初始化为空字符串（<code>&quot;&quot;</code>）。</p>\n</li>\n</ol>\n<p>如果 <code>Sales_data</code> 类定义中 <code>revenue</code> 和 <code>units_sold</code> 成员有默认值分别为 <code>0.0</code> 和 <code>0</code>，而 <code>bookNo</code> 没有给出初始值，那么创建 <code>Sales_data</code> 的对象时：</p>\n<ul>\n<li><code>revenue</code> 会被初始化为 <code>0.0</code></li>\n<li><code>units_sold</code> 会被初始化为 <code>0</code></li>\n<li><code>bookNo</code> 作为 <code>std::string</code>，会被初始化为空字符串 <code>&quot;&quot;</code></li>\n</ul>\n<p>这是编译器提供的默认行为，确保了即使没有显式构造函数，类的实例也能得到合理的初始化。<br><strong>为何某些类需自定义默认构造函数？</strong><br>针对常规类设计，明确定义默认构造函数显得尤为关键，其背后蕴含三大核心缘由：</p>\n<ol>\n<li><p><strong>编译器行为的明确性：</strong><br><strong>【关键点】默认构造函数仅在无明确声明时由编译器自动合成。</strong><br>当类中不存在任何构造函数定义，编译器会贴心地提供一个默认版本。但一旦类中包含了其他构造函数，这一合成过程即刻终止，除非手动添加默认构造函数，否则类将缺失此功能。这一原则基于深思熟虑的设计考量：若类在特定情境下需控制初始化流程，那么普遍情况下同样需要这种控制权。</p>\n</li>\n<li><p><strong>避免未定义行为：</strong><br><strong>【注意】含有内置类型或复合类型成员的类，需谨慎处理默认初始化。</strong><br>缺省情况下，内置类型及复合类型成员可能被赋予未定义值。因此，<strong>仅当所有此类成员均在类内获得明确初始化值时</strong>，采用合成默认构造函数才是安全合理的做法。</p>\n</li>\n<li><p><strong>编译器限制与依赖问题：</strong><br><strong>【要点】类中含无默认构造函数的其他类类型成员时，需手动介入。</strong><br>编译器在面临此类复杂依赖时，无法自动生成默认构造函数，要求开发者明确实现，以确保所有成员得到恰当初始化。</p>\n</li>\n</ol>\n<p><strong>C++11的解决方案：<code>= default</code>指令</strong><br>为了简化流程且保留默认行为，C++11引入<code>= default</code>关键字。此指令允许在构造函数声明或定义处使用，指示编译器生成默认构造函数。无论置于类内（此时默认为内联）还是类外，<code>= default</code>均为确保构造函数存在性提供了简洁途径。</p>\n<p><strong>构造函数初始化列表的重要性</strong><br>特别强调，<strong>构造函数初始化列表</strong>是高效、准确初始化成员变量的关键实践。通过在列表中逐一指定成员及其初始值，开发人员能直接控制对象构造期间的内存初始化顺序和方式，避免了潜在的资源浪费或逻辑错误。</p>\n<p>我们再为Sales_data添加几个带参数的构造函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Sales_data</span>(<span class=\"type\">const</span> std::string &amp;s) : <span class=\"built_in\">bookNo</span>(s) &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Sales_data</span>(<span class=\"type\">const</span> std::string &amp;s, <span class=\"type\">unsigned</span> n, <span class=\"type\">double</span> p)</span><br><span class=\"line\">    : <span class=\"built_in\">bookNo</span>(s), <span class=\"built_in\">units_sold</span>(n), <span class=\"built_in\">revenue</span>(p * n) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再实现一个构造函数，其参数为ostream类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sales_data::<span class=\"built_in\">Sales_data</span>(std::istream &amp;is)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">read</span>(is, *<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","feature":true,"text":"介绍类的使用以及成员函数和构造函数。...","permalink":"/post/类和对象","photos":[],"count_time":{"symbolsCount":"7.9k","symbolsTime":"7 mins."},"categories":[{"name":"类的认识","slug":"类的认识","count":2,"path":"api/categories/类的认识.json"}],"tags":[{"name":"C++","slug":"C","count":10,"path":"api/tags/C.json"},{"name":"类和对象","slug":"类和对象","count":1,"path":"api/tags/类和对象.json"},{"name":"成员函数","slug":"成员函数","count":2,"path":"api/tags/成员函数.json"},{"name":"构造函数","slug":"构造函数","count":1,"path":"api/tags/构造函数.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB\"><span class=\"toc-text\">类</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">成员函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9B%B8%E5%85%B3%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">类相关非成员函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">构造函数</span></a></li></ol>","author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"类的访问控制","uid":"aa58dd8d3b218c61e8320d0bbec359ae","slug":"类的访问控制","date":"2021-06-15T10:49:36.000Z","updated":"2024-05-18T18:57:25.890Z","comments":true,"path":"api/articles/类的访问控制.json","keywords":null,"cover":"img/C++.jpg","text":"介绍通过关键字来控制类的访问权限，以及拓展到成员函数的访问权限。...","permalink":"/post/类的访问控制","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"类的认识","slug":"类的认识","count":2,"path":"api/categories/类的认识.json"}],"tags":[{"name":"C++","slug":"C","count":10,"path":"api/tags/C.json"},{"name":"成员函数","slug":"成员函数","count":2,"path":"api/tags/成员函数.json"},{"name":"友元","slug":"友元","count":1,"path":"api/tags/友元.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":true},"next_post":{"title":"Hexo搭建博客网站","uid":"8412bcb71a16d5331194e0e41f73e27d","slug":"Hexo搭建博客","date":"2020-05-16T15:15:58.000Z","updated":"2024-05-18T18:05:11.816Z","comments":true,"path":"api/articles/Hexo搭建博客.json","keywords":null,"cover":"img/web.jpg","text":"使用Hexo搭建博客网站....","permalink":"/post/Hexo搭建博客","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"实用教程","slug":"实用教程","count":3,"path":"api/categories/实用教程.json"}],"tags":[{"name":"Hexo","slug":"Hexo","count":1,"path":"api/tags/Hexo.json"},{"name":"网站搭建","slug":"网站搭建","count":1,"path":"api/tags/网站搭建.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":true}}