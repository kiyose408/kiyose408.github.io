{"title":"函数","uid":"d7ccd0a2fc5b38ef8ee1737116d9945c","slug":"函数","date":"2021-05-28T12:10:53.000Z","updated":"2024-06-11T18:00:53.922Z","comments":true,"path":"api/articles/函数.json","keywords":null,"cover":"img/C++.jpg","content":"<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>一个典型的函数（function）定义包括以下部分：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。其中，形参以逗号隔开，形参的列表位于一对圆括号之内，如下就是一个函数的定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">funca</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;hello world!!!&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h2><p>在C++语言中，名字有作用域，对象有生命周期（lifetime）。理解这两个概念非常重要。 · 名字的作用域是程序文本的一部分，名字在其中可见。 · 对象的生命周期是程序执行过程中该对象存在的一段时间。 如我们所知，函数体是一个语句块。块构成一个新的作用域，我们可以在其中定义变量。形参和函数体内部定义的变量统称为局部变量（local variable）。它们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏（hide）在外层作用域中同名的其他所有声明中。</p>\n<h3 id=\"自动对象\"><a href=\"#自动对象\" class=\"headerlink\" title=\"自动对象\"></a>自动对象</h3><p>对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为自动对象（automatic object）。函数形参和函数内部定义的普通变量都是自动对象。</p>\n<h3 id=\"局部静态对象\"><a href=\"#局部静态对象\" class=\"headerlink\" title=\"局部静态对象\"></a>局部静态对象</h3><p>某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型从而获得这样的对象。局部静态对象（local static object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">count_calls</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用结束后，这个值仍然有效</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">size_t</span> ctr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ++ctr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i != <span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">count_calls</span>() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段程序将输出从1到10（包括10在内）的数字。在控制流第一次经过ctr的定义之前，ctr被创建并初始化为0。每次调用将ctr加1并返回新值。每次执行count_calls函数时，变量ctr的值都已经存在并且等于函数上一次退出时ctr的值。因此，第二次调用时ctr的值是1，第三次调用时ctr的值是2，以此类推。 局部静态变量赋初值只在第一次执行时赋初值的操作，以后再执行都不会进行赋初值的操作。而且生命周期随着程序结束才结束。</p>\n<h2 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h2><h3 id=\"值传递\"><a href=\"#值传递\" class=\"headerlink\" title=\"值传递\"></a>值传递</h3><p>函数的形参如果是非引用类型则是值传递,函数内部修改形参不会影响到外部实参的值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void nochange(int a)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    a--;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    int m = 6;</span><br><span class=\"line\">    nochange(m);</span><br><span class=\"line\">    cout &lt;&lt; m &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<p>程序输出5和6，在函数内部输出的是5，在函数外部输出的是6，可见值传递不会改变实参的值，如果要改变实参的值可以通过引用或者指针操作。</p>\n<h3 id=\"指针形参\"><a href=\"#指针形参\" class=\"headerlink\" title=\"指针形参\"></a>指针形参</h3><p>指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void change(int *p)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    (*p)--;</span><br><span class=\"line\">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int m = 6;</span><br><span class=\"line\">change(&amp;m);</span><br><span class=\"line\">cout &lt;&lt; m &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<p>输出5，5 p指向了m的地址，所以*p取到的是m的空间数据，这样就达到修改m的效果。</p>\n<h3 id=\"传引用参数\"><a href=\"#传引用参数\" class=\"headerlink\" title=\"传引用参数\"></a>传引用参数</h3><p>函数参数为引用类型可以达到通过函数内部修改外部实参的效果，也可以减少传递参数造成的copy开销，拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void change(int &amp;ra)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ra--;</span><br><span class=\"line\">    cout &lt;&lt; ra &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int m = 6;</span><br><span class=\"line\">change(m);</span><br><span class=\"line\">cout &lt;&lt; m &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<p>输出两个5，参数为引用类型，可以通过函数内部修改外部实参的值。 我们准备编写一个函数比较两个string对象的长度。因为string对象可能会非常长，所以应该尽量避免直接拷贝它们，这时使用引用形参是比较明智的选择。又因为比较长度无须改变string对象的内容，所以把形参定义成对常量的引用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool isShorter(const string &amp;s1, const string &amp;s2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return s1.size() &lt; s2.size();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用引用形参返回额外信息\"><a href=\"#使用引用形参返回额外信息\" class=\"headerlink\" title=\"使用引用形参返回额外信息\"></a>使用引用形参返回额外信息</h3><p>一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。举个例子，我们定义一个名为find_char的函数，它返回在string对象中某个指定字符第一次出现的位置。同时，我们也希望函数能返回该字符出现的总次数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string ::size_type find_char(const string &amp;s, char c, string::size_type &amp;occurs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //第一次出现的位置(如果有的话)</span><br><span class=\"line\">    auto ret = s.size();</span><br><span class=\"line\">    //设置表示出现次数的形参的值</span><br><span class=\"line\">    occurs = 0;</span><br><span class=\"line\">    for (decltype(ret) i = 0; i != s.size(); ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (s[i] == c)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (ret == s.size())</span><br><span class=\"line\">                //记录c第一次出现的位置</span><br><span class=\"line\">                ret = i;</span><br><span class=\"line\"></span><br><span class=\"line\">            //出现的次数+1</span><br><span class=\"line\">            ++occurs;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参数为数组\"><a href=\"#参数为数组\" class=\"headerlink\" title=\"参数为数组\"></a>参数为数组</h3><p>当函数的参数为数组时，一般都显示传递一个数组的大小参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// const int ia[]等价于const int * ia</span><br><span class=\"line\">// size表示数组的大小，将它显示地传给函数用于控制对ia元素的访问</span><br><span class=\"line\">void print_array(const int ia[], size_t size)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (size_t i = 0; i != size; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; ia[i] &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主函数可以这样调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int j[] = &#123;0, 1&#125;;</span><br><span class=\"line\"> print_array(j, end(j) - begin(j));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组引用形参\"><a href=\"#数组引用形参\" class=\"headerlink\" title=\"数组引用形参\"></a>数组引用形参</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// arr是数组的引用，维度是类型的一部分</span><br><span class=\"line\">void print_arrayref(int (&amp;arr)[10])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (auto elem : arr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; elem &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"initializer-list形参\"><a href=\"#initializer-list形参\" class=\"headerlink\" title=\"initializer_list形参\"></a>initializer_list形参</h3><p>如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void error_msg(initializer_list&lt;string&gt; il)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (auto beg = il.begin(); beg != il.end(); beg++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; *beg &lt;&lt; &quot; &quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p>函数可以是void类型不返回数据，也可以是有返回值类型，但是不要返回局部变量的指针或者引用。如前所述，返回局部对象的引用是错误的；同样，返回局部对象的指针也是错误的。一旦函数完成，局部对象被释放，指针将指向一个不存在的对象。 也可以返回引用类型，这样返回值就可以作为左值使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char &amp;get_val(string &amp;str, string::size_type ix)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return str[ix];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  string s(&quot;a value&quot;);</span><br><span class=\"line\">    cout &lt;&lt; s &lt;&lt; endl; //输出a value</span><br><span class=\"line\">      //将s的第一个字母修改为A</span><br><span class=\"line\">    get_val(s, 0) = &#x27;A&#x27;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"返回值为数组的指针或引用\"><a href=\"#返回值为数组的指针或引用\" class=\"headerlink\" title=\"返回值为数组的指针或引用\"></a>返回值为数组的指针或引用</h2><p>因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// arrT是一个类型别名，他表示的类型含有10个整数数组</span><br><span class=\"line\">typedef int arrT[10];</span><br><span class=\"line\">// arrT的等价声明</span><br><span class=\"line\">using arrT2 = int[10];</span><br><span class=\"line\">// func返回一个指向含有10个整数的数组的指针</span><br><span class=\"line\">arrT *func(int);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"声明一个返回数组指针的函数\"><a href=\"#声明一个返回数组指针的函数\" class=\"headerlink\" title=\"声明一个返回数组指针的函数\"></a>声明一个返回数组指针的函数</h2><p>如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。因此，返回数组指针的函数形式如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type (*function(parameter_list))[dimension]</span><br></pre></td></tr></table></figure>\n\n<p>举个具体点的例子，下面这个func函数的声明没有使用类型别名：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int (*func(int i))[10];</span><br></pre></td></tr></table></figure>\n\n<p>· func（int i）表示调用func函数时需要一个int类型的实参。 · （＊func（int i））意味着我们可以对函数调用的结果执行解引用操作。 · （＊func（int i））[10]表示解引用func的调用将得到一个大小是10的数组。 · int （＊func（int i））[10]表示数组中的元素是int类型。</p>\n<h3 id=\"尾置类型\"><a href=\"#尾置类型\" class=\"headerlink\" title=\"尾置类型\"></a>尾置类型</h3><p>在C++11新标准中还有一种可以简化上述func声明的方法，就是使用尾置返回类型（trailing return type）。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// func接受一个int类型的实参，返回值为一个指针</span></span><br><span class=\"line\"><span class=\"comment\">//该指针指向含有10个整数的数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> -&gt; <span class=\"title\">int</span> <span class=\"params\">(*)</span>[10]</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用decltype\"><a href=\"#使用decltype\" class=\"headerlink\" title=\"使用decltype\"></a>使用decltype</h3><p>如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> odd[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> even[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//返回一个指针，该指针指向含有5个整数的数组</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(odd) *<span class=\"built_in\">arrPtr</span>(<span class=\"type\">int</span> i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (i % <span class=\"number\">2</span>) ? &amp;odd : &amp;even;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><p>如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载（overloaded）函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *cp)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">int</span> *beg, <span class=\"type\">const</span> <span class=\"type\">int</span> *end)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">int</span> ia[], <span class=\"type\">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>利用const_cast实现两个返回最小字符串的函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">const</span> string &amp;<span class=\"title\">shorterString</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;s1, <span class=\"type\">const</span> string &amp;s2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s1.<span class=\"built_in\">size</span>() &lt;= s2.<span class=\"built_in\">size</span>() ? s1 : s2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">string &amp;<span class=\"title\">shorterString</span><span class=\"params\">(string &amp;s1, string &amp;s2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> &amp;r = <span class=\"built_in\">shorterString</span>(<span class=\"built_in\">const_cast</span>&lt;<span class=\"type\">const</span> string &amp;&gt;(s1), <span class=\"built_in\">const_cast</span>&lt;<span class=\"type\">const</span> string &amp;&gt;(s2));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">const_cast</span>&lt;string &amp;&gt;(r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"默认实参\"><a href=\"#默认实参\" class=\"headerlink\" title=\"默认实参\"></a>默认实参</h2><p>我们可以对函数形参设置默认值，如果不传实参，则用形参默认值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> string::size_type sz;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">screen</span><span class=\"params\">(sz ht = <span class=\"number\">24</span>, sz wh = <span class=\"number\">80</span>, <span class=\"type\">char</span> back = <span class=\"string\">&#x27; &#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。 使用时可以</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数形参分别为100,200,&#x27;a&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">screen</span>(<span class=\"number\">100</span>,<span class=\"number\">200</span>,<span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">//函数形参分别为100,200,&#x27; &#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">screen</span>(<span class=\"number\">100</span>,<span class=\"number\">200</span>);</span><br><span class=\"line\"><span class=\"comment\">//函数形参分别为24,80,&#x27; &#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">screen</span>();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"内联函数\"><a href=\"#内联函数\" class=\"headerlink\" title=\"内联函数\"></a>内联函数</h2><p>内联函数可避免函数调用的开销将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开 constexpr函数（constexpr function）是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">constexpr</span> <span class=\"type\">int</span> <span class=\"title\">new_sz</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">42</span>; &#125;</span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"type\">int</span> foo = <span class=\"built_in\">new_sz</span>();</span><br></pre></td></tr></table></figure>\n\n<p>执行该初始化任务时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。 我们允许constexpr函数的返回值并非一个常量：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">constexpr</span> <span class=\"type\">size_t</span> <span class=\"title\">scale</span><span class=\"params\">(<span class=\"type\">size_t</span> cnt)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">new_sz</span>() * cnt; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>当scale的实参是常量表达式时，它的返回值也是常量表达式；反之则不然：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//正确，scale(2)返回的是常量</span></span><br><span class=\"line\"><span class=\"type\">int</span> arr[<span class=\"built_in\">scale</span>(<span class=\"number\">2</span>)];</span><br><span class=\"line\"><span class=\"comment\">//i不是常量，scale返回的不是常量</span></span><br><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">//编译器报错</span></span><br><span class=\"line\"><span class=\"type\">int</span> arr2[<span class=\"built_in\">scale</span>(i)];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h2><p>函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pf指向一个函数,该函数的参数是两个const string 的引用，返回bool类型</span></span><br><span class=\"line\"><span class=\"built_in\">bool</span> (*pf)(<span class=\"type\">const</span> string &amp;, <span class=\"type\">const</span> string &amp;);</span><br></pre></td></tr></table></figure>\n\n<p>从我们声明的名字开始观察，pf前面有个＊，因此pf是指针；右侧是形参列表，表示pf指向的是函数；再观察左侧，发现函数的返回类型是布尔值。因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。 ＊pf两端的括号必不可少。如果不写这对括号，则pf2是一个返回值为bool指针的函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明一个名为pf2的函数返回值类型为bool*</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> *<span class=\"title\">pf2</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;, <span class=\"type\">const</span> string &amp;)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要想声明一个返回函数指针的函数，最简单的办法是使用类型别名</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// F是函数类型，不是指针</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> F = <span class=\"built_in\">int</span>(<span class=\"type\">int</span> *, <span class=\"type\">int</span>);</span><br><span class=\"line\"><span class=\"comment\">// PF是指针类型</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> PF = <span class=\"built_in\">int</span> (*)(<span class=\"type\">int</span> *, <span class=\"type\">int</span>);</span><br></pre></td></tr></table></figure>\n\n<p>f1,f2,f3都是返回函数指针的函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">F *<span class=\"title\">f1</span><span class=\"params\">(<span class=\"type\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">PF <span class=\"title\">f2</span><span class=\"params\">(<span class=\"type\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">int</span> (*<span class=\"built_in\">f3</span>(<span class=\"type\">int</span>))(<span class=\"type\">int</span> *, <span class=\"type\">int</span>);</span><br></pre></td></tr></table></figure>\n\n<p>对于f3的声明，按照由内向外的顺序阅读这条声明语句：我们看到f3有形参列表，所以f3是个函数；f3前面有*，所以f3返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int。 我们可以使用尾置声明</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">f4</span><span class=\"params\">(<span class=\"type\">int</span>)</span> -&gt; <span class=\"title\">int</span> <span class=\"params\">(*)</span><span class=\"params\">(<span class=\"type\">int</span> *, <span class=\"type\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">string::size_type <span class=\"title\">sumLength</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;, <span class=\"type\">const</span> string &amp;)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//根据形参取值，getFcn函数返回值为指向sumLength的指针</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(sumLength) *<span class=\"built_in\">getFcn</span>(<span class=\"type\">const</span> string &amp;);</span><br></pre></td></tr></table></figure>\n\n<p>以下几种调用都是正常的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> PF = <span class=\"built_in\">int</span> (*)(<span class=\"type\">int</span> *, <span class=\"type\">int</span>*);</span><br><span class=\"line\"><span class=\"keyword\">using</span> F =  <span class=\"built_in\">int</span>(<span class=\"type\">int</span> *, <span class=\"type\">int</span> *);</span><br><span class=\"line\">PF test1 = &amp;test;</span><br><span class=\"line\">PF test2 = test;</span><br><span class=\"line\">F* test3 = test;</span><br><span class=\"line\"><span class=\"built_in\">test1</span>(<span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\"><span class=\"built_in\">test2</span>(<span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">(*test2)(<span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\"><span class=\"built_in\">test3</span>(<span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br></pre></td></tr></table></figure>","feature":true,"text":"一个典型的函数（function）定义包括...","permalink":"/post/函数","photos":[],"count_time":{"symbolsCount":"7.9k","symbolsTime":"7 mins."},"categories":[{"name":"C++基础","slug":"C-基础","count":8,"path":"api/categories/C-基础.json"}],"tags":[{"name":"C++","slug":"C","count":18,"path":"api/tags/C.json"},{"name":"函数","slug":"函数","count":2,"path":"api/tags/函数.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">局部变量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">自动对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">局部静态对象</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92\"><span class=\"toc-text\">参数传递</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%80%BC%E4%BC%A0%E9%80%92\"><span class=\"toc-text\">值传递</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%87%E9%92%88%E5%BD%A2%E5%8F%82\"><span class=\"toc-text\">指针形参</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">传引用参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E5%BD%A2%E5%8F%82%E8%BF%94%E5%9B%9E%E9%A2%9D%E5%A4%96%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">使用引用形参返回额外信息</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E4%B8%BA%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">参数为数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8%E5%BD%A2%E5%8F%82\"><span class=\"toc-text\">数组引用形参</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#initializer-list%E5%BD%A2%E5%8F%82\"><span class=\"toc-text\">initializer_list形参</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">返回值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%BA%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88%E6%88%96%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">返回值为数组的指针或引用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%9A%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">声明一个返回数组指针的函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%BE%E7%BD%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">尾置类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8decltype\"><span class=\"toc-text\">使用decltype</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">函数重载</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82\"><span class=\"toc-text\">默认实参</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">内联函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88\"><span class=\"toc-text\">函数指针</span></a></li></ol>","author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"C++模版","uid":"59f4fe88c44206beeb3d56cc24c7cea8","slug":"C++模板","date":"2021-07-16T10:50:36.000Z","updated":"2024-06-11T18:00:37.751Z","comments":true,"path":"api/articles/C++模板.json","keywords":null,"cover":"img/c01.jpg","text":"模板就是建立通用的模具，大大提高复用性...","permalink":"/post/C++模板","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"C++高级","slug":"C-高级","count":9,"path":"api/categories/C-高级.json"}],"tags":[{"name":"C++","slug":"C","count":18,"path":"api/tags/C.json"},{"name":"函数模版","slug":"函数模版","count":1,"path":"api/tags/函数模版.json"},{"name":"类模版","slug":"类模版","count":1,"path":"api/tags/类模版.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":true},"next_post":{"title":"Leetcode2806. 取整购买后的账户余额","uid":"7c2197de16b3c7f32cf086f091a02f09","slug":"Leetcode2806. 取整购买后的账户余额","date":"2024-06-11T16:11:00.000Z","updated":"2024-06-11T17:56:01.811Z","comments":true,"path":"api/articles/Leetcode2806. 取整购买后的账户余额.json","keywords":null,"cover":"img/lc.png","text":"一开始，你的银行账户里有 100 块钱。 给你一个整数purchaseAmount ，它表示你在一次购买中愿意支出的","permalink":"/post/Leetcode2806. 取整购买后的账户余额","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"LeetCode","slug":"LeetCode","count":4,"path":"api/categories/LeetCode.json"}],"tags":[{"name":"LeetCode","slug":"LeetCode","count":4,"path":"api/tags/LeetCode.json"}],"author":{"name":"kiyose408","slug":"blog-author","avatar":"img/kiyose.png","link":"/","description":"强风吹拂~","socials":{"github":"https://github.com/kiyose408","twitter":"","stackoverflow":"https://stackoverflow.com/users/22586365/kiyose408","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_4492248","juejin":"https://juejin.cn/user/3941068096931262","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/kiyose408"}}}},"feature":null}}